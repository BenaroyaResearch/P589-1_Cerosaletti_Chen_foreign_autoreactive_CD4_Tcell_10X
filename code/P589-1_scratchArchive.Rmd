---
title: "10x of foreign Ag specific Tconv and Treg in T1D"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Author: Thomas H. Edwards
# Collaborators: Karen Cerosaletti, Janice Chen, Alex Hu, Matt Dufort, Hannah DeBerg
setwd("/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X")

library(knitr)
library(dplyr)
library(tibble)
library(ggplot2)
library(GGally)
theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, size = 1),
      axis.text = element_text(colour = "black"),
      axis.ticks = element_line(colour = "black"),
      legend.key = element_blank(),
      strip.text.x = element_text(size = 14, margin = margin(b = 2, t = 2)),
      strip.background = element_rect(fill = "white", colour = "black")))

library(ggthemes)
library(ggforce)
library(ggbeeswarm)
library(ggvenn)
library(viridis)
library(stringr)
library(readxl)
library(openxlsx)
library(kableExtra)
library(RColorBrewer)
library(plotly)
library(tidyr)
library(gtools)
library(data.table)
library(miscHelpers)
library(tcrGraph)
library(edgeR)
library(limma)
library(ggrepel)
library(ComplexHeatmap)
library(egg) # For ggarrange
library(ggpubr) # Also for ggarrange
library(umap)
library(igraph)
library(forcats)
library(Seurat)
library(apird)
library(randomcoloR)
library(rcartocolor)
library(paletteer)
library(circlize)
library(gridExtra)
library(ggpointdensity)
library(cowplot)
library(clusterSim) # for cluster-evaluation metrics
library(foreach) # for parallel for-loops
library(TCRtools) # for making circos plots with Matt D's code
library(scDEED)
library(dsb)
library(monocle3)
library(rstatix)
library(SeuratData)
library(SeuratWrappers)
library(magrittr)
library(purrr)
library(msigdbr)
library(clusterProfiler)
library(enrichplot)
library(alphahull) # for boundary curves around clusters
library(MASS) # for contour plots with density (provides kernal)
library(ggh4x)
opts_chunk$set(fig.width = 6, fig.height = 4.0, cache = TRUE, echo = FALSE, warning = FALSE, message = FALSE, cache.lazy = FALSE, results = "hide")
opts_knit$set(root.dir = "/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X")

options(stringsAsFactors = FALSE)

options(future.globals.maxSize = 1591289600)
```

```{r setUpDirectories, cache = TRUE}
baseDir <- "/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X"
dataInputDir <- file.path(baseDir, "data/input")
plotDir <- file.path(baseDir, "figures")
dataOutputDir <- file.path(baseDir, "data/output")
dataDate <- "2025-06-09"
filenameSuffix <- paste0("P589-1_autoreactive_CD4_Tcell_10X.", dataDate, "_")

P589_1Samples <- c("pool589-1_1",
  "pool589-1_2")
# /mnt/bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/
P589_1Files <- paste0("/Volumes/Bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/",
  P589_1Samples,
  "/outs/per_sample_outs/",
  P589_1Samples,
  "/count/sample_filtered_feature_bc_matrix.h5")

P589_1RawFiles <- paste0("/Volumes/Bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/",
  P589_1Samples,
  "/outs/multi/count/",
  "raw_feature_bc_matrix.h5")

poolOrder <- c("1", "2")
```

```{r defineUtilityFunctions}
# function for saving plots as both pdf and png
savePlot <- function(
    plot,
    plotDir,
    filename,
    height,
    width,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
    ) {
  # Ensure plotDir exists
  if (!dir.exists(plotDir)) dir.create(plotDir, recursive = TRUE)

  # Save as PDF
  if ("pdf" %in% formats) {
    pdf(file.path(plotDir, paste0(filenameSuffix, filename, ".pdf")), height = height, width = width) # nolint
    print(plot)
    dev.off()
  }

  # Save as PNG
  if ("png" %in% formats) {
    png(
      file.path(plotDir, paste0(filenameSuffix, filename, ".png")),
      height = height,
      width = width,
      units = units,
      res = dpi
    )
    print(plot)
    dev.off()
  }
}
```

```{r defineAirlinePlotFunction}

# this version colors cells by CITEseq/FB/TotalSeq surface marker gating cellType
airlinePlotFB <- function(seuratObj,
                          cloneIDColumn,
                          cloneID,
                          arcLinewidth = 0.2, # nolint
                          arcAlpha = 0.5,
                          savePlot = FALSE,
                          plotTitle, # string
                          plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }

  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellType") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cell type \nby TotalSeq") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = c("Treg" = "blue", "Tconv" = "red", "Other" = "grey")) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors cells by CITEseq/FB/TotalSeq surface marker gating cellType (DSB norm)
airlinePlotFBDSB <- function(seuratObj,
                             cloneIDColumn,
                             cloneIDs,
                             arcLinewidth = 0.2,
                             arcAlpha = 0.5,
                             savePlot = FALSE,
                             plotTitle, # string
                             plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellTypeDSB") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cell type \nby TotalSeq") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = c("Treg" = "blue", "Tconv" = "red", "Other" = "grey")) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors cells by CITEseq/FB/TotalSeq surface marker gating cellType
# and omits some labels, has larger label text throughout to look good on a poster
airlinePlotFBPoster <- function(seuratObj,
                                cloneIDColumn,
                                cloneIDs,
                                arcLinewidth = 0.4,
                                arcAlpha = 0.5,
                                savePlot = FALSE,
                                plotTitle, # string
                                plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellType") +
    # labs(title = "") +
    labs(title = plotTitle, color = "Cell type \nby TotalSeq") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = c("Treg" = "blue", "Tconv" = "red", "Other" = "grey")) +
    theme(aspect.ratio = 1,
      text = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.text = element_text(size = 16),
      legend.title = element_text(size = 16),
      strip.text = element_text(size = 16),
      plot.title = element_text(size = 16, face = "plain"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = "none")

  if (savePlot == TRUE) {

    pdf(file = file.path(plotDir, paste0(plotName, ".pdf")),
      width = 3.5,
      height = 3.5)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# # this version colors points by RNAseq clusters
# airlinePlot <- function(seuratObj,
#                         cloneIDColumn,
#                         cloneIDs,
#                         reductionName = "umap",
#                         arcLinewidth = 0.1,
#                         arcAlpha = 0.5,
#                         savePlot = FALSE,
#                         plotTitle, # string
#                         plotName = "AirlinePlot") {

#   DefaultAssay(seuratObj) <- "RNA"

#   # Make sure the specified reduction exists
#   if (is.null(seuratObj@reductions[[reductionName]])) {
#     stop(paste(reductionName, "must first be run on the Seurat object"))
#   }

#   # Make sure the clone ID column exists
#   if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
#     stop("Check that the clone ID column exists in the metadata")
#   }

#   # Link reduction coordinates to cloneIDs
#   reductionDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
#     dim1 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 1],
#     dim2 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 2])

#   # Filter the reductionDF to only include the cloneIDs of interest
#   reductionDF <- reductionDF %>%
#     dplyr::filter(cloneID %in% cloneIDs)

#   # create data frame to store links
#   curves.tmp <-
#     data.frame(
#       cloneID = character(),
#       x = numeric(),
#       y = numeric(),
#       xend = numeric(),
#       yend = numeric())

#   # loop over each clone, and extract coordinates for cells from the same clone
#   for (clone_id.tmp in na.omit(unique(reductionDF$cloneID))) {
#     clone_id_curves.tmp <- curves.tmp[0, ]
#     data_for_curves.tmp <-
#       reductionDF %>%
#       dplyr::filter(cloneID %in% clone_id.tmp)
#     for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
#       for (j in (i + 1):nrow(data_for_curves.tmp)) {
#         clone_id_curves.tmp <-
#           rbind(
#             clone_id_curves.tmp,
#             list(
#               cloneID =
#                 data_for_curves.tmp$cloneID[i],
#               x = data_for_curves.tmp$dim1[i],
#               y = data_for_curves.tmp$dim2[i],
#               xend = data_for_curves.tmp$dim1[j],
#               yend = data_for_curves.tmp$dim2[j]))
#       }
#     }
#     curves.tmp <-
#       rbind(curves.tmp, clone_id_curves.tmp)
#   }

#   gPlot <- DimPlot(object = seuratObj, reduction = reductionName, group.by = "seurat_clusters_DS") +
#     labs(title = plotTitle, x = paste(reductionName, "1"), y = paste(reductionName, "2"), color = "RNA clusters") +
#     geom_curve(
#       data = curves.tmp,
#       mapping = aes(x = x, y = y, xend = xend, yend = yend),
#       linewidth = arcLinewidth,
#       alpha = arcAlpha)  +
#     scale_color_manual(values = palRNAClusters2) +
#     theme(aspect.ratio = 1)

#   if (savePlot == TRUE) {

#     png(file = file.path(plotDir, paste0(plotName, ".png")),
#       width = 7,
#       height = 5.5,
#       units = "in",
#       res = 600)

#     print(gPlot)

#     invisible(dev.off())
#   }

#   return(gPlot)
# }

# this version colors cells by CellTypist cell type calling
airlinePlotCT <- function(seuratObj,
                          cloneIDColumn,
                          cloneIDs,
                          arcLinewidth = 0.1,
                          arcAlpha = 0.5,
                          savePlot = FALSE,
                          plotTitle, # string
                          plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellTypistCalling") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cell type \nby CellTypist") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = palCellTypist) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

airlinePlotCellType <- function(seuratObj,
                                cloneIDColumn,
                                cloneIDs,
                                reductionName = "umap",
                                arcLinewidth = 0.1,
                                arcAlpha = 0.5,
                                savePlot = FALSE,
                                plotTitle, # string
                                plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure the specified reduction exists
  if (is.null(seuratObj@reductions[[reductionName]])) {
    stop(paste(reductionName, "must first be run on the Seurat object"))
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }

  # Link reduction coordinates to cloneIDs
  reductionDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    dim1 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 1],
    dim2 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 2])

  # Filter the reductionDF to only include the cloneIDs of interest
  reductionDF <- reductionDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(reductionDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      reductionDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$dim1[i],
              y = data_for_curves.tmp$dim2[i],
              xend = data_for_curves.tmp$dim1[j],
              yend = data_for_curves.tmp$dim2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = reductionName, group.by = "cellType") +
    labs(title = plotTitle, x = paste(reductionName, "1"), y = paste(reductionName, "2"), color = "Cell type") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = palCellType) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors points by DonorId
airlinePlotDonorId <- function(seuratObj,
                               cloneIDColumn,
                               cloneIDs,
                               arcLinewidth = 0.2,
                               arcAlpha = 0.5,
                               savePlot = FALSE,
                               plotTitle,
                               plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "donorIdFigures") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Donor ID") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = palDonorId) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

airlinePlot <- function(seuratObj,
                        tcrPairs,
                        reductionName = "umap",
                        arcLinewidth = 0.1,
                        arcAlpha = 0.5,
                        colorPalette = palRNAClusters,
                        plotTitle, # string
                        savePlot = TRUE,
                        plotName = "AirlinePlot",
                        minClones = 2) { # New parameter added

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure the specified reduction exists
  if (is.null(seuratObj@reductions[[reductionName]])) {
    stop(paste(reductionName, "must first be run on the Seurat object"))
  }

  # subset tcrPairs down to the barcodes present in the seuratObj
  tcrPairs <- tcrPairs[tcrPairs$barcode %in% seurat.tmp$barcode, ]

  # Determine clone IDs based on fullLengthNT_a and fullLengthNT_b
  tcrPairs$cloneID <- paste(tcrPairs$fullLengthNTa, tcrPairs$fullLengthNTb, sep = "_")

  # Filter out clones that do not meet the minClones threshold
  cloneCounts <- table(tcrPairs$cloneID)
  validClones <- names(cloneCounts[cloneCounts >= minClones])
  tcrPairs <- tcrPairs[tcrPairs$cloneID %in% validClones, ]

  # Link reduction coordinates to cloneIDs
  reductionDF <- data.frame(barcode = rownames(seuratObj@meta.data),
    dim1 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 1],
    dim2 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 2])

  # Merge reductionDF with TCR pairs data
  reductionDF <- merge(reductionDF, tcrPairs, by.x = "barcode", by.y = "barcode")

  # Create data frame to store links
  curves.tmp <- data.frame(
    cloneID = character(),
    x = numeric(),
    y = numeric(),
    xend = numeric(),
    yend = numeric()
  )

  # Loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(reductionDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <- reductionDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <- rbind(
          clone_id_curves.tmp,
          list(
            cloneID = data_for_curves.tmp$cloneID[i],
            x = data_for_curves.tmp$dim1[i],
            y = data_for_curves.tmp$dim2[i],
            xend = data_for_curves.tmp$dim1[j],
            yend = data_for_curves.tmp$dim2[j]
          )
        )
      }
    }
    curves.tmp <- rbind(curves.tmp, clone_id_curves.tmp)
  }

  curves.tmp <- na.omit(curves.tmp)

  gPlot <- DimPlot(
    object = seuratObj,
    reduction = reductionName,
    group.by = "seurat_clusters_DS"
  ) +
    scale_color_manual(values = colorPalette) +
    labs(
      title = plotTitle,
      x = "UMAP 1",
      y = "UMAP 2",
      color = "RNA clusters"
    ) +
    geom_curve(
      data = curves.tmp,
      aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha,
      color = "black",
      inherit.aes = FALSE
    ) +
    theme(aspect.ratio = 1)


  if (savePlot == TRUE) {
    # png(file = file.path(plotDir, paste0(filenameSuffix, plotName, ".png")),
    #   width = 7,
    #   height = 5.5,
    #   units = "in",
    #   res = 600)
    pdf(file = file.path(plotDir, paste0(filenameSuffix, plotName, ".pdf")),
      width = 7,
      height = 5.5)
    print(gPlot)
    invisible(dev.off())
  }

  return(gPlot)
}



airlinePlot <- function(seuratObj,
                        tcrPairs,
                        reductionName = "umap",
                        displayVariable = "seurat_clusters_DS", # variable to color the UMAP by
                        arcLinewidth = 0.1,
                        arcAlpha = 0.5,
                        colorPalette = palRNAClusters,
                        plotTitle, # string
                        colorString = "RNA Clusters", # string for the name of the legend
                        savePlot = TRUE,
                        plotName = "AirlinePlot",
                        minClones = 2) { # New parameter added

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure the specified reduction exists
  if (is.null(seuratObj@reductions[[reductionName]])) {
    stop(paste(reductionName, "must first be run on the Seurat object"))
  }

  # subset tcrPairs down to the barcodes present in the seuratObj
  tcrPairs <- tcrPairs[tcrPairs$barcode %in% seurat.tmp$barcode, ]

  # Determine clone IDs based on fullLengthNT_a and fullLengthNT_b
  tcrPairs$cloneID <- paste(tcrPairs$fullLengthNTa, tcrPairs$fullLengthNTb, sep = "_")

  # Filter out clones that do not meet the minClones threshold
  cloneCounts <- table(tcrPairs$cloneID)
  validClones <- names(cloneCounts[cloneCounts >= minClones])
  tcrPairs <- tcrPairs[tcrPairs$cloneID %in% validClones, ]

  # Link reduction coordinates to cloneIDs
  reductionDF <- data.frame(barcode = rownames(seuratObj@meta.data),
    dim1 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 1],
    dim2 = seuratObj@reductions[[reductionName]]@cell.embeddings[, 2])

  # Merge reductionDF with TCR pairs data
  reductionDF <- merge(reductionDF, tcrPairs, by.x = "barcode", by.y = "barcode")

  # Create data frame to store links
  curves.tmp <- data.frame(
    cloneID = character(),
    x = numeric(),
    y = numeric(),
    xend = numeric(),
    yend = numeric()
  )

  # Loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(reductionDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <- reductionDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <- rbind(
          clone_id_curves.tmp,
          list(
            cloneID = data_for_curves.tmp$cloneID[i],
            x = data_for_curves.tmp$dim1[i],
            y = data_for_curves.tmp$dim2[i],
            xend = data_for_curves.tmp$dim1[j],
            yend = data_for_curves.tmp$dim2[j]
          )
        )
      }
    }
    curves.tmp <- rbind(curves.tmp, clone_id_curves.tmp)
  }

  curves.tmp <- na.omit(curves.tmp)

  gPlot <- DimPlot(
    object = seuratObj,
    reduction = reductionName,
    group.by = displayVariable
  ) +
    scale_color_manual(values = colorPalette) +
    labs(
      title = plotTitle,
      x = "UMAP 1",
      y = "UMAP 2",
      color = colorString
    ) +
    geom_curve(
      data = curves.tmp,
      aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha,
      color = "black",
      inherit.aes = FALSE
    ) +
    theme(aspect.ratio = 1)


  if (savePlot == TRUE) {
    # png(file = file.path(plotDir, paste0(filenameSuffix, plotName, ".png")),
    #   width = 7,
    #   height = 5.5,
    #   units = "in",
    #   res = 600)
    pdf(file = file.path(plotDir, paste0(filenameSuffix, plotName, ".pdf")),
      width = 7,
      height = 5.5)
    print(gPlot)
    invisible(dev.off())
  }

  return(gPlot)
}
```

# ```{r readP589_1}
# gexAb <- Read10X_h5(P589_1Files[1])

# processP589_1 <- function(sample) {
#   print(sample) # debugging

#   gexAb <- Read10X_h5(sample)

#   # seuratSample <- CreateSeuratObject(counts = gexAb,
#   #                                    min.features = 100,
#   #                                    min.cells = 3)
#   # note: removing min.features prevents the error: Error: No feature overlap between existing object and new layer data
#   seuratSample <- CreateSeuratObject(counts = gexAb,
#     min.cells = 3)

#   # Clean memory
#   #   remove(gexAb)

#   seuratSample[["sample"]] <- str_extract(sample, "pool[1-9][1-9][1-9]-1_[1-9]")
#   seuratSample[["percentMT"]] <- PercentageFeatureSet(seuratSample, pattern = "^MT-")

#   return(seuratSample)

# }

# gexP589_1 <- lapply(P589_1Files, processP589_1)
# ```

```{r read10XGEXDataFromAllFlowcells}
gexAbObjects <- lapply(P589_1Files, Read10X_h5)

gexObjects <- list(gexAbObjects[[1]]$`Gene Expression`,
  gexAbObjects[[2]]$`Gene Expression`)

abObjects <- list(gexAbObjects[[1]]$`Antibody Capture`,
  gexAbObjects[[2]]$`Antibody Capture`)

# # temp
pool1HT <- c("CerosalettiLab632811_CD3CD28",
  "CerosalettiLab448473_CD3CD28",
  "CerosalettiLab839987_CD3CD28",
  "CerosalettiLab632811_CEFX",
  "CerosalettiLab448473_CEFX",
  "CerosalettiLab839987_CEFX",
  "CerosalettiLab632811_Islet",
  "CerosalettiLab448473_Islet",
  "CerosalettiLab839987_Islet")

pool1HTVars <- c("CerosalettiLab632811-CD3CD28",
  "CerosalettiLab448473-CD3CD28",
  "CerosalettiLab839987-CD3CD28",
  "CerosalettiLab632811-CEFX",
  "CerosalettiLab448473-CEFX",
  "CerosalettiLab839987-CEFX",
  "CerosalettiLab632811-Islet",
  "CerosalettiLab448473-Islet",
  "CerosalettiLab839987-Islet")

pool2HT <- c("CerosalettiLab1464776_CD3CD28",
  "CerosalettiLab1059994_CD3CD28",
  "CerosalettiLab942655_CD3CD28",
  "CerosalettiLab1464776_CEFX",
  "CerosalettiLab1059994_CEFX",
  "CerosalettiLab942655_CEFX",
  "CerosalettiLab1464776_Islet",
  "CerosalettiLab1059994_Islet",
  "CerosalettiLab942655_Islet")

pool2HTVars <- c("CerosalettiLab1464776-CD3CD28",
  "CerosalettiLab1059994-CD3CD28",
  "CerosalettiLab942655-CD3CD28",
  "CerosalettiLab1464776-CEFX",
  "CerosalettiLab1059994-CEFX",
  "CerosalettiLab942655-CEFX",
  "CerosalettiLab1464776-Islet",
  "CerosalettiLab1059994-Islet",
  "CerosalettiLab942655-Islet")

# Make a list of Seurat gene expression count objects
# Set parameters to define cells
seuratObjects <- lapply(gexObjects,
  function(x) CreateSeuratObject(counts = x,
    min.features = 100,
    min.cells = 3))


# Read in raw samples individually (for BSD normalizationm)
rawGexAbObjects <- lapply(P589_1RawFiles, Read10X_h5)

rawGexObjects <- list(rawGexAbObjects[[1]]$`Gene Expression`,
  rawGexAbObjects[[2]]$`Gene Expression`)

rawAbObjects <- list(rawGexAbObjects[[1]]$`Antibody Capture`,
  rawGexAbObjects[[2]]$`Antibody Capture`)

# Make a list of Seurat gene expression count objects
# Set parameters to define cells
seuratRawObjects <- lapply(rawGexObjects,
  function(x) CreateSeuratObject(counts = x,
    min.features = 0,
    min.cells = 0))
```

```{r addFBData}
# Create a separate "FB" assay slot within the Seurat object
# This is preferable over adding the ab data as metadata because
# it allows for seurat's normalization routine to be run on it.

# Separate hastags into a HT object assay, separate surface antibody tags into an FB (feature barcode) object assay
for (i in 1:length(seuratObjects)) {
  seurat <- seuratObjects[[i]]

  ht <- abObjects[[i]]
  if (i == 1) {
    ht <- ht[c("CerosalettiLab632811_CD3CD28",
      "CerosalettiLab448473_CD3CD28",
      "CerosalettiLab839987_CD3CD28",
      "CerosalettiLab632811_CEFX",
      "CerosalettiLab448473_CEFX",
      "CerosalettiLab839987_CEFX",
      "CerosalettiLab632811_Islet",
      "CerosalettiLab448473_Islet",
      "CerosalettiLab839987_Islet"), ]

  } else if (i == 2) {
    ht <- ht[c("CerosalettiLab1464776_Islet",
      "CerosalettiLab1464776_CEFX",
      "CerosalettiLab1059994_Islet",
      "CerosalettiLab1059994_CEFX",
      "CerosalettiLab942655_Islet",
      "CerosalettiLab942655_CEFX",
      "CerosalettiLab1464776_CD3CD28",
      "CerosalettiLab1059994_CD3CD28",
      "CerosalettiLab942655_CD3CD28"), ]
  }
  fb <- abObjects[[i]]
  fb <- fb[c("anti-human CD154",
    "anti-human CD137",
    "anti-human CD69",
    "anti-human CD127",
    "anti-human CD25",
    "anti-human CD45RA",
    "anti-human CD45RO",
    "anti-human CCR7",
    "Mouse IgG1, _ isotype Ctrl"), ]

  keepCells <- colnames(seurat)

  ht <- ht[, keepCells]
  seurat[["HT"]] <- CreateAssayObject(ht)

  fb <- fb[, keepCells]
  seurat[["FB"]] <- CreateAssayObject(fb)

  seuratObjects[[i]] <- seurat

}

# now for the raw files
for (i in 1:length(seuratRawObjects)) {
  seurat <- seuratRawObjects[[i]]

  ht <- rawAbObjects[[i]]
  if (i == 1) {
    ht <- ht[c("CerosalettiLab632811_CD3CD28",
      "CerosalettiLab448473_CD3CD28",
      "CerosalettiLab839987_CD3CD28",
      "CerosalettiLab632811_CEFX",
      "CerosalettiLab448473_CEFX",
      "CerosalettiLab839987_CEFX",
      "CerosalettiLab632811_Islet",
      "CerosalettiLab448473_Islet",
      "CerosalettiLab839987_Islet"), ]

  } else if (i == 2) {
    ht <- ht[c("CerosalettiLab1464776_Islet",
      "CerosalettiLab1464776_CEFX",
      "CerosalettiLab1059994_Islet",
      "CerosalettiLab1059994_CEFX",
      "CerosalettiLab942655_Islet",
      "CerosalettiLab942655_CEFX",
      "CerosalettiLab1464776_CD3CD28",
      "CerosalettiLab1059994_CD3CD28",
      "CerosalettiLab942655_CD3CD28"), ]
  }
  fb <- rawAbObjects[[i]]
  fb <- fb[c("anti-human CD154",
    "anti-human CD137",
    "anti-human CD69",
    "anti-human CD127",
    "anti-human CD25",
    "anti-human CD45RA",
    "anti-human CD45RO",
    "anti-human CCR7",
    "Mouse IgG1, _ isotype Ctrl"), ]

  keepCells <- colnames(seurat)

  ht <- ht[, keepCells]
  seurat[["HT"]] <- CreateAssayObject(ht)

  fb <- fb[, keepCells]
  seurat[["FB"]] <- CreateAssayObject(fb)

  seuratRawObjects[[i]] <- seurat
}
```

```{r loadGeneLists}
# load the gene lists
geneListsTconv.df <-
  read.xlsx(file.path(dataInputDir, "CD4_Tconv_geneLists.xlsx")) %>%
  data.frame()

geneListsTreg.df <-
  read.xlsx(file.path(dataInputDir, "CD4_Treg_geneLists.xlsx")) %>%
  data.frame()

geneListsHCvsT1D.df <-
  read.xlsx(file.path(dataInputDir, "Presenacker_Treg_geneList.xlsx")) %>%
  data.frame()

geneListsTCR.df <-
  read.xlsx(file.path(dataInputDir, "TCR_geneList.xlsx")) %>%
  data.frame()

# read in the P390 cluster-defining genes
geneListsP390TconvCDGenes.df <- read.table(
  file.path(dataInputDir, "top20markers_P390Tconvs5.txt"),
  header = TRUE,
  sep = "\t"
) %>% data.frame()

geneListsP390TregCDGenes.df <- read.table(
  file.path(dataInputDir, "top20markers_P390Tregs3.txt"),
  header = TRUE,
  sep = "\t"
) %>% data.frame()
```

```{r loadTCRData}
# load the data
TCRsPool1.df <-
  read.csv(file.path(dataInputDir, "filtered_contig_annotations_pool1.csv")) %>%
  data.frame() %>%
  dplyr::mutate(barcode = paste0("1_", barcode))

TCRsPool2.df <-
  read.csv(file.path(dataInputDir, "filtered_contig_annotations_pool2.csv")) %>%
  data.frame() %>%
  dplyr::mutate(barcode = paste0("2_", barcode))

# merge the two pools
TCRs.df <- rbind(TCRsPool1.df, TCRsPool2.df)

# create a full-length nucleotide column
TCRs.df$fullLengthNT <- paste0(TCRs.df$fwr1_nt,
  TCRs.df$cdr1_nt,
  TCRs.df$fwr2_nt,
  TCRs.df$cdr2_nt,
  TCRs.df$fwr3_nt,
  TCRs.df$cdr3_nt,
  TCRs.df$fwr4_nt)

# create a full-length AA column
TCRs.df$fullLengthAA <- paste(TCRs.df$v_gene, TCRs.df$cdr3, TCRs.df$j_gene, sep = "_")
```

```{r callMultipletsFunctionDefinition}
# Remove cells with: a) 3+ alphas, b) cells with 2 alphas and 2 betas, and c) 2 betas
# Remove iNKT and MAIT cells
callMultiplets <- function(tcrs,
                           nAlphaCut = 3,
                           nBetaCut = 2,
                           alphaAndBetaCut = 2,
                           callINKT = TRUE,
                           callMAIT = TRUE) {
  # Count chains
  chainCounts <- tcrs %>%
    dplyr::group_by(barcode) %>%
    dplyr::summarise(nAlpha = sum(chain ==  "TRA"),
      nBeta = sum(chain == "TRB"))

  multiplets <- chainCounts %>%
    dplyr::filter(nAlpha > nAlphaCut |
      nBeta > nBetaCut |
      (nAlpha >= alphaAndBetaCut & nBeta >= alphaAndBetaCut))

  tcrs$multiplet <- tcrs$barcode %in% multiplets$barcode

  if (callMAIT == TRUE) {
    tcrs <- tcrs %>%
      dplyr::mutate(isMAIT = (str_detect(v_gene, "TRAV1-2") &
        str_detect(j_gene, "TRAJ(33|12|20)")))
  }

  if (callINKT == TRUE) {
    tcrs <- tcrs %>%
      dplyr::mutate(isINKT = (str_detect(v_gene, "TRAV10") &
        str_detect(j_gene, "TRAJ18")))
  }
  return(tcrs)
}
```

```{r callAndCleanMultipletsFromTCRs}
# call multiplets
TCRs.df <- callMultiplets(TCRs.df,
  nAlphaCut = 3,
  nBetaCut = 2,
  alphaAndBetaCut = 2,
  callINKT = TRUE,
  callMAIT = TRUE)

# 77 MAIT
# 153 MAIT
# 4260 multiplets

# for filtering the seurat object later
barcodesToFilter <- TCRs.df$barcode[which(TCRs.df$multiplet |
  TCRs.df$isMAIT |
  TCRs.df$isINKT)]

# remove multiplets, MAIT cells, and iNKT cells
cleanTCRs.df <- TCRs.df %>%
  dplyr::filter(!multiplet) %>%
  dplyr::filter(!isMAIT) %>%
  dplyr::filter(!isINKT)
```

```{r define_callClonesFunction}
# From a list of TCRs, call clones
# orig version
callClones <- function(tcrs,
                       cloneOption = "",
                       cloneColumnName = "CloneID",
                       chainOption = "both") {
  # Define acceptable options
  possibleCloneOptions <- c("CDR3", "VJandCDR3", "CDR3nt", "fullLengthNT")
  possibleChainOptions <- c("both", "alpha", "beta")

  # Validate cloneOption
  if (is.null(cloneOption) || length(cloneOption) != 1L || !cloneOption %in% possibleCloneOptions) {
    stop("'cloneOption' must be one of: 'CDR3', 'VJandCDR3', 'CDR3nt', 'fullLengthNT'")
  }

  # Validate chainOption
  if (is.null(chainOption) || length(chainOption) != 1L || !chainOption %in% possibleChainOptions) {
    stop("'chainOption' must be one of: 'both', 'alpha', 'beta'")
  }

  # Modify cloneColumnName and determine chains to process based on chainOption
  if (chainOption == "alpha") {
    cloneColumnName_new <- paste0(cloneColumnName, "_alpha")
    chains_to_process <- "TRA"
  } else if (chainOption == "beta") {
    cloneColumnName_new <- paste0(cloneColumnName, "_beta")
    chains_to_process <- "TRB"
  } else { # chainOption == "both"
    cloneColumnName_new <- cloneColumnName
    chains_to_process <- c("TRA", "TRB")
  }

  # Initialize the clone column with NA
  tcrs[[cloneColumnName_new]] <- NA

  # Assign cloneKey based on cloneOption
  if (cloneOption == "CDR3") {
    tcrs$cloneKey <- tcrs$cdr3
  } else if (cloneOption == "VJandCDR3") {
    tcrs$cloneKey <- fullLengthAA
  } else if (cloneOption == "CDR3nt") {
    tcrs$cloneKey <- tcrs$cdr3_nt
  } else if (cloneOption == "fullLengthNT") {
    tcrs$cloneKey <- tcrs$fullLengthNT
  }

  # Ensure cloneKey is atomic to avoid sort.list errors
  tcrs$cloneKey <- as.character(tcrs$cloneKey)

  # Filter TCRs based on chains to process
  tcrs_filtered <- dplyr::filter(tcrs, chain %in% chains_to_process)

  # Check if 'chain' column exists before proceeding
  if (!"chain" %in% colnames(tcrs_filtered)) {
    stop("The 'chain' column is missing from the dataframe.")
  }

  # Create cloneLookup by grouping by barcode and chain
  cloneLookup <- tcrs_filtered %>%
    dplyr::group_by(barcode, chain) %>%
    dplyr::summarise(key = paste(sort(unique(cloneKey)), collapse = "_"), .groups = "drop")

  # Create cloneDictionary with unique keys and assign clone IDs
  cloneDictionary <- cloneLookup %>%
    dplyr::ungroup() %>%
    dplyr::select(key) %>% # Retain only 'key' to ensure uniqueness
    dplyr::distinct() %>%
    dplyr::mutate(cloneID = paste0("Clone_", dplyr::row_number()))

  # Merge cloneDictionary back to cloneLookup to map keys to cloneIDs
  cloneLookup <- cloneLookup %>%
    dplyr::left_join(cloneDictionary, by = "key")

  # Retain only necessary columns for merging back
  cloneLookup <- cloneLookup %>%
    dplyr::select(barcode, chain, cloneID)

  # Merge cloneLookup with the original tcrs to assign cloneIDs
  tcrs <- tcrs %>%
    dplyr::left_join(cloneLookup, by = c("barcode", "chain"))

  # Assign cloneID to the appropriate cloneColumnName based on chainOption
  tcrs[[cloneColumnName_new]] <- ifelse(tcrs$chain %in% chains_to_process, tcrs$cloneID, NA)

  # Count how often each cloneID is observed
  cloneCounts <- cloneLookup %>%
    dplyr::group_by(cloneID) %>%
    dplyr::summarise(cloneFreq = n(), .groups = "drop")

  # Merge cloneCounts back to tcrs and create a counts column
  tcrs <- tcrs %>%
    dplyr::left_join(cloneCounts, by = "cloneID") %>%
    dplyr::mutate(cloneFreq = ifelse(chain %in% chains_to_process, cloneFreq, NA)) %>%
    dplyr::rename(!!paste0(cloneColumnName_new, "_counts") := cloneFreq)

  # Remove temporary cloneKey and cloneID columns
  tcrs <- tcrs %>%
    dplyr::select(-cloneKey, -cloneID)

  return(tcrs)
}
```

```{r callClonesDeprecated}
# alpha AND beta
cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3",
  cloneColumnName = "cdr3CloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3nt",
  cloneColumnName = "cdr3CloneID_nt")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "VJandCDR3",
  cloneColumnName = "threePointCloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "fullLengthNT",
  chainOption = "both",
  cloneColumnName = "fullLengthNTCloneID")

# alpha only
cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3",
  chainOption = "alpha",
  cloneColumnName = "cdr3CloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3nt",
  chainOption = "alpha",
  cloneColumnName = "cdr3CloneID_nt")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "VJandCDR3",
  chainOption = "alpha",
  cloneColumnName = "threePointCloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "fullLengthNT",
  chainOption = "alpha",
  cloneColumnName = "fullLengthNTCloneIDAlpha")

# beta only
cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3",
  chainOption = "beta",
  cloneColumnName = "cdr3CloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3nt",
  chainOption = "beta",
  cloneColumnName = "cdr3CloneID_nt")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "VJandCDR3",
  chainOption = "beta",
  cloneColumnName = "threePointCloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "fullLengthNT",
  chainOption = "beta",
  cloneColumnName = "fullLengthNTCloneIDBeta")

# try tcrGraph
cleanTCRs.tcrGraph.df <- cleanTCRs.df
cleanTCRs.tcrGraph.df$libid <- cleanTCRs.tcrGraph.df$barcode

myGraph.tmp <- makeTcrGraph(cleanTCRs.tcrGraph.df, link = "cdr3")
myGraphCDR3AAClones <- getClonesFromTcrGraph(myGraph.tmp)

myGraph.tmp <- makeTcrGraph(cleanTCRs.tcrGraph.df, link = "cdr3_nt")
myGraphCDR3NTClones <- getClonesFromTcrGraph(myGraph.tmp)

myfullLengthNTGraph.tmp <- makeTcrGraph(cleanTCRs.tcrGraph.df, link = "fullLengthNT")
myGraphFullLengthNTClones <- getClonesFromTcrGraph(myGraph.tmp)

myfullLengthAAGraph.tmp <- makeTcrGraph(cleanTCRs.tcrGraph.df, link = "fullLengthAA")
myGraphFullLengthAAClones <- getClonesFromTcrGraph(myGraph.tmp)

# # alpha AND beta
# cleanTCRs.df <- callClonesAlphaAndBeta(cleanTCRs.df,
#   cloneOption = "CDR3",
#   cloneColumnName = "cdr3CloneIDab")

# cleanTCRs.df <- callClonesAlphaAndBeta(cleanTCRs.df,
#   cloneOption = "CDR3nt",
#   cloneColumnName = "cdr3CloneID_ntab")

# cleanTCRs.df <- callClonesAlphaAndBeta(cleanTCRs.df,
#   cloneOption = "VJandCDR3",
#   cloneColumnName = "threePointCloneIDab")

# cleanTCRs.df <- callClonesAlphaAndBeta(cleanTCRs.df,
#   cloneOption = "fullLengthNT",
#   cloneColumnName = "fullLengthNTCloneIDab")
```

```{r alexHuCallPairsCode}
# finds all pairs of alpha/beta TCRs
# TCRs is a dataframe that has a detected TCR chain for each row (alpha or beta or gamma, etc.) This is the output of mixcr, and maybe something analogous for 10x. But the columns might be named something different for 10x.
tcrs$trinity <- paste(tcrs$v_gene, tcrs$junction, tcrs$j_gene, sep = "-")

combinePairs <- function(tcrDf) {
  a <- tcrDf[tcrDf$chain %in% c("TRA", "a"), ]
  b <- tcrDf[tcrDf$chain %in% c("TRB", "b"), ]
  commonlibs <- intersect(a$libid, b$libid) # get libids that have both an alpha or beta chain
  a <- a[a$libid %in% commonlibs, ]
  b <- b[b$libid %in% commonlibs, ]

  # Compute how many alpha/beta pairs there should be
  atab <- table(a$libid)
  btab <- table(b$libid)
  nPairs <- sum(atab[commonlibs] * btab[commonlibs])

  # initialize the pairs data frame
  # here the column "sample" refers to libid, but it could refer to barcode in 10x data
  pairs <- data.frame(CDR3b = rep("", nPairs),
    CDR3bnt = rep("", nPairs),
    TRBV = rep("", nPairs),
    TRBJ = rep("", nPairs),
    CDR3a = rep("", nPairs),
    CDR3ant = rep("", nPairs),
    TRAV = rep("", nPairs),
    TRAJ = rep("", nPairs),
    sample = rep("", nPairs),
    trinitya = rep("", nPairs),
    trinityb = rep("", nPairs))

  # Iterate through the tcr alphas and betas and fill out the pair dataframe
  k <- 1
  for (lib in commonlibs) {
    arows <- which(a$libid == lib)
    brows <- which(b$libid == lib)
    for (i in arows) {
      for (j in brows) {
        pairs[k, ] <- c(b$junction[j],
          b$full_nt_sequence[j],
          b$v_gene[j],
          b$j_gene[j],
          a$junction[i],
          a$full_nt_sequence[i],
          a$v_gene[i],
          a$j_gene[i],
          lib,
          a$trinity[i],
          b$trinity[j])
        k <- k + 1
      }
    }
  }
  return(pairs)
}

pairs <- combinePairs(tcrs)


# from chatGPT 20250414
combinePairs <- function(tcrDf) {
  a <- tcrDf[tcrDf$chain %in% c("TRA", "a"), ]
  b <- tcrDf[tcrDf$chain %in% c("TRB", "b"), ]
  commonbarcodes <- intersect(a$barcode, b$barcode) # get barcodes that have both an alpha or beta chain
  a <- a[a$barcode %in% commonbarcodes, ]
  b <- b[b$barcode %in% commonbarcodes, ]

  # Compute how many alpha/beta pairs there should be
  atab <- table(a$barcode)
  btab <- table(b$barcode)
  nPairs <- sum(atab[commonbarcodes] * btab[commonbarcodes])

  # Initialize the pairs data frame
  pairs <- data.frame(CDR3b = rep("", nPairs),
    CDR3bnt = rep("", nPairs),
    TRBV = rep("", nPairs),
    TRBJ = rep("", nPairs),
    CDR3a = rep("", nPairs),
    CDR3ant = rep("", nPairs),
    TRAV = rep("", nPairs),
    TRAJ = rep("", nPairs),
    barcode = rep("", nPairs),
    fullLengthNTa = rep("", nPairs),
    fullLengthNTb = rep("", nPairs))

  # Iterate through the TCR alphas and betas and fill out the pair dataframe
  k <- 1
  for (barcode in commonbarcodes) {
    arows <- which(a$barcode == barcode)
    brows <- which(b$barcode == barcode)
    for (i in arows) {
      for (j in brows) {
        pairs[k, ] <- c(b$cdr3[j],
          b$cdr3_nt[j],
          b$v_gene[j],
          b$j_gene[j],
          a$cdr3[i],
          a$cdr3_nt[i],
          a$v_gene[i],
          a$j_gene[i],
          barcode,
          a$fullLengthNT[i],
          b$fullLengthNT[j])
        k <- k + 1
      }
    }
  }
  return(pairs)
}

cleanTCRpairs.df <- combinePairs(cleanTCRs.df)


# note this just does NT
combinePairs10X <- function(tcrDf) {
  # Subset alpha and beta chains -- name them "a" and "b"
  a <- tcrDf[tcrDf$chain %in% c("TRA", "alpha"), ]
  b <- tcrDf[tcrDf$chain %in% c("TRB", "beta"), ]

  # Find barcodes that have both alpha and beta TCR chains
  commonBarcodes <- intersect(a$barcode, b$barcode)
  a <- a[a$barcode %in% commonBarcodes, ]
  b <- b[b$barcode %in% commonBarcodes, ]

  # Calculate how many alpha/beta combinations we expect
  aTab <- table(a$barcode)
  bTab <- table(b$barcode)
  nPairs <- sum(aTab[commonBarcodes] * bTab[commonBarcodes])

  # Initialize the result data frame
  # Here "sample" is just a placeholder name for the cells "barcode"
  pairs <- data.frame(
    CDR3b         = rep("", nPairs),
    CDR3b_nt      = rep("", nPairs),
    TRBV          = rep("", nPairs),
    TRBJ          = rep("", nPairs),
    CDR3a         = rep("", nPairs),
    CDR3a_nt      = rep("", nPairs),
    TRAV          = rep("", nPairs),
    TRAJ          = rep("", nPairs),
    barcode        = rep("", nPairs),
    fullLengthNT_b = rep("", nPairs),  # formerly "trinityb"
    fullLengthNT_a = rep("", nPairs)   # formerly "trinitya"
  )

  # Fill the result data frame by looping over all alpha+beta pairs per barcode
  k <- 1
  for (bc in commonBarcodes) {
    a_rows <- which(a$barcode == bc)
    b_rows <- which(b$barcode == bc)
    for (i in a_rows) {
      for (j in b_rows) {
        pairs[k, ] <- c(
          b$cdr3[j],
          b$fullLengthNT[j],
          b$v_gene[j],
          b$j_gene[j],
          a$cdr3[i],
          a$fullLengthNT[i],
          a$v_gene[i],
          a$j_gene[i],
          bc,
          b$fullLengthNT[j], # or keep your own naming (e.g. "fullLengthAA")
          a$fullLengthNT[i]
        )
        k <- k + 1
      }
    }
  }
  return(pairs)
}

cleanTCRpairs.df <- combinePairs10X(cleanTCRs.df)
```


```{r addMetaDataToTCRs}
# add seuratQCMergedCleaned@meta.data$stimulationFigures to cleanTCRs.df, matching on $barcode
metaData.df.tmp <- seuratQCMergedCleaned@meta.data

cleanTCRs.df <- cleanTCRs.df %>%
  left_join(metaData.df.tmp %>% dplyr::select(barcode, stimulationFigures, donorIdFigures), by = "barcode")

cleanTCRpairs.df <- cleanTCRpairs.df %>%
  left_join(metaData.df.tmp %>% dplyr::select(barcode, stimulationFigures, donorIdFigures), by = "barcode")

rm_tmp(ask = FALSE)
```

```{r alexHuTCRAnomalyCheckCode}
# Make graph
ntGraph <- makeTcrGraph(subTcrs, link = "full_nt_sequence")
# Call the clones from the graph
ntCloneDf <- getClonesFromTcrGraph(ntGraph, maxA = 10, maxB = 10, maxD = -1, maxG = -1, format = "compressed", link = "full_nt_sequence")
rownames(ntCloneDf) <- ntCloneDf$cloneId

myGraph.tmp <- makeTcrGraph(cleanTCRs.tcrGraph.df, link = "fullLengthNT")
myGraphFullLengthNTClones <- getClonesFromTcrGraph(myGraph.tmp)
rownames(myGraphFullLengthNTClones) <- myGraphFullLengthNTClones$cloneId
rownames(myGraphFullLengthAAClones) <- myGraphFullLengthAAClones$cloneId

betaNts <- unique(cleanTCRs.df$fullLengthNT[cleanTCRs.df$chain == "TRB"])
alphaNts <- unique(cleanTCRs.df$fullLengthNT[cleanTCRs.df$chain == "TRA"])
summarizeClone <- function(cloneDfRow) {
  numLibs <- length(strsplit(cloneDfRow["libs"], ",")[[1]])
  vgenes <- strsplit(cloneDfRow["vGenes"], ",")
  numAlphaVGenes <- sum(grepl("TRA", vgenes))
  numBetaVGenes <- sum(grepl("TRB", vgenes))

  jgenes <- strsplit(cloneDfRow["jGenes"], ",")
  numAlphaJGenes <- sum(grepl("TRA", jgenes))
  numBetaJGenes <- sum(grepl("TRB", jgenes))

  nts <- gsub(" ", "", strsplit(cloneDfRow["fullLengthNT"], ",")[[1]])
  numANts <- sum(nts %in% alphaNts)
  numBNts <- sum(nts %in% betaNts)

  return(c(cloneId = as.character(cloneDfRow["cloneId"]), libCount = numLibs,
    AVCount = numAlphaVGenes,
    BVCount = numBetaVGenes,
    AJCount = numAlphaJGenes,
    BJCount = numBetaJGenes,
    aCount = numANts,
    bCount = numBNts))
}
cloneSummary <- data.frame(t(apply(myGraphFullLengthNTClones, 1, summarizeClone)))
# Print out a table of clonotypes with the alpha and beta count info
print(table(paste0("a:", cloneSummary$aCount), paste0("b:", cloneSummary$bCount)))

# let's find the barcodes associated with 'anomalous' clones
# Subset clones with aCount == 2 or bCount == 2
selected_clones <- cloneSummary[cloneSummary$aCount == 2 | cloneSummary$bCount == 2, ]
selected_cloneIds <- selected_clones$cloneId

# Subset the graph for these clone IDs
selected_graph <- myGraphFullLengthNTClones[myGraphFullLengthNTClones$cloneId %in% selected_cloneIds, ]

# Extract barcodes from the "libs" column.
# (Assumes that if there are multiple barcodes they are separated by commas)
selected_barcodes_list <- lapply(selected_graph$libs, function(libStr) {
  # Remove spaces and split on comma
  unlist(strsplit(gsub(" ", "", libStr), ","))
})

# Flatten the list and take unique barcodes
selected_barcodes <- unique(unlist(selected_barcodes_list))

# Print or inspect the resulting set of barcodes
print(selected_barcodes)

anomalousTCRs.df <- cleanTCRs.df[cleanTCRs.df$barcode %in% selected_barcodes, ]
anomalousTCRs.df$libid <- anomalousTCRs.df$barcode

anomalousTCRs.DS.df <- anomalousTCRs.df %>%
  sample_n(size = 50)
# calculate a new TCRgraph for the anomalous clones
fullLengthNTAnomalousGraph <- makeTcrGraph(anomalousTCRs.df, link = "fullLengthNT")
fullLengthNTAnomalousGraphClones <- getClonesFromTcrGraph(fullLengthNTAnomalousGraph)
```

```{r visualizeTCRGraph}
png(file.path(plotDir,
  paste0(filenameSuffix, "anomalousFullLengthNTTCRGraphVis.png")),
height = 5,
width = 8,
units = "in",
res = 600)
plot(
  fullLengthNTAnomalousGraph,
  chainPalette = c("red", "blue", "purple", "magenta"),
  main = "TCR Clones Plot"
)
dev.off()
```

```{r add_qc_metrics_anno}
## Add % mito information, library name info
for (i in 1:length(seuratObjects)) {
  seurat <- seuratObjects[[i]]
  seurat[["percent_mt"]] <- PercentageFeatureSet(seurat, pattern = "^MT-")
  seurat[["pool"]] <- i
  seuratObjects[[i]] <- seurat
}

for (i in 1:length(seuratRawObjects)) {
  seurat <- seuratRawObjects[[i]]
  seurat[["percent_mt"]] <- PercentageFeatureSet(seurat, pattern = "^MT-")
  seurat[["pool"]] <- i
  seuratRawObjects[[i]] <- seurat
}
```

```{r plot_n_features, fig.height = 3, fig.width=3}
# Select QC cutoffs
nFeatureLow <- 1000
nFeatureHigh <- 4500
pctMt <- 4

# Look at distributions of quality features
nFeatureHistograms <- lapply(seuratObjects, function(x) hist(x$nFeature_RNA, 200, xlim = c(0, 5000), main = unique(x$pool), xlab = "nFeature RNA"))

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_NFeatureHistograms.pdf")),
height = 4,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratObjects, function(x) {
  hist(x$nFeature_RNA, 50, xlim = c(0, 6000), main = unique(x$pool), xlab = "nFeature RNA")
  abline(v = nFeatureHigh)
  abline(v = nFeatureLow)
})

invisible(dev.off())
```

```{r plot_pct_mito, fig.height = 3, fig.width=3}
pctMitoHistograms <- lapply(seuratObjects, function(x) hist(x$percent_mt, 50, xlim = c(0, 25), main = unique(x$pool), xlab = "% mitochondrial reads"))

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_PctMitoHistograms.pdf")),
height = 4,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratObjects, function(x) {
  hist(x$percent_mt, 100, xlim = c(0, 25), main = unique(x$pool), xlab = "% mitochondrial reads")
  abline(v = pctMt)
})

invisible(dev.off())
```

```{r inspect_qc_cutoffs, fig.width=8, fig.height=2}
plotLayers <- list(geom_vline(xintercept = nFeatureLow),
  geom_vline(xintercept = nFeatureHigh),
  geom_hline(yintercept = pctMt),
  labs(x = "Number of genes",
    y = "% mito reads",
    title = ""),
  xlim(c(0, 7000)),
  ylim(c(0, 50)),
  theme(legend.position = "none"))

featureScatterPlots <- lapply(seuratObjects, function(x) FeatureScatter(x,
  feature1 = "nFeature_RNA",
  feature2 = "percent_mt") +
  plotLayers +
  ggtitle(unique(x$pool)))

ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_QCscatterplots.pdf")),
height = 6,
width = 10)

ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

invisible(dev.off())
```

```{r nCountsRNA}
rasterResolutionDpi <- 300

qcMetricsThresholds <-
  c(
    "min_nFeature_RNA" = 250,
    "max_nFeature_RNA" = 6000,
    "min_nCount_RNA" = 450,
    "max_nCount_RNA" = 35000,
    # "nFeature_ADT" = 50,
    # "nCount_ADT" = 500,
    "percent_mt" = 12.5
    # "percent_ribo" = 50,
    # "percent_hb" = 10
  )

qcMetricsDfForPlot <-
  data.frame(
    metric = str_replace(names(qcMetricsThresholds), "^(min|max)_", ""),
    threshold = unname(qcMetricsThresholds)
  )

qcMetrics.tmp <-
  c("nFeature_RNA", "nCount_RNA",
    # "nFeature_ADT", "nCount_ADT",
    "percent_mt"
    # "percent_ribo", "percent_hb")
  )

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_QCmetricplots.pdf")),
height = 5.5,
width = 12)

plot.tmp <-
  seuratObjects[[1]]@meta.data %>%
  dplyr::select(all_of(qcMetrics.tmp)) %>%
  pivot_longer(
    cols = one_of(qcMetrics.tmp),
    names_to = "metric", values_to = "value") %>%
  mutate(metric = metric %>% factor(levels = qcMetrics.tmp)) %>%
  ggplot(mapping = aes(x = "sample", y = value)) +
  geom_violin() +
  ggrastr::rasterise(
    geom_jitter(size = 0.5), dpi = rasterResolutionDpi) +
  facet_wrap(facets = vars(metric), ncol = 2, scales = "free_y") +
  geom_hline(
    data =
      qcMetricsDfForPlot %>%
        dplyr::filter(metric %in% qcMetrics.tmp) %>%
        mutate(metric = metric %>% factor(levels = qcMetrics.tmp)),
    mapping = aes(yintercept = threshold),
    color = "red", linetype = "dashed") +
  theme(
    axis.text.x = element_blank(),
    # axis.text.x = element_text(angle=-45, hjust=0, size = 10),
    strip.text = element_text(size = rel(0.8), margin = margin(t = 3, b = 3))) +
  labs(x = NULL, y = NULL)

print(plot.tmp)

dev.off()
```

```{r add_anno}
annoP589_1 <- read_excel(file.path(dataInputDir, "P589-1_Final_Annotation.xlsx"),
  "Final Annotation")

# Remove duplicated columns based on their values
annoP589_1 <- annoP589_1 %>% dplyr::select(which(!duplicated(as.list(.))))

# clean up colnames
colnames(annoP589_1) <- gsub("\\.", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub(" ", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("/", "Per", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\r\n", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("%", "Percent", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("#", "Num", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("-", "", colnames(annoP589_1))
colnames(annoP589_1) <- sub("[1-9]$", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\\(", "_", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\\)", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\\(", "_", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("10x", "tenx", colnames(annoP589_1))
colnames(annoP589_1) <- sub("^([A-Z])", "\\L\\1", colnames(annoP589_1), perl = TRUE)

names(annoP589_1)[names(annoP589_1) == "gateforcellcounter"] <- "gateForCellCounter"
names(annoP589_1)[names(annoP589_1) == "libtype"] <- "libType"
names(annoP589_1)[names(annoP589_1) == "tenxdillibQubitn"]

names(annoP589_1)[names(annoP589_1) == "index_name"] <- "indexName"
names(annoP589_1)[names(annoP589_1) == "samplelocationPlateWellPerTubeNum"] <- "sampleLocationPlateWellPerTubeNum"
names(annoP589_1)[names(annoP589_1) == "cellCountafterWashPerResuspcellsPerul"] <- "cellCountAfterWashPerResuspcellsPerul"
names(annoP589_1)[names(annoP589_1) == "poolratio"] <- "poolRatio"
names(annoP589_1)[names(annoP589_1) == "datecollected"] <- "dateCollected"

# Define the mapping of donor IDs to numbers
donor_mapping <- c(
  "CerosalettiLab1059994" = 1,
  "CerosalettiLab1464776" = 2,
  "CerosalettiLab448473" = 3,
  "CerosalettiLab632811" = 4,
  "CerosalettiLab839987" = 5,
  "CerosalettiLab942655" = 6
)


annoP589_1$donorIdFigures <- with(annoP589_1, {
  donor_id <- as.character(donor_mapping[donorID])
  paste0(donor_id, "_", studyGroup)
})
```

```{r setupPalettes}
# Extract unique donor IDs
unique_donor_ids <- unique(annoP589_1$donorIdFigures)

# Reorder unique donor IDs to match the desired order
desired_order <- c("2_T1D", "5_T1D", "6_T1D", "1_Control", "3_Control", "4_Control")
unique_donor_ids <- unique_donor_ids[order(match(unique_donor_ids, desired_order))]

# Ensure the number of colors matches the number of unique donor IDs
colors <- paletteer::paletteer_d(palette = "LaCroixColoR::Lemon", n = length(unique_donor_ids))

# Create named vector
palDonorId <- setNames(colors, unique_donor_ids)

# create stimulation color palette
# palStimulation <- setNames(paletteer::paletteer_d("khroma::highcontrast", n = 3), c("Polyclonal", "IAR", "Microbial"))
palStimulation <- setNames(paletteer::paletteer_d("PrettyCols::Bold", n = 3), c("Polyclonal", "IAR", "Microbial"))

# create cellType (TotalSeq) color palette
palCellType <- c("Treg" = "blue", "Tconv" = "red", "Other" = "gray")

# create studyGroup color palette
palStudyGroup <- c("Control" = "lightblue", "T1D" = "orange")

# create pool color palette
palPool <- c("1" = "darkgreen", "2" = "darkorange4")
```

```{r checkForTCRGenesPreQC}
# TRA, TRB, TRGC1, TRGC2, TRDC
# TRAV24, TRAJ18, TRAV7-2,
# merge Seurat objects
seuratMerged.tmp <- merge(seuratObjects[[1]],
  y = c(seuratObjects[2]),
  add.cell.ids = poolOrder,
  merge.data = TRUE)

# Set the default assay to RNA if not already set
DefaultAssay(seuratMerged.tmp) <- "RNA"

seuratMerged.tmp <- JoinLayers(seuratMerged.tmp, assay = "RNA")

# Get the counts matrix from the "counts" slot
counts_mat <- GetAssayData(seuratMerged.tmp, assay = "RNA", slot = "counts")

# Retrieve gene names that start with "TRA", "TRB", "TRD", or "TRG"
tcr_genes <- grep("^(TRA|TRB|TRD|TRG)", rownames(counts_mat), value = TRUE)

# Print the resulting gene names
print(tcr_genes)

# Subset the matrix to the TR genes
tcr_counts <- counts_mat[tcr_genes, ]

# Calculate for each gene the number of cells with non-zero counts
nonzero_cell_counts <- Matrix::rowSums(tcr_counts > 0)
print(nonzero_cell_counts)

# Calculate the mean and standard deviation (SD) of counts for non-zero cells
mean_nonzero <- apply(tcr_counts, 1, function(x) {
  v <- x[x > 0]
  if (length(v) == 0) NA else mean(v)
})
sd_nonzero <- apply(tcr_counts, 1, function(x) {
  v <- x[x > 0]
  if (length(v) == 0) NA else sd(v)
})

# Convert the named vector to a data frame with additional columns
nonzero_df <- data.frame(
  Gene = names(nonzero_cell_counts),
  Count = as.integer(nonzero_cell_counts),
  Mean = as.numeric(mean_nonzero),
  SD = as.numeric(sd_nonzero)
)

# Export the data frame as an Excel file in the dataOutputDir directory
library(openxlsx)
write.xlsx(nonzero_df, file = file.path(dataOutputDir, "20250401_P589-1_nonzeroTCRGeneCounts.xlsx"))

rm_tmp(ask = FALSE)
```

```{r make_qc_cuts, results = "show"}
seuratQC <- NULL

for (i in 1:length(seuratObjects)) {
  seurat <- seuratObjects[[i]]

  seuratQC[[i]] <- subset(seurat,
    subset = nFeature_RNA > nFeatureLow & nFeature_RNA < nFeatureHigh & percent_mt < pctMt)
}

# Tally how many cells pass QC
poolAnno <- data.frame("pool" = c("1",
  "2"))

poolAnno$nCells <- NA
poolAnno$nCellsQC <- NA

for (i in 1:length(seuratObjects)) {
  selectedPool <- unique(seuratObjects[[i]]$pool) %>%
    as.character()

  poolAnno$nCells[poolAnno$pool == selectedPool] <- dim(seuratObjects[[i]])[2]

  poolAnno$nCellsQC[poolAnno$pool == selectedPool] <- dim(seuratQC[[i]])[2]
}

poolAnno$pctPass <- round(poolAnno$nCellsQC / poolAnno$nCells * 100, 2)

poolAnno %>%
  dplyr::select(pool, nCells, nCellsQC, pctPass) %>%
  dplyr::rename(Pool = pool,
    `Number of cells` = nCells,
    `Number of high quality cells` = nCellsQC,
    `Percent of cells that pass QC` = pctPass) %>%
  kable(row.names = F,
    caption = "Quality analysis summary") %>%
  kable_styling(full_width = F,
    position = "left")
```

```{r qc_nfeature}

# QC cutoffs should be applied differently in P407-1 and P407-2

# Select QC cutoffs separately for -1 and -2

# nFeatureLow1 <- 500
# nFeatureHigh1 <- 4000
# pctMtCutoff1 <- 15

# nFeatureLow2 <- 500
# nFeatureHigh2 <- 2500
# pctMtCutoff2 <- 5

# mergedMono$qcPass <- case_when(mergedMono$project == "P407-1" ~ (mergedMono$nFeature_RNA > nFeatureLow1 & mergedMono$nFeature_RNA < nFeatureHigh1 & mergedMono$percentMT < pctMtCutoff1),
#   mergedMono$project == "P407-2" ~ (mergedMono$nFeature_RNA > nFeatureLow2 & mergedMono$nFeature_RNA < nFeatureHigh2 & mergedMono$percentMT < pctMtCutoff2))

# mergedLymph$qcPass <- mergedLymph$nFeature_RNA > nFeatureLow2 & mergedLymph$nFeature_RNA < nFeatureHigh2 & mergedLymph$percentMT < pctMtCutoff2

# seuratMonoQC <- subset(mergedMono,
#   subset = (qcPass == TRUE))

# seuratLymphQC <- subset(mergedLymph,
#   subset = (qcPass == TRUE))

# remove(mergedMono)
# remove(mergedLymph)
```

### Examine empty drop, do DSB normalization
```{r remove_cells_from_raw}
seuratEmptyObjects <- NULL

for (i in 1:length(seuratRawObjects)) {
  # Remove things that were called cells but failed QC as well as things that were called cells and passed QC
  seuratRaw <- seuratRawObjects[[i]]
  seuratCells <- seuratObjects[[i]]

  # check assay sizes of rna and fb data
  rnaSize <- log10(Matrix::colSums(seuratRaw[["RNA"]]))
  fbSize <- log10(Matrix::colSums(seuratRaw[["FB"]]))
  # filter raw data barcodes to only include those with data for both assays (done in DSB analysis)
  # nonZeroBCIdx <- which(rnaSize > 0 &fbSize > 0)
  # Maybe keeping cells with non-zero fb, but zero rna data is better
  seuratRaw <- seuratRaw[, rnaSize > 0]

  emptyBarcodes <-  setdiff(colnames(seuratRaw), colnames(seuratCells))
  ## check sizes
  # length(emptyBarcodes)+ncol(seuratCells)
  # ncol(seuratRaw)
  seuratEmpty <- seuratRaw[, emptyBarcodes]

  # Filter objects with > 100 RNA features (in line with DSB paper)
  seuratEmpty <- subset(seuratEmpty,
    subset = nFeature_RNA < 100)

  # Filter objects with < 10 or > 1000 Ab counts (like in DSB paper)
  seuratEmpty <- subset(seuratEmpty,
    subset = nCount_FB > 10 & nCount_FB < 1000)

  seuratEmptyObjects[[i]] <- seuratEmpty
}

# Clean up
remove(seuratRawObjects)
remove(seuratRaw)
```

#Examine empty droplets

```{r plot_n_features_empty, fig.height = 3, fig.width=3}
# Select QC cutoffs

# Look at distributions of quality features
nFeatureHistograms <- lapply(seuratEmptyObjects, function(x) hist(x$nFeature_RNA, 200, xlim = c(0, 100), main = unique(x$pool), xlab = "nFeature RNA"))

pdf(file.path(plotDir,
  "NFeatureHistograms_EmptyDrops.pdf"),
height = 6,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratEmptyObjects, function(x) {
  hist(x$nFeature_RNA, 50, xlim = c(0, 100), main = unique(x$pool), xlab = "nFeature RNA")
  abline(v = nFeatureHigh)
  abline(v = nFeatureLow)
})

invisible(dev.off())
```

```{r plot_n_features_abs, fig.height = 3, fig.width=3}
# Look at distributions of quality features
nFeatureHistograms <- lapply(seuratEmptyObjects, function(x) hist(x$nFeature_FB, 200, xlim = c(0, 200), main = unique(x$pool), xlab = "nFeature FB"))

pdf(file.path(plotDir,
  "NFeatureHistogramsFB_EmptyDrops.pdf"),
height = 6,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratEmptyObjects, function(x) {
  hist(x$nFeature_FB, 50, xlim = c(0, 200), main = unique(x$pool), xlab = "nFeature Abs")
})

invisible(dev.off())

# Make a single plot of n feature distributions
nFeatureFBList <- NULL
for (i in 1:length(seuratEmptyObjects)) {
  seurat <- seuratEmptyObjects[[i]]

  nFeatureFBList[[i]] <- data.frame(pool = seurat$pool,
    nFeatureFB = seurat$nFeature_FB)
}

nFeatureFB <- bind_rows(nFeatureFBList)

gNFeatureAb <- nFeatureFB %>%
  dplyr::mutate(dilution = factor(pool,
    levels = c ("1",
      "2"))) %>%
  ggplot() +
  geom_density(aes(x = nFeatureFB,
    color = pool)) +
  # scale_color_manual(values = dilutionColors) +
  labs(x = "Number of unique antibody features",
    y = "Density (area under each curve = 1)",
    color = "Pool")

pdf(file.path(plotDir,
  "NFeatureDensityPlotsFB_EmptyDrops.pdf"),
height = 6,
width = 8)

print(gNFeatureAb)

invisible(dev.off())
```

##Plots of the percent mitochondrial reads per library

The following plots show the percent of features that mapped to mitochondrial genes. High percentages can indicate a poor quality or dying cell. 

```{r plot_pct_mito, fig.height = 3, fig.width=3}
pctMitoHistograms <- lapply(seuratEmptyObjects, function(x) hist(x$percent_mt, 50, xlim = c(0, 20), main = unique(x$pool), xlab = "% mitochondrial reads"))

pdf(file.path(plotDir,
  "PctMitoHistograms_EmptyDrops.pdf"),
height = 6,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratEmptyObjects, function(x) {
  hist(x$percent_mt, 100, xlim = c(0, 25), main = unique(x$pool), xlab = "% mitochondrial reads")
  abline(v = pctMt)
})

invisible(dev.off())
```

## Quality metric scatterplots with cutoffs

The plots below explore the relationship between percent mitochonridal reads and the number of features detected. Each point represents a cell. Lines on the plots indicate quality cutoffs for features (both a lower and an upper bound) and mitochrondial reads (an upper bound). 

```{r inspect_qc_cutoffs, fig.width=8, fig.height=2}
plotLayers <- list(labs(x = "Number of genes",
  y = "Number of ab features",
  title = ""),
scale_y_log10(),
theme(legend.position = "none"))

featureScatterPlots <- lapply(seuratEmptyObjects, function(x) FeatureScatter(x,
  feature1 = "nFeature_RNA",
  feature2 = "nCount_FB") +
  plotLayers +
  ggtitle(unique(x$pool)))


ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

png(file.path(plotDir,
  "NFeatureScatterplots_EmptyDrops.png"),
height = 600,
width = 800)

ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

invisible(dev.off())

for (i in 1:length(seuratEmptyObjects)) {
  seuratEmpty <- seuratEmptyObjects[[i]]
  gFeature <- seuratEmpty@meta.data %>%
    ggplot(aes(x = nFeature_RNA,
      y = nCount_FB)) +
    geom_bin2d(bins = 300) +
    plotLayers +
    scale_fill_viridis_c(option = "C")
}
```

### end of examining empty drops for DSB normalization


```{r histAndBiaxialHTPlots}
# merge Seurat objects
seuratQCMerged <- merge(seuratQC[[1]],
  y = c(seuratQC[2]),
  add.cell.ids = poolOrder,
  merge.data = TRUE)

# DSB normalization on the FB/CITEseq/TotalSeq/whatever data
controlAbs <- c("Mouse IgG1, - isotype Ctrl")

dsbNormProtList <- NULL

seuratEmptyMerged <- merge(seuratEmptyObjects[[1]],
  y = c(seuratQC[2]),
  add.cell.ids = poolOrder,
  merge.data = TRUE)

emptyMatrix <- GetAssayData(seuratEmptyMerged, assay = "FB")
cellMatrix <- GetAssayData(seuratQCMerged, assay = "FB")

dsbNormProtMerged <- DSBNormalizeProtein(
  cell_protein_matrix = cellMatrix,
  empty_drop_matrix = emptyMatrix,
  denoise.counts = TRUE,
  use.isotype.control = TRUE,
  isotype.control.name.vec = controlAbs
)

# add DSB normalized FB data to seurat object
seuratQCMerged[["DSB"]] <- CreateAssayObject(dsbNormProtMerged)

DefaultAssay(seuratQCMerged) <- "HT"

htVariables <- rownames(seuratQCMerged)
htDF <- FetchData(seuratQCMerged,
  vars = c(htVariables))

# manually transform as log(count + 1)
htDF <- log(htDF + 1)

# manually transform as log(cpm +1)
# htDF <- log(((htDF * 10^6) / colSums(htDF)) + 1)

# Convert the data frame to a matrix
htMatrix <- as.matrix(htDF)

# Transpose htMatrix
htMatrix <- t(htMatrix)

# Get the cell names (columns) and feature names (rows) from the existing "HT" assay data
cells <- colnames(seuratQCMerged[["HT"]]@data)
features <- rownames(seuratQCMerged[["HT"]]@data)

# Ensure the cell names (columns) and feature names (rows) in htMatrix match those in the existing "HT" assay data
colnames(htMatrix) <- cells
rownames(htMatrix) <- features

# Overwrite the "HT" assay data with the normalized data
seuratQCMerged[["HT"]]@data <- htMatrix

png(file.path(plotDir,
  paste0(filenameSuffix, "_Scatterplots_HTExpression.png")),
height = 1000,
width = 2400)

ggpairs(htDF[sample(1:nrow(htDF)), ],
  columns = 1:18,
  aes(alpha = 0.4))

invisible(dev.off())
```

```{r stephanPribitzerHTODemuxAltApproach}
# #Usually performs better for human samples than hto demux

# individual cutoffs determined by examining ridgeplots of the individual hashtags (log(counts + 1))

# Create a vector of cutoffs
htCutoffs <- c("CerosalettiLab1464776-Islet" = 3.5,
  "CerosalettiLab1464776-CEFX" = 4,
  "CerosalettiLab1059994-Islet" = 4,
  "CerosalettiLab1059994-CEFX" = 3.85,
  "CerosalettiLab942655-Islet" = 4,
  "CerosalettiLab942655-CEFX" = 4,
  "CerosalettiLab1464776-CD3CD28" = 5,
  "CerosalettiLab1059994-CD3CD28" = 6,
  "CerosalettiLab942655-CD3CD28" = 5.5,
  "CerosalettiLab632811-CD3CD28" = 6.25,
  "CerosalettiLab448473-CD3CD28" = 7.25,
  "CerosalettiLab839987-CD3CD28" = 6.5,
  "CerosalettiLab632811-CEFX" = 4.25,
  "CerosalettiLab448473-CEFX" = 3.5,
  "CerosalettiLab839987-CEFX" = 3.5,
  "CerosalettiLab632811-Islet" = 4.25,
  "CerosalettiLab448473-Islet" = 3.5,
  "CerosalettiLab839987-Islet" = 3.5)

# Define the mapping of donor IDs to numbers
donor_mapping <- c(
  "CerosalettiLab1059994" = 1,
  "CerosalettiLab1464776" = 2,
  "CerosalettiLab448473" = 3,
  "CerosalettiLab632811" = 4,
  "CerosalettiLab839987" = 5,
  "CerosalettiLab942655" = 6
)

# # Add the #donorIdFigures column to seuratQCMerged@meta.data
# seuratQCMerged@meta.data$donorIdFigures <- with(seuratQCMerged@meta.data, {
#   donor_id <- as.character(donor_mapping[donorId])
#   paste0(donor_id, "_", studyGroup)
# })

# # Ensure that the donorIdFigures column is correctly formatted
# seuratQCMerged@meta.data$donorIdFigures <- ifelse(
#   is.na(seuratQCMerged@meta.data$donorIdFigures),
#   NA,
#   seuratQCMerged@meta.data$donorIdFigures
# )

# # make $stimulationFigures where the values in $stimulation map from "CD3CD28", "CEFX", "Islet"
# # to "Polyclonal", "Microbial", "IAR"
# stimulation_mapping <- c(
#   "CD3CD28" = "Polyclonal",
#   "CEFX" = "Microbial",
#   "Islet" = "IAR"
# )

# # Assuming your data frame is named df
# # Add the stimulationFigures column to the data frame
# seuratQCMerged@meta.data$stimulationFigures <- stimulation_mapping[seuratQCMerged@meta.data$stimulation]

# # Ensure that the stimulationFigures column is correctly formatted
# seuratQCMerged@meta.data$stimulationFigures <- ifelse(
#   is.na(seuratQCMerged@meta.data$stimulationFigures),
#   NA,
#   seuratQCMerged@meta.data$stimulationFigures
# )

# # make $stimulationFigures a factor with order "Microbial", "IAR", "Polyclonal"
# seuratQCMerged@meta.data$stimulationFigures <- factor(seuratQCMerged@meta.data$stimulationFigures,
#   levels = c("Microbial", "IAR", "Polyclonal"))

hashtagHistograms.tmp <- htDF %>%
  pivot_longer(cols = all_of(pool1HTVars),
    names_to = "ht",
    values_to = "counts") %>%
  mutate(cutoff = htCutoffs[ht]) %>%  # Add a column with the cutoff for each hashtag
  ggplot(aes(x = counts)) +
  geom_histogram() +
  geom_vline(aes(xintercept = cutoff),  # Use the cutoff column as the xintercept
    color = "red") +
  labs(x = "hashtag expression",
    y = "log10(Number of cells)") +
  scale_y_log10() +
  scale_x_continuous(breaks = 0:12) +
  facet_wrap(~ht,
    scales = "free_y",
    ncol = 3)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_HistogramsHashtags_pool1.pdf")),
width = 12,
height = 5.5)

print(hashtagHistograms.tmp)

invisible(dev.off())

rm_tmp(ask = FALSE)

hashtagHistograms.tmp <- htDF %>%
  pivot_longer(cols = all_of(pool2HTVars),
    names_to = "ht",
    values_to = "counts") %>%
  mutate(cutoff = htCutoffs[ht]) %>%  # Add a column with the cutoff for each hashtag
  ggplot(aes(x = counts)) +
  geom_histogram() +
  geom_vline(aes(xintercept = cutoff),  # Use the cutoff column as the xintercept
    color = "red") +
  labs(x = "hashtag expression",
    y = "log10(Number of cells)") +
  scale_y_log10() +
  scale_x_continuous(breaks = 0:12) +
  facet_wrap(~ht,
    scales = "free_y",
    ncol = 3)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_HistogramsHashtags_pool2.pdf")),
width = 12,
height = 5.5)

print(hashtagHistograms.tmp)

invisible(dev.off())

rm_tmp(ask = FALSE)

# htCutoffs <- c("CerosalettiLab1464776-Islet" = 1, "CerosalettiLab1464776-CEFX" = 1, "CerosalettiLab1059994-Islet" = 1,
#                "CerosalettiLab1059994-CEFX" = 1, "CerosalettiLab942655-Islet" = 1, "CerosalettiLab942655-CEFX" = 1,
#                "CerosalettiLab1464776-CD3CD28" = 1, "CerosalettiLab1059994-CD3CD28" = 1, "CerosalettiLab942655-CD3CD28" = 1)

# Match the names in htCutoffs to the column names in htDF
htCutoffs <- htCutoffs[match(colnames(htDF), names(htCutoffs))]

# Apply the cutoffs to each column
htDF$nCells <- rowSums(sweep(htDF, 2, htCutoffs, ">"))

htDF <- htDF %>%
  dplyr::mutate(manualHT = case_when(nCells > 1 ~ "Multiplet",
    nCells == 0 ~ "Negative",
    `CerosalettiLab1464776-Islet` > htCutoffs["CerosalettiLab1464776-Islet"] ~ "CerosalettiLab1464776-Islet",
    `CerosalettiLab1464776-CEFX` > htCutoffs["CerosalettiLab1464776-CEFX"] ~ "CerosalettiLab1464776-CEFX",
    `CerosalettiLab1059994-Islet` > htCutoffs["CerosalettiLab1059994-Islet"] ~ "CerosalettiLab1059994-Islet",
    `CerosalettiLab1059994-CEFX` > htCutoffs["CerosalettiLab1059994-CEFX"] ~ "CerosalettiLab1059994-CEFX",
    `CerosalettiLab942655-Islet` > htCutoffs["CerosalettiLab942655-Islet"] ~ "CerosalettiLab942655-Islet",
    `CerosalettiLab942655-CEFX` > htCutoffs["CerosalettiLab942655-CEFX"] ~ "CerosalettiLab942655-CEFX",
    `CerosalettiLab1464776-CD3CD28` > htCutoffs["CerosalettiLab1464776-CD3CD28"] ~ "CerosalettiLab1464776-CD3CD28",
    `CerosalettiLab1059994-CD3CD28` > htCutoffs["CerosalettiLab1059994-CD3CD28"] ~ "CerosalettiLab1059994-CD3CD28",
    `CerosalettiLab942655-CD3CD28` > htCutoffs["CerosalettiLab942655-CD3CD28"] ~ "CerosalettiLab942655-CD3CD28",
    `CerosalettiLab632811-CD3CD28` > htCutoffs["CerosalettiLab632811-CD3CD28"] ~ "CerosalettiLab632811-CD3CD28",
    `CerosalettiLab448473-CD3CD28` > htCutoffs["CerosalettiLab448473-CD3CD28"] ~ "CerosalettiLab448473-CD3CD28",
    `CerosalettiLab839987-CD3CD28` > htCutoffs["CerosalettiLab839987-CD3CD28"] ~ "CerosalettiLab839987-CD3CD28",
    `CerosalettiLab632811-CEFX` > htCutoffs["CerosalettiLab632811-CEFX"] ~ "CerosalettiLab632811-CEFX",
    `CerosalettiLab448473-CEFX` > htCutoffs["CerosalettiLab448473-CEFX"] ~ "CerosalettiLab448473-CEFX",
    `CerosalettiLab839987-CEFX` > htCutoffs["CerosalettiLab839987-CEFX"] ~ "CerosalettiLab839987-CEFX",
    `CerosalettiLab632811-Islet` > htCutoffs["CerosalettiLab632811-Islet"] ~ "CerosalettiLab632811-Islet",
    `CerosalettiLab448473-Islet` > htCutoffs["CerosalettiLab448473-Islet"] ~ "CerosalettiLab448473-Islet",
    `CerosalettiLab839987-Islet` > htCutoffs["CerosalettiLab839987-Islet"] ~ "CerosalettiLab839987-Islet"))

# Check ht calls. Many things are multiplets according to this
table(htDF$manualHT)

png(file.path(plotDir,
  paste0(filenameSuffix, "_Scatterplots_HTExpression_ManualDemux_V3.png")),
height = 18,
width = 30,
units = "in",
res = 600)


ggpairs(htDF[sample(1:nrow(htDF)), ],
  columns = 1:length(htVariables),
  aes(color = manualHT,
    fill = manualHT,
    alpha = 0.4))

invisible(dev.off())

# add the manual demultiplexing results into @meta.data
seuratQCMerged@meta.data <- seuratQCMerged@meta.data %>%
  dplyr::mutate(htDemux = htDF$manualHT,
    donorId = sub("-.*", "", htDemux),
    stimulation = sub(".*-", "", htDemux))

# Check with additional plots

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Ridgeplots_HTExpression_ManualDemux_pool1.pdf")),
height = 20,
width = 30)

# RidgePlot(seuratQCMerged,
#           assay = "HT",
#           features = htVariables,
#           group.by = "htDemux",
#           ncol = 3) &
#   labs(x = "Hashtag expression",
#        y = "Assigned demux group") +
#   scale_x_continuous(limits = c(0, 9), breaks = seq(0, 9, by = 0.5))

# Create a list to store the plots
plots <- list()

# Create a plot for each feature
for (feature in pool1HTVars) {
  p <- RidgePlot(seuratQCMerged,
    assay = "HT",
    features = feature,
    group.by = "htDemux") +
    labs(x = "Hashtag expression",
      y = "Assigned demux group") +
    scale_x_continuous(limits = c(0, 10), breaks = seq(0, 10, by = 0.5)) +
    theme(legend.position = "none")  # Remove the legend

  # Add the plot to the list
  plots[[feature]] <- p
}

# Combine the plots
combined_plot <- patchwork::wrap_plots(plots, ncol = 3)

# Print the combined plot
print(combined_plot)

invisible(dev.off())

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Ridgeplots_HTExpression_ManualDemux_pool2.pdf")),
height = 20,
width = 30)

# Create a list to store the plots
plots <- list()

# Create a plot for each feature
for (feature in pool2HTVars) {
  p <- RidgePlot(seuratQCMerged,
    assay = "HT",
    features = feature,
    group.by = "htDemux") +
    labs(x = "Hashtag expression",
      y = "Assigned demux group") +
    scale_x_continuous(limits = c(0, 10), breaks = seq(0, 10, by = 0.5)) +
    theme(legend.position = "none")  # Remove the legend

  # Add the plot to the list
  plots[[feature]] <- p
}

# Combine the plots
combined_plot <- patchwork::wrap_plots(plots, ncol = 3)

# Print the combined plot
print(combined_plot)

invisible(dev.off())


DefaultAssay(seuratQCMerged) <- "HT"
seuratQCMerged <- ScaleData(seuratQCMerged, features = rownames(htVariables),
  verbose = FALSE)
seuratQCMerged <- RunPCA(seuratQCMerged, features = htVariables, approx = FALSE)
# ElbowPlot(seuratQCMerged)
seuratQCMerged <- FindNeighbors(seuratQCMerged, dims = 1:6)
clusterResolution <- c("HT" = 0.1, "RNA" = 0.3)
seuratQCMerged <- FindClusters(seuratQCMerged, resolution = clusterResolution["HT"])

seuratQCMerged <- RunUMAP(seuratQCMerged, dims = 1:6)

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

clusterName[["HT"]] <-
  paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["HT"]], "\\.", "p"))
seuratQCMerged <- seuratQCMerged %>%
  Seurat::AddMetaData(Idents(seuratQCMerged), col.name = clusterName[["HT"]])

Idents(seuratQCMerged) <- seuratQCMerged@meta.data[[clusterName[["HT"]]]]
clusterMarkers[[paste0("HT_", clusterName[["HT"]])]] <-
  FindAllMarkers(seuratQCMerged, assay = "HT")

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_HT_labels.pdf")),
height = 5,
width = 12)
umap_plot <- DimPlot(seuratQCMerged,
  label = TRUE,
  repel = TRUE,
  group.by = "htDemux")

print(umap_plot)

invisible(dev.off())
```

```{r cleanSeuratWithTCRData}
# removes iNKT cells, mait cells, and TCR multiplets
seuratQCMerged <- subset(seuratQCMerged, cells = barcodesToFilter, invert = TRUE)

# add_clone_info_to_seurat_object
cellLevelTCRInfo <- cleanTCRs.df %>%
  dplyr::group_by(barcode) %>%
  dplyr::summarise(
    # Count the number of alpha and beta chains per barcode
    nAlpha = sum(stringr::str_detect(chain, "TRA")),
    nBeta  = sum(stringr::str_detect(chain, "TRB")),

    # Assign unique clone IDs per barcode by selecting the first non-NA value
    cdr3CloneID               = dplyr::first(na.omit(cdr3CloneID)),
    threePointCloneID         = dplyr::first(na.omit(threePointCloneID)),
    cdr3CloneID_nt            = dplyr::first(na.omit(cdr3CloneID_nt)),
    fullLengthNTCloneID       = dplyr::first(na.omit(fullLengthNTCloneID)),
    cdr3CloneID_alpha         = dplyr::first(na.omit(cdr3CloneID_alpha)),
    threePointCloneID_alpha   = dplyr::first(na.omit(threePointCloneID_alpha)),
    cdr3CloneID_nt_alpha      = dplyr::first(na.omit(cdr3CloneID_nt_alpha)),
    fullLengthNTCloneID_alpha = dplyr::first(na.omit(fullLengthNTCloneID_alpha)),
    cdr3CloneID_beta          = dplyr::first(na.omit(cdr3CloneID_beta)),
    threePointCloneID_beta    = dplyr::first(na.omit(threePointCloneID_beta)),
    cdr3CloneID_nt_beta       = dplyr::first(na.omit(cdr3CloneID_nt_beta)),
    fullLengthNTCloneID_beta  = dplyr::first(na.omit(fullLengthNTCloneID_beta)),

    # Incorporate existing count data from cleanTCRs.df using the existing '_counts' columns
    cdr3CloneCount               = dplyr::first(na.omit(cdr3CloneID_counts)),
    threePointCloneCount         = dplyr::first(na.omit(threePointCloneID_counts)),
    cdr3_ntCloneCount            = dplyr::first(na.omit(cdr3CloneID_nt_counts)),
    fullLengthNTCloneCount       = dplyr::first(na.omit(fullLengthNTCloneID_counts)),
    cdr3CloneCount_alpha         = dplyr::first(na.omit(cdr3CloneID_alpha_counts)),
    threePointCloneCount_alpha   = dplyr::first(na.omit(threePointCloneID_alpha_counts)),
    cdr3_ntCloneCount_alpha      = dplyr::first(na.omit(cdr3CloneID_nt_alpha_counts)),
    fullLengthNTCloneCount_alpha = dplyr::first(na.omit(fullLengthNTCloneID_alpha_counts)),
    cdr3CloneCount_beta          = dplyr::first(na.omit(cdr3CloneID_beta_counts)),
    threePointCloneCount_beta    = dplyr::first(na.omit(threePointCloneID_beta_counts)),
    cdr3_ntCloneCount_beta       = dplyr::first(na.omit(cdr3CloneID_nt_beta_counts)),
    fullLengthNTCloneCount_beta  = dplyr::first(na.omit(fullLengthNTCloneID_beta_counts))
  ) %>%
  dplyr::ungroup() %>%
  as.data.frame()

rownames(cellLevelTCRInfo) <- cellLevelTCRInfo$barcode

seuratQCMerged <- Seurat::AddMetaData(object = seuratQCMerged,
  metadata = cellLevelTCRInfo)
```

```{r addAnnoToSeurat}
# now that we've demultiplexed by hashtag, we can add certain metadata to the Seurat object

# add studyGroup from annoP589_1
sampleNameStudyGroup.tmp <- unique(annoP589_1[, c("sampleName", "studyGroup")])
sampleNameStudyGroup.tmp$sampleName <- gsub("_", "-", sampleNameStudyGroup.tmp$sampleName)

studyGroup_vector.tmp <- setNames(sampleNameStudyGroup.tmp$studyGroup, sampleNameStudyGroup.tmp$sampleName)

seuratQCMerged@meta.data$studyGroup <- studyGroup_vector.tmp[seuratQCMerged@meta.data$htDemux]

rm_tmp(ask = FALSE)

# add $donorIdFigures where
# CerosalettiLab1059994 CerosalettiLab1464776  CerosalettiLab448473  CerosalettiLab632811  CerosalettiLab839987  CerosalettiLab942655 map to
# 1, 2, 3, 4, 5, 6, then an underscore, and then the value of $studyGroup
# Define the mapping of donor IDs to numbers
donor_mapping <- c(
  "CerosalettiLab1059994" = 1,
  "CerosalettiLab1464776" = 2,
  "CerosalettiLab448473" = 3,
  "CerosalettiLab632811" = 4,
  "CerosalettiLab839987" = 5,
  "CerosalettiLab942655" = 6
)

# Add the #donorIdFigures column to seuratQCMerged@meta.data
seuratQCMerged@meta.data$donorIdFigures <- with(seuratQCMerged@meta.data, {
  donor_id <- as.character(donor_mapping[donorId])
  paste0(donor_id, "_", studyGroup)
})

# Ensure that the donorIdFigures column is correctly formatted
seuratQCMerged@meta.data$donorIdFigures <- ifelse(
  is.na(seuratQCMerged@meta.data$donorIdFigures),
  NA,
  seuratQCMerged@meta.data$donorIdFigures
)

# make $stimulationFigures where the values in $stimulation map from "CD3CD28", "CEFX", "Islet"
# to "Polyclonal", "Microbial", "IAR"
stimulation_mapping <- c(
  "CD3CD28" = "Polyclonal",
  "CEFX" = "Microbial",
  "Islet" = "IAR"
)

# Assuming your data frame is named df
# Add the stimulationFigures column to the data frame
seuratQCMerged@meta.data$stimulationFigures <- stimulation_mapping[seuratQCMerged@meta.data$stimulation]

# Ensure that the stimulationFigures column is correctly formatted
seuratQCMerged@meta.data$stimulationFigures <- ifelse(
  is.na(seuratQCMerged@meta.data$stimulationFigures),
  NA,
  seuratQCMerged@meta.data$stimulationFigures
)

# make $stimulationFigures a factor with order "Microbial", "IAR", "Polyclonal"
seuratQCMerged@meta.data$stimulationFigures <- factor(seuratQCMerged@meta.data$stimulationFigures,
  levels = c("Microbial", "IAR", "Polyclonal"))
```

```{r MattLawranceHTODemuxAltMethod}
# cell barcode with colors for HTO_M1 through HTO_M3, black for unassigned, red for multiplePositive. This is just a named vector of unassigned, multiplepositive, and each of my hashes with a color from miscHelper's big_colorblind_pal function. You can make a named vector with any colors you want. This is just for plotting.

pal.sampleBarcode <-
  big_colorblind_pal(
    n_colors = 4,
    drop_yellow = TRUE, drop_black = FALSE) %>%
  # B0251 = Hashtag1, B0260 = Hashtag2
  setNames(c("unassigned", paste0("HTO-M", 1:3))) %>%
  c("multiplePositive" = "red")

# add logCPM counts for the hashes. My assay was HTO in your case it might be Hashes

# add logCpm for each
offset.tmp <- 1
Pool1InclMultiplets <- Pool1InclMultiplets %>%
  Seurat::AddMetaData(
    metadata =
      log(t(as.matrix(Pool1InclMultiplets[["HTO"]]@counts + offset.tmp)) /
        Pool1InclMultiplets$nCount_HTO * 1e6) %>%
        as.data.frame() %>%
        set_colnames(make.names(paste0("logCpm", colnames(.))))
  )

# These are my thresholds. You'll get a ridgeplot with these lines drawn soon, the objective is to get the red and blue lines in the middle of the valley between positive and negative samples. ADjust them as necessary

thresholdsHtoPool1 <-
  list(logCpm = c("posAbove" = 11.5, "negBelow" = 11, "minGap" = 1.5))

# Makes a ridgeplot of the hashtag CPMs. Your cols might need to matches logCpmHashes not HTO based on your assay name. Important thing is where the lines are and that they're cleanly splitting your positive and negative peaks. Keep adjusting thresholdsHto until you're happy.

Pool1InclMultiplets@meta.data %>%
  pivot_longer(
    cols = matches("logCpmHTO"),
    names_to = "hashtag", names_prefix = "clrMd",
    values_to = "count") %>%
  ggplot(mapping = aes(x = count)) +
  geom_density(size = 1) +
  facet_wrap(vars(hashtag), nrow = 2) +
  labs(x = "Hashtag counts (log CPM)") +
  geom_vline(
    xintercept = thresholdsHtoPool1[["logCpm"]]["negBelow"],
    linetype = "dashed", color = "red") +
  geom_vline(
    xintercept = thresholdsHtoPool1[["logCpm"]]["posAbove"],
    linetype = "dashed", color = "blue")

# Now that our thresholds are good for what we want, we make a big fat dataframe for every cell's condition at every single hashtag (positive or negative), then count everything that is negative at all hashes as negative for hashes, everything that is positive for multiple hashes as a multiplet, and everything that is exlusively positive for one hash as positive for that hash. Huge chunk, sorry

ogCpmHTO.tmp <-
  Pool1InclMultiplets@meta.data %>%
  dplyr::select(matches("logCpmHTO"))

thresholdLogCpmHTOStatus.tmp <-
  matrix(
    "ambiguous",
    nrow = nrow(logCpmHTO.tmp), ncol = ncol(logCpmHTO.tmp),
    dimnames = dimnames(logCpmHTO.tmp))

thresholdLogCpmHTOStatus.tmp[logCpmHTO.tmp > thresholdsHtoPool1[["logCpm"]]["posAbove"]] <- "positive"
thresholdLogCpmHTOStatus.tmp[logCpmHTO.tmp < thresholdsHtoPool1[["logCpm"]]["negBelow"]] <- "negative"

thresholdLogCpmHTOStatus.tmp <-
  matrix(
    "ambiguous",
    nrow = nrow(logCpmHTO.tmp), ncol = ncol(logCpmHTO.tmp),
    dimnames = dimnames(logCpmHTO.tmp))
thresholdLogCpmHTOStatus.tmp[logCpmHTO.tmp > thresholdsHtoPool1[["logCpm"]]["posAbove"]] <- "positive"
thresholdLogCpmHTOStatus.tmp[
  t(apply(logCpmHTO.tmp, MARGIN = 1, function(x) {
    max(x) - x
  })) >
    thresholdsHtoPool1[["logCpm"]]["minGap"]] <-
  "negative"

sampleBarcode.tmp <- rep("unassigned", ncol(Pool1InclMultiplets))

# identify multiplePositive
cells.tmp <-
  which(apply(thresholdLogCpmHTOStatus.tmp,
    MARGIN = 1, FUN = function(x) {
      sum(x %in% c("ambiguous", "positive")) > 1
    }))
sampleBarcode.tmp[cells.tmp] <- "multiplePositive"

# identify  single positives
cells.tmp <-
  which(apply(thresholdLogCpmHTOStatus.tmp,
    MARGIN = 1,
    FUN = function(x) {
      (sum(x %in% "positive") == 1) & (sum(x %in% "ambiguous") == 0)
    }))
sampleBarcode.tmp[cells.tmp] <-
  colnames(thresholdLogCpmHTOStatus.tmp)[
    apply(thresholdLogCpmHTOStatus.tmp[cells.tmp, ],
      MARGIN = 1, function(x) which(x %in% "positive"))] %>%
  str_replace_all("logCpmHTO.", "HTO-")

sampleBarcode.tmp <-
  sampleBarcode.tmp %>%
  factor(levels = str_sort(unique(.), numeric = TRUE))

# add to Seurat object metadata
Pool1InclMultiplets <- Pool1InclMultiplets %>%
  Seurat::AddMetaData(
    metadata = sampleBarcode.tmp,
    col.name = "hashtagIdentity")

# Final product is your seurat file with new metadata column called hashtagIdentity with the identity of the hash
```

```{r removeMultipletsAndNegatives}
seuratQCMergedCleaned <- subset(seuratQCMerged,
  subset = (htDemux %in% c("CerosalettiLab1464776-Islet",
    "CerosalettiLab1464776-CEFX",
    "CerosalettiLab1059994-Islet",
    "CerosalettiLab1059994-CEFX",
    "CerosalettiLab942655-Islet",
    "CerosalettiLab942655-CEFX",
    "CerosalettiLab1464776-CD3CD28",
    "CerosalettiLab1059994-CD3CD28",
    "CerosalettiLab942655-CD3CD28",
    "CerosalettiLab632811-CD3CD28",
    "CerosalettiLab448473-CD3CD28",
    "CerosalettiLab839987-CD3CD28",
    "CerosalettiLab632811-CEFX",
    "CerosalettiLab448473-CEFX",
    "CerosalettiLab839987-CEFX",
    "CerosalettiLab632811-Islet",
    "CerosalettiLab448473-Islet",
    "CerosalettiLab839987-Islet")))

# these cells wind up way out in no-man's land in UMAPs:

# 1_ACCCTATTCGCTCCGT-1 1_AGAGAGAAGGTGAGAT-1 1_AGTGTACGTAGCGGGA-1 1_GCGCTCCGTAGAGTGA-1 1_GTCTGCGAGATATTGC-1 2_CAAGACCTCGCTTTAC-1 2_CCCAATTTCATTGTAA-1
suspiciousCellBarcodes <- c("1_ACCCTATTCGCTCCGT-1", "1_AGAGAGAAGGTGAGAT-1", "1_AGTGTACGTAGCGGGA-1", "1_GCGCTCCGTAGAGTGA-1", "1_GTCTGCGAGATATTGC-1", "2_CAAGACCTCGCTTTAC-1", "2_CCCAATTTCATTGTAA-1")
# metaData.df <- seuratQCMergedCleanedDS@meta.data

# #filter metaData.df down to just the $barcode matching suspiciousCellBarcodes
# metaData.df <- metaData.df[metaData.df$HT_names %in% suspiciousCellBarcodes,]

# results: 3 control donors, 1 T1D. All Islet cells. No TCRs. Remove them.

# remove the rows in seuratQCMergedCleaned with the rownames in suspiciousCellBarcodes
# Identify the cell barcodes to keep
cells_to_keep <- setdiff(rownames(seuratQCMergedCleaned@meta.data), suspiciousCellBarcodes)

# Subset the @meta.data slot to keep only the rows not in suspiciousCellBarcodes
seuratQCMergedCleaned <- subset(seuratQCMergedCleaned, cells = cells_to_keep)

# now that we've removed multiplets and negatives, we can set the order of the donorIdFigures factor
seuratQCMergedCleaned@meta.data$donorIdFigures <- factor(
  seuratQCMergedCleaned@meta.data$donorIdFigures,
  levels = c("1_Control", "3_Control", "4_Control", "2_T1D", "5_T1D", "6_T1D")
)
```

```{r clusterByHTAfterRemoval}
seuratQCMergedCleaned <- RunPCA(seuratQCMergedCleaned, features = htVariables, approx = FALSE)
seuratQCMergedCleaned <- RunUMAP(seuratQCMergedCleaned, dims = 1:6, min.dist = 1)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_HT_labels_multiplet_removed.pdf")),
height = 5,
width = 12)
umap_plot <- DimPlot(seuratQCMergedCleaned,
  label = TRUE,
  repel = TRUE,
  group.by = "htDemux")

print(umap_plot)

invisible(dev.off())
```

```{r CD8CheckAndFilter}
# we want to remove cells that are likely to be CD8s

# setup $barcode in the metadata
seuratQCMergedCleaned@meta.data$barcode <- rownames(seuratQCMergedCleaned@meta.data)

# set the default assay to RNA
DefaultAssay(seuratQCMergedCleaned) <- "RNA"

# Extract the expression data for CD8A and CD8B
CD8AExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "CD8A")
CD8BExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "CD8B")

# Let's also look at CD4
CD4Expression.tmp <- FetchData(seuratQCMergedCleaned, vars = "CD4")

# 20250228 and also CD3 (for Meenakshi)
TRDCExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRDC")
# TODO check TRGC1, TRGC2, TRDC

# Convert the data to a data frame
expressionData.tmp <- data.frame(
  CD8A = CD8AExpression.tmp$CD8A,
  CD8B = CD8BExpression.tmp$CD8B,
  CD4 = CD4Expression.tmp$CD4,
  TRDC = TRDCExpression.tmp$TRDC
)
rownames(expressionData.tmp) <- rownames(CD4Expression.tmp)

# Identify the non-zero entries in CD8A and CD8B
nonZeroBarcodes.tmp <- rownames(expressionData.tmp)[CD8AExpression.tmp$CD8A != 0 | CD8BExpression.tmp$CD8B != 0]
# nonZeroBarcodesCD8A.tmp <- rownames(expressionData.tmp)[CD8AExpression.tmp$CD8A != 0]
# nonZeroBarcodesCD8B.tmp <- rownames(expressionData.tmp)[CD8BExpression.tmp$CD8B != 0]

# make a subset of expressionData.tmp that only has the nonZeroBarcodes.tmp
expressionDataCD8Pos.tmp <- expressionData.tmp[nonZeroBarcodes.tmp, ]

# Subset seuratQCMergedCleaned@meta.data based on these barcodes
metaDataSubset.df.tmp <- seuratQCMergedCleaned@meta.data %>%
  filter(barcode %in% nonZeroBarcodes.tmp)

table(metaDataSubset.df.tmp$stimulationFigures)
# microbial: 288, IAR: 1, Polyclonal: 12

# Group the data by stimulationFigures and donorIdFigures and count the number of cells
cell_counts.tmp <- metaDataSubset.df.tmp %>%
  group_by(stimulationFigures, donorIdFigures) %>%
  summarise(count = n()) %>%
  ungroup()

# Define the output file path
output_file.tmp <- file.path(dataOutputDir, "CD8PosCells.xlsx")

# Save the table to an Excel file
write.xlsx(cell_counts.tmp, output_file.tmp)

# Create histograms using ggplot2
histCD8A.tmp <- ggplot(expressionData.tmp, aes(x = CD8A)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Histogram of CD8A Expression", x = "CD8A Expression", y = "Frequency") +
  theme_minimal() +
  theme(text = element_text(size = 16))

histCD8B.tmp <- ggplot(expressionData.tmp, aes(x = CD8B)) +
  geom_histogram(binwidth = 0.1, fill = "red", color = "black", alpha = 0.7) +
  labs(title = "Histogram of CD8B Expression", x = "CD8B Expression", y = "Frequency") +
  theme_minimal() +
  theme(text = element_text(size = 16))

scatterPlotCD4CD8A.tmp <- ggplot(expressionDataCD8Pos.tmp, aes(x = CD4, y = CD8A)) +
  geom_point() +
  labs(title = "Scatterplot of CD8A vs CD4", x = "CD4 Expression", y = "CD8A") +
  theme_minimal() +
  theme(text = element_text(size = 16))

scatterPlotCD4CD8B.tmp <- ggplot(expressionDataCD8Pos.tmp, aes(x = CD4, y = CD8B)) +
  geom_point() +
  labs(title = "Scatterplot of CD8B vs CD4", x = "CD4 Expression", y = "CD8B") +
  theme_minimal() +
  theme(text = element_text(size = 16))

# Print the histograms
# print(histCD8A.tmp)
# print(histCD8B.tmp)

# let's remove the CD8 positive cells
# Identify the cell barcodes to keep
cellsToKeep.tmp <- setdiff(rownames(seuratQCMergedCleaned@meta.data), nonZeroBarcodes.tmp)

# Subset the @meta.data slot to keep only the rows not in snonZeroBarcodes.tmp
seuratQCMergedCleaned <- subset(seuratQCMergedCleaned, cells = cellsToKeep.tmp)

rm_tmp(ask = FALSE)
```

```{r printCellTable}
# Extract the relevant metadata columns
metadata <- seuratQCMerged@meta.data[, c("stimulationFigures", "donorIdFigures")]

# Create a contingency table
cell_count_table <- table(metadata$donorIdFigures, metadata$stimulationFigures)

# Convert the table to a data frame for better readability
cell_count_df <- as.data.frame.matrix(cell_count_table)

# Print the table
print(cell_count_df)


# Define the output file path
output_file_path <- file.path(dataOutputDir, "cell_count_table_cleaned.csv")

# Write the table to a CSV file
write.csv(cell_count_df, file = output_file_path, row.names = TRUE)
```

```{r removeTCRGenesFromGEXData}
# we need to remove TCR genes (TRA, TRB, TRD, TRG) so that they don't drive clustering
# result: none of these genes are present in the RNA assay

# TCRAExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRA")
# TCRBExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRB")
# TCRDExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRD")
# TCRGExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRG")

# rm_tmp(ask = FALSE)
```

```{r reProcessCleanedData}
# Re-run normalization, clustering, UMAP, etc on this subset
seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned, assay = "RNA")

DefaultAssay(seuratQCMergedCleaned) <- "RNA"
seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned, verbose = FALSE, assay = "RNA")

seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratQCMergedCleaned <- FindVariableFeatures(object = seuratQCMergedCleaned,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleaned <- ScaleData(object = seuratQCMergedCleaned, verbose = FALSE)
seuratQCMergedCleaned <- RunPCA(object = seuratQCMergedCleaned, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleaned)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# # let's do some hyperparameter optimization
# # create grid of hyperparameters to test
# hyperParamGrid.df <- expand.grid(
#   findNeighborsDim = c(10, 14, 16),
#   findClustersRes = c(0.01, 0.05, 0.1, 0.3, 0.4, 0.6, 0.8, 1, 1.3, 1.5, 2)
# )

# # detect nuymber of cores, leave one available for the machine to do other things
# nCores <- parallel::detectCores() - 1

# # create the cluster
# myCluster <- parallel::makeCluster(
#   nCores,
#   type = "FORK"
# )

# # check the cluster definition (optional)
# print(myCluster)

# # register it to be used by %dopar%
# doParallel::registerDoParallel(cl = myCluster)

# # check if it is registered (optional)
# foreach::getDoParRegistered()

# # how many workers are available? (optional)
# foreach::getDoParWorkers()

# # Hyperparameter grid search
# clusteringMetrics <- foreach(
#   findNeighborsDim = hyperParamGrid.df$findNeighborsDim,
#   findClustersRes = hyperParamGrid.df$findClustersRes,
#   .combine = "cbind"
# ) %dopar% {
#   # do the UMAP clustering on the Seurat object
#   set.seed(6022)
#   seuratQCMergedCleaned <- FindNeighbors(seuratQCMergedCleaned, dims = 1:findNeighborsDim, verbose = FALSE)
#   seuratQCMergedCleaned <- FindClusters(seuratQCMergedCleaned, resolution = findClustersRes, verbose = FALSE)

#   # extract the cluster information
#   metaData.df <- seuratQCMergedCleaned@meta.data

#   # Extract PCA embeddings
#   pca_embeddings <- seuratQCMergedCleaned@reductions$pca@cell.embeddings

#   clusterMat <- pca_embeddings
#   clusterVect <- as.numeric(metaData.df$seurat_clusters)
#   nClusters <- dim(table(metaData.df$seurat_clusters))

#   # calculate clustering metrics
#   daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
#   calinskiHarabasz <- index.G1(clusterMat, clusterVect)
#   silScore <- silhouette(clusterVect, dist(clusterMat))
#   if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
#     medianSilScore <- NaN
#   } else {
#     silScoreSummary <- summary(silScore)
#     medianSilScore <- silScoreSummary$si.summary["Median"]
#   }

#   clusteringMetrics <- c("nClusters" = nClusters,
#     "DBIndex" = daviesBouldinIdx$DB,
#     "CHMetric" = calinskiHarabasz,
#     "medianSilScore" = medianSilScore)
#   return(clusteringMetrics)
# }

# # transpose the result
# clusteringMetrics <- t(clusteringMetrics)

# # adding the prediction error column
# hyperParamGrid.df$DBIndex <- clusteringMetrics[, "DBIndex"]
# hyperParamGrid.df$CHMetric <- clusteringMetrics[, "CHMetric"]
# hyperParamGrid.df$medianSilScore <- clusteringMetrics[, "medianSilScore.Median"]
# hyperParamGrid.df$nClusters <- clusteringMetrics[, "nClusters"]

# # stop cluster after we're done
# parallel::stopCluster(cl = myCluster)

seuratQCMergedCleaned <- FindNeighbors(seuratQCMergedCleaned, dims = 1:10)
seuratQCMergedCleaned <- FindClusters(seuratQCMergedCleaned, resolution = 0.4)

set.seed(6022)
seuratQCMergedCleaned <- RunUMAP(object = seuratQCMergedCleaned, reduction = "pca",
  dims = 1:10,
  n.neighbors = 30,
  min.dist = 0.1)

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["RNA"]], "\\.", "p"))

# Add metadata to the Seurat object
seuratQCMergedCleaned <- seuratQCMergedCleaned %>%
  Seurat::AddMetaData(Idents(seuratQCMergedCleaned), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratQCMergedCleaned) <- seuratQCMergedCleaned@meta.data[[clusterName[["RNA"]]]]

# Join the data layers in the RNA assay if not already joined
if (!"RNA" %in% names(seuratQCMergedCleaned@assays)) {
  seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned, layers = c("RNA"))
}

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratQCMergedCleaned, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])
```

```{r checkGeneSymbolsInGeneLists}
# figure out which gene names are missing from our data

# Retrieve gene names from the RNA assay
geneNames.tmp <- rownames(GetAssayData(seuratQCMergedCleaned, assay = "RNA"))

# Extract gene names from all columns in each dataframe
genesTconv.tmp <- unlist(geneListsTconv.df)
genesTreg.tmp <- unlist(geneListsTreg.df)
genesHCvsT1D.tmp <- unlist(geneListsHCvsT1D.df)
genesTCR.tmp <- unlist(geneListsTCR.df)

# Combine all gene names into a single vector
allGeneListGenes.tmp <- unique(c(genesTconv.tmp, genesTreg.tmp, genesHCvsT1D.tmp, genesTCR.tmp))

# Identify gene names not in geneNames.tmp
genesNotInDataset.tmp <- setdiff(allGeneListGenes.tmp, geneNames.tmp)

# Print the gene names not in geneNames.tmp
print(genesNotInDataset.tmp)

rm_tmp(ask = FALSE)
```

```{r tcr_detection_plot_QC}

seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# Add on overall average
tcrDetectionPctsAvg <- seuratQCMergedCleaned@meta.data %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::group_by(tcrGroup, nCells) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = "Average over all")

tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
  tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQC.pdf"),
  height = 4,
  width = 8)

print(gTcrGroup)

dev.off()
```

```{r saveSeuratToH5AD}
# save seuratQCMergedCleaned to h5ad (for CellTypist)

# Convert to V3 object
seuratQCMergedCleanedV3.tmp <- seuratQCMergedCleaned
seuratQCMergedCleanedV3.tmp[["RNA"]] <- as(object = seuratQCMergedCleanedV3.tmp[["RNA"]], Class = "Assay")
library(SeuratDisk)
SaveH5Seurat(
  seuratQCMergedCleanedV3.tmp,
  filename =
    file.path(dataOutputDir, "seuratP589AllCells.h5Seurat"),
  overwrite = TRUE)
Convert(
  source = file.path(dataOutputDir, "seuratP589AllCells.h5Seurat"),
  dest = "h5ad",
  assay = "RNA",
  overwrite = TRUE)

rm_tmp(ask = FALSE)
```

```{r loadCellTypistResultsAndAddToSeurat}
# load in the cellTypist output
cellTypist.df <-
  read.csv(file.path(dataOutputDir, "P589_1_Metadata_With_CelltypistPredictions.csv")) %>%
  data.frame()

# add cellTypist.df$majority_voting to seuratQCMergedCleaned metadata as $cellTypistCalling
# Extract barcodes from cellTypist.df and Seurat object metadata
cellTypistBarcodes <- cellTypist.df$X
seuratBarcodes <- seuratQCMergedCleaned@meta.data$barcode

# Match barcodes and create a named vector for majority_voting
matchingIndices <- match(seuratBarcodes, cellTypistBarcodes)
cellTypistCalling <- cellTypist.df$majority_voting[matchingIndices]

# Add cellTypistCalling to seuratQCMergedCleaned metadata
seuratQCMergedCleaned <- Seurat::AddMetaData(
  object = seuratQCMergedCleaned,
  metadata = cellTypistCalling,
  col.name = "cellTypistCalling"
)

# Replace NA values in cellTypistCalling column with "Other"
seuratQCMergedCleaned$cellTypistCalling[is.na(seuratQCMergedCleaned$cellTypistCalling)] <- "Other"

# create $cellTypistSimplified where "Treg" stays the same, "Memory CD4 T cell" becomes "Tconv", and all other cells are "Other"
seuratQCMergedCleaned@meta.data$cellTypistSimplified <- ifelse(
  seuratQCMergedCleaned@meta.data$cellTypistCalling == "Treg",
  "Treg",
  ifelse(seuratQCMergedCleaned@meta.data$cellTypistCalling == "Memory CD4 T cell",
    "Tconv",
    "Other")
)

# make a color palette for these cell types
# Define the cell types including NA
cell_types.tmp <- c("Memory CD4 T cell", "cDC1", "Memory CD8 T cell", "Treg", "Other")

# Generate the color palette
palCellTypist <- paletteer::paletteer_d("fishualize::Centropyge_loricula", n = length(cell_types.tmp))
palCellTypist[1] <- "#FF0000" # to match palCellType
palCellTypist[2] <- "#ff7b00"
palCellTypist[4] <- "#0000FF" # to match palCellType
palCellTypist[5] <- "#808080" # to match palCellType

#
# Create a named vector of colors
names(palCellTypist) <- cell_types.tmp

rm_tmp(ask = FALSE)
```

```{r loadCellTypistL3Predictions}
# load in the cellTypist output
cellTypist.df <-
  read.csv(file.path(dataOutputDir, "20241220_P589-1_celltypist_L3_predictions.csv")) %>%
  data.frame()

# add cellTypist.df$majority_voting to seuratQCMergedCleaned metadata as $cellTypistCalling
# Extract barcodes from cellTypist.df and Seurat object metadata
cellTypistBarcodes <- cellTypist.df$X
seuratBarcodes <- seuratQCMergedCleaned@meta.data$barcode

# Match barcodes and create a named vector for majority_voting
matchingIndices <- match(seuratBarcodes, cellTypistBarcodes)
cellTypistCalling <- cellTypist.df$majority_voting[matchingIndices]

# Add cellTypistCalling to seuratQCMergedCleaned metadata
seuratQCMergedCleaned <- Seurat::AddMetaData(
  object = seuratQCMergedCleaned,
  metadata = cellTypistCalling,
  col.name = "cellTypistCallingL3"
)

# Replace NA values in cellTypistCalling column with "Other"
seuratQCMergedCleaned$cellTypistCallingL3[is.na(seuratQCMergedCleaned$cellTypistCallingL3)] <- "Other"

# create $cellTypistSimplified where "Treg" stays the same, "Memory CD4 T cell" becomes "Tconv", and all other cells are "Other"
seuratQCMergedCleaned@meta.data$cellTypistSimplified <- ifelse(
  seuratQCMergedCleaned@meta.data$cellTypistCalling == "Treg",
  "Treg",
  ifelse(seuratQCMergedCleaned@meta.data$cellTypistCalling == "Memory CD4 T cell",
    "Tconv",
    "Other")
)

# # make a color palette for these cell types
# # Define the cell types including NA
# cell_types.tmp <- c("Memory CD4 T cell", "cDC1", "Memory CD8 T cell", "Treg", "Other")

# # Generate the color palette
# palCellTypist <- paletteer::paletteer_d("fishualize::Centropyge_loricula", n = length(cell_types.tmp))
# palCellTypist[1] <- "#FF0000" # to match palCellType
# palCellTypist[4] <- "#0000FF" # to match palCellType
# palCellTypist[5] <- "#808080" # to match palCellType

# #
# # Create a named vector of colors
# names(palCellTypist) <- cell_types.tmp

# # Extract the new metadata column from the original Seurat object
# new_metadata <- seuratQCMergedCleaned@meta.data$cellTypistCallingL3

# # Ensure the cells are in the same order
# new_metadata_subset <- new_metadata[Cells(seuratQCMergedCleaned)]

# # Add the new metadata column to the subset Seurat object
# seuratTreg <- Seurat::AddMetaData(seuratQCMergedCleaned, metadata = new_metadata_subset, col.name = "cellTypistCallingL3")

rm_tmp(ask = FALSE)
```

```{r stemness}
# load in the file containing the stemness ML weights
stemnessWeights <- read_excel(file.path(dataInputDir,
  "Malta_et_al_2018_SignatureWeights_Machine Learning Identifies Stemness Features Associated with Oncogenic Dedifferentiation_Cell.xlsx"),
sheet = "mRNAsi")

# Filter down to just the genes that we have in the RNA assay counts of the Seurat object
stemnessWeights <- stemnessWeights[stemnessWeights$HUGO %in% rownames(seuratQCMergedCleaned[["RNA"]]$counts), ]

# counts_overlap <- log2(counts_pc_norm[rownames(counts_pc_norm) %in% stemness_weights$HUGO, ]+1)

# Filter down to just the genes that we have in the RNA assay counts of the Seurat object
countsOverlap <- seuratQCMergedCleaned[["RNA"]]$counts[rownames(seuratQCMergedCleaned[["RNA"]]$counts) %in% stemnessWeights$HUGO, ]

stemnessWeights$Weight <- as.numeric(stemnessWeights$Weight)

# countsOverlap <- countsOverlap[stemnessWeights$HUGO, ]

# Follow PanCanStem github page appraoch for assigning a stemness score
stemnessScores <- apply(countsOverlap, 2, function(z) {
  cor(z, stemnessWeights$Weight, method = "sp", use = "complete.obs")
})

# Scale the scores to be between 0 and 1
stemnessScores <- stemnessScores - min(stemnessScores)
stemnessScores <- stemnessScores / max(stemnessScores)

# Add stemnessScores to the meta.data of the Seurat object
seuratQCMergedCleaned <- Seurat::AddMetaData(seuratQCMergedCleaned, metadata = stemnessScores, col.name = "stemnessScore")

# Verify that the stemnessScores have been added
head(seuratQCMergedCleaned@meta.data)
```

```{r tcr_detection_plot_QC_stimulation_facet}
# Define the tcrGroup column
seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Group and summarize the data
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorIdFigures, stimulationFigures) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorIdFigures, stimulationFigures, tcrGroup, nCells, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n(), .groups = "drop") %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup, levels = c("no TCR", "alpha only", "beta only", "both")))

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorIdFigures,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~stimulationFigures)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(file = file.path(plotDir, "TCRDetectionBySampleQCStimulationFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorIdFigures,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1, size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16)) +
  facet_wrap(~stimulationFigures)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(file = file.path(plotDir, "TCRDetectionBySampleQCStimulationFacetPoster.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_facet}

seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~studyGroup)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1, size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16)) +
  facet_wrap(~studyGroup)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupFacetPoster.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_stimulation_facet}

seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~ studyGroup + stimulation)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupStimulationFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_table}

chainCounts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::mutate(nCellsTot = n()) %>%
  dplyr::group_by(nAlpha, nBeta, nCellsTot) %>%
  dplyr::summarise(nCells = n()) %>%
  dplyr::mutate(pctCells = round(nCells / nCellsTot * 100, 1),
    stringOutput = paste0(nCells, " (", pctCells, "%)"),
    nAlpha = paste0(nAlpha, " alpha"),
    nBeta = paste0(nBeta, " beta"), ) %>%
  pivot_wider(id_cols = nBeta,
    names_from = nAlpha,
    values_from = stringOutput)

colnames(chainCounts)[1] <- ""

chainCounts <- as.data.frame(chainCounts) # change class from table to dataframe
write.csv(chainCounts,
  file.path(dataOutputDir,
    "tcrChainCountsQC.csv"),
  row.names = F)
```

```{r savePreprocData}
# save the workspace as an .RData file
save.image(file.path(dataOutputDir, "20250123_preprocData.RData"))

# load the saved image
load(file.path(dataOutputDir, "preprocData.RData"))
```

```{r downsamplingCEFX}
# First, generate a table of the number of cells from each $donorId in each $stimulation
cellCounts.tmp <- seuratQCMergedCleaned@meta.data %>%
  group_by(donorId, stimulation) %>%
  summarise(cell_count = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = stimulation, values_from = cell_count, values_fill = list(cell_count = 0))

# Print the table
# print(cellCounts.tmp)
#   donorId               CD3CD28  CEFX Islet
#   <chr>                   <int> <int> <int>
# 1 CerosalettiLab1059994      42  1392   110
# 2 CerosalettiLab1464776     159  1858   152
# 3 CerosalettiLab448473      488  3064   236
# 4 CerosalettiLab632811      598  1315   384
# 5 CerosalettiLab839987      274  8188   237
# 6 CerosalettiLab942655      435 12291   244

# set # of CEFX cells to downsample to
# nCEFXDownsample <- 600 # 1300

# Calculate the mean of the cell count for CD3CD28 and Islet cells per donor
meanCellCounts.tmp <- cellCounts.tmp %>%
  rowwise() %>%
  mutate(meanCount = round(mean(c(CD3CD28, Islet)))) %>%
  dplyr::select(donorId, meanCount)

# Convert to a named list
meanCellCountsList.tmp <- setNames(meanCellCounts.tmp$meanCount, meanCellCounts.tmp$donorId)

# Print the list
# print(meanCellCountsList.tmp)

# Identify unique CEFX hashtags
unique_cefx_hashtags <- unique(seuratQCMergedCleaned@meta.data$htDemux[grepl("CEFX$", seuratQCMergedCleaned@meta.data$htDemux)])

# Initialize an empty list to store sampled cells
sampled_cefx_cells_list <- list()

# Iterate over each unique CEFX hashtag
set.seed(6022)
for (hashtag in unique_cefx_hashtags) {
  # set.seed(6022)  # Set seed for reproducibility #NOTE move this out of the loop!! moved on 20241017
  # during changes from downsampling from 600 CEFX to IAR count

  # set nCEFXDownsample to the number of Islet cells for the current donor
  # Extract the donor ID from the hashtag
  donor_id <- sub("-CEFX$", "", hashtag)

  # Look up the Islet cell count for the current donor
  nCEFXDownsample <- cellCounts.tmp %>%
    filter(donorId == donor_id) %>%
    pull(Islet)

  # Identify cells belonging to the current hashtag
  cefx_cells <- rownames(seuratQCMergedCleaned@meta.data)[seuratQCMergedCleaned@meta.data$htDemux == hashtag]

  # Check if any cells were found
  if (length(cefx_cells) == 0) {
    print(paste("No cells belonging to the group", hashtag, "were found."))
  } else {
    # Determine the number of cells to sample
    num_cells_to_sample <- min(nCEFXDownsample, length(cefx_cells))

    if (num_cells_to_sample < nCEFXDownsample) {
      warning(paste("Only", num_cells_to_sample, "cells found belonging to the group", hashtag, ". Proceeding with available cells."))
    }

    # Randomly sample the determined number of cells from the identified cells
    sampled_cefx_cells <- sample(cefx_cells, num_cells_to_sample)

    # Add the sampled cells to the list
    sampled_cefx_cells_list <- c(sampled_cefx_cells_list, sampled_cefx_cells)
  }
}

# Combine all sampled CEFX cells into a single vector
sampled_cefx_cells <- unlist(sampled_cefx_cells_list)

# Identify non-CEFX cells
non_cefx_cells <- rownames(seuratQCMergedCleaned@meta.data)[!grepl("CEFX$", seuratQCMergedCleaned@meta.data$htDemux)]

# Combine sampled CEFX cells with non-CEFX cells
all_cells_to_keep <- c(sampled_cefx_cells, non_cefx_cells)

# Subset the Seurat object to include only the cells to keep
seuratQCMergedCleanedDS <- subset(seuratQCMergedCleaned, cells = all_cells_to_keep)

# Verify the downsampling
print(paste("Number of cells after downsampling:", length(all_cells_to_keep)))

cellCountsDS.tmp <- seuratQCMergedCleanedDS@meta.data %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(cell_count = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = stimulationFigures, values_from = cell_count, values_fill = list(cell_count = 0))

print(cellCountsDS.tmp)

rm_tmp(ask = FALSE)
```


```{r addMetaDataToTCRs, echo=TRUE, message=FALSE, warning=FALSE}
# create $barcode in the seurat object for convenience
seuratQCMergedCleanedDS@meta.data$barcode <- rownames(seuratQCMergedCleanedDS@meta.data)

# subset the TCR dataframe to only the cells to keep after downsampling CEFX
TCRs.DS.df <- TCRs.df %>%
  filter(barcode %in% all_cells_to_keep)

# save seurat metadata as a .tmp
meta_data_df.tmp <- as.data.frame(seuratQCMergedCleanedDS@meta.data)

# Step 3: Merge TCRs.df with the modified meta_data_df based on the barcode
TCRs.DS.df <- TCRs.DS.df %>%
  left_join(meta_data_df.tmp[, c("barcode", "htDemux", "donorId", "stimulation", "studyGroup")], by = c("barcode" = "barcode"))

# Now TCRs.df contains the additional columns from seuratQCMergedCleaned@meta.data
rm_tmp(ask = FALSE)

# let's do some checking
# Extract the barcodes from seuratQCMergedCleanedDS@meta.data
seurat_barcodes <- seuratQCMergedCleanedDS@meta.data$barcode

# Extract the barcodes from TCRs.df
tcr_barcodes <- TCRs.DS.df$barcode

# Find barcodes in seurat_barcodes that are not in tcr_barcodes
missing_barcodes <- setdiff(seurat_barcodes, tcr_barcodes)

# Print the number of missing barcodes
length(missing_barcodes)

# Step 4: Filter the Seurat object to include only the missing barcodes
missing_meta_data <- seuratQCMergedCleanedDS@meta.data[seuratQCMergedCleanedDS@meta.data$barcode %in% missing_barcodes, ]

# Step 5: Create a table that counts the occurrences of each category
missing_counts <- missing_meta_data %>%
  group_by(donorId, stimulation, studyGroup) %>%
  summarise(count = n())

# Step 6: Display the table using kable
missing_TCR_kable <- kable(missing_counts, caption = "Counts of Missing Barcodes by DonorId, Stimulation, and StudyGroup")
```

```{r TCRAccounting_obselete_from_HD_contribution}

# # Then with QCd data
# tcrChainCountsQC <- TCRs.DS.df %>%
#   dplyr::group_by(chain, barcode) %>%
#   summarize(num = n()) %>%
#   pivot_wider(names_from = chain,
#     values_from = num)

# seuratQCMergedCleanedDS@meta.data$nAlpha <- tcrChainCountsQC$TRA[match(seuratQCMergedCleanedDS@meta.data$barcode,
#   tcrChainCountsQC$barcode)]

# seuratQCMergedCleanedDS@meta.data$nBeta <- tcrChainCountsQC$TRB[match(seuratQCMergedCleanedDS@meta.data$barcode,
#   tcrChainCountsQC$barcode)]

# seuratQCMergedCleanedDS@meta.data$nAlpha[is.na(seuratQCMergedCleanedDS@meta.data$nAlpha)] <- 0
# seuratQCMergedCleanedDS@meta.data$nBeta[is.na(seuratQCMergedCleanedDS@meta.data$nBeta)] <- 0

# numDoubletsQC <- sum(seuratQCMergedCleanedDS@meta.data$nAlpha >= 3 | seuratQCMergedCleanedDS@meta.data$nBeta >= 3)
```

```{r filter_doublets_obsolete_from_HD_contribution}

# # Remove cells with: a) 3+ betas or alphas and, b) cells with 2 alphas and 2 betas
# filtered_meta_data <- seuratQCMergedCleanedDS@meta.data %>%
#   filter(!(nBeta >= 3 | nAlpha >= 3 | (nAlpha == 2 & nBeta == 2)))

# # Subset the Seurat object based on the filtered metadata
# seuratQCMergedCleanedDS <- subset(seuratQCMergedCleanedDS, cells = rownames(filtered_meta_data))

# TCRs.DS.df <- TCRs.DS.df %>%
#   dplyr::filter(barcode %in% seuratQCMergedCleanedDS@meta.data$barcode)
```

```{r tcr_detection_plot_QC}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# Add on overall average
tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::group_by(tcrGroup, nCells) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = "Average over all")

tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
  tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCDS.pdf"),
  height = 4,
  width = 8)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_stimulation_facet}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~stimulation)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStimulationFacetDS.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_facet}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~studyGroup)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupFacetDS.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_stimulation_facet}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~ studyGroup + stimulation)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupStimulationFacetDS.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_table}

chainCounts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::mutate(nCellsTot = n()) %>%
  dplyr::group_by(nAlpha, nBeta, nCellsTot) %>%
  dplyr::summarise(nCells = n()) %>%
  dplyr::mutate(pctCells = round(nCells / nCellsTot * 100, 1),
    stringOutput = paste0(nCells, " (", pctCells, "%)"),
    nAlpha = paste0(nAlpha, " alpha"),
    nBeta = paste0(nBeta, " beta"), ) %>%
  pivot_wider(id_cols = nBeta,
    names_from = nAlpha,
    values_from = stringOutput)

colnames(chainCounts)[1] <- ""

chainCounts <- as.data.frame(chainCounts) # change class from table to dataframe
write.csv(chainCounts,
  file.path(dataOutputDir,
    "tcrChainCountsQCDS.csv"),
  row.names = F)
```

```{r reProcessCleanedDownsampledData}
# just checking normalization stuff... 20241212
counts.tmp <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", layer = "counts")

# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS, layers = c("RNA"))
seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  assay = "RNA")

# seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS, verbose = FALSE)
seuratQCMergedCleanedDS <- FindVariableFeatures(object = seuratQCMergedCleanedDS,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleanedDS <- ScaleData(object = seuratQCMergedCleanedDS, verbose = FALSE)
seuratQCMergedCleanedDS <- RunPCA(object = seuratQCMergedCleanedDS, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleanedDS)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# TODO replace this section with your function
# create grid of hyperparameters to test
hyperParamGrid.df <- expand.grid(
  findNeighborsDim = c(5, 7, 14, 16, 18, 20),
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5)
)

# hyperParamGrid.df <- expand.grid(
#   findNeighborsDim = c(5, 2),
#   findClustersRes = c(0.01, 1)
# )

# detect nuymber of cores, leave one available for the machine to do other things
nCores <- parallel::detectCores() - 1

# create the cluster
myCluster <- parallel::makeCluster(
  nCores,
  type = "FORK"
)

# check the cluster definition (optional)
print(myCluster)

# register it to be used by %dopar%
doParallel::registerDoParallel(cl = myCluster)

# check if it is registered (optional)
foreach::getDoParRegistered()

# how many workers are available? (optional)
foreach::getDoParWorkers()

# Hyperparameter grid search
clusteringMetrics <- foreach(
  findNeighborsDim = hyperParamGrid.df$findNeighborsDim,
  findClustersRes = hyperParamGrid.df$findClustersRes,
  .combine = "cbind"
) %dopar% {
  # do the UMAP clustering on the Seurat object
  set.seed(6022)
  seuratQCMergedCleanedDS <- FindNeighbors(seuratQCMergedCleanedDS, dims = 1:findNeighborsDim, verbose = FALSE)
  seuratQCMergedCleanedDS <- FindClusters(seuratQCMergedCleanedDS, resolution = findClustersRes, verbose = FALSE)

  # extract the cluster information
  metaData.df <- seuratQCMergedCleanedDS@meta.data

  # Extract PCA embeddings
  pca_embeddings <- seuratQCMergedCleanedDS@reductions$pca@cell.embeddings

  clusterMat <- pca_embeddings
  clusterVect <- as.numeric(metaData.df$seurat_clusters)
  nClusters <- dim(table(metaData.df$seurat_clusters))

  # calculate clustering metrics
  daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
  calinskiHarabasz <- index.G1(clusterMat, clusterVect)
  silScore <- silhouette(clusterVect, dist(clusterMat))
  if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
    medianSilScore <- NaN
  } else {
    silScoreSummary <- summary(silScore)
    medianSilScore <- silScoreSummary$si.summary["Median"]
  }

  clusteringMetrics <- c("nClusters" = nClusters,
    "DBIndex" = daviesBouldinIdx$DB,
    "CHMetric" = calinskiHarabasz,
    "medianSilScore" = medianSilScore)
  return(clusteringMetrics)
}

# transpose the result
clusteringMetrics <- t(clusteringMetrics)

# adding the prediction error column
hyperParamGrid.df$DBIndex <- clusteringMetrics[, "DBIndex"]
hyperParamGrid.df$CHMetric <- clusteringMetrics[, "CHMetric"]
hyperParamGrid.df$medianSilScore <- clusteringMetrics[, "medianSilScore"]
hyperParamGrid.df$nClusters <- clusteringMetrics[, "nClusters"]

# stop cluster after we're done
parallel::stopCluster(cl = myCluster)

# scale the clustering metrics to fall between 0 and 1
hyperParamGrid.df$DBIndex <- (hyperParamGrid.df$DBIndex - min(hyperParamGrid.df$DBIndex, na.rm = TRUE)) /
  (max(hyperParamGrid.df$DBIndex, na.rm = TRUE) - min(hyperParamGrid.df$DBIndex, na.rm = TRUE))

hyperParamGrid.df$CHMetric <- (hyperParamGrid.df$CHMetric - min(hyperParamGrid.df$CHMetric, na.rm = TRUE)) /
  (max(hyperParamGrid.df$CHMetric, na.rm = TRUE) - min(hyperParamGrid.df$CHMetric, na.rm = TRUE))

hyperParamGrid.df$medianSilScore <- (hyperParamGrid.df$medianSilScore - min(hyperParamGrid.df$medianSilScore, na.rm = TRUE)) /
  (max(hyperParamGrid.df$medianSilScore, na.rm = TRUE) - min(hyperParamGrid.df$medianSilScore, na.rm = TRUE))

# make an inverse DB score so that it is more easily compared to the other two metrics
# (small DB is best, but large CH and silscore are best)
hyperParamGrid.df$DBIndexInverse <- 1 - hyperParamGrid.df$DBIndex

# create hyperParamGrid.df$meanEvalMetric, as the mean of $DBIndex, $CHMetric, $medianSilScore
hyperParamGrid.df$meanEvalMetric <- rowMeans(hyperParamGrid.df[, c("DBIndexInverse", "CHMetric", "medianSilScore")], na.rm = TRUE)

# sort and export the hyperparamgrid
hyperParamGrid.df <- hyperParamGrid.df %>%
  arrange(nClusters, desc(meanEvalMetric))

write.xlsx(hyperParamGrid.df, file = file.path(dataOutputDir, "20242017_RNA_clustering_hyperParamGrid.xlsx"))

# create a subset of hyperParamGrid.df with the best option for each nClusters
hyperParamGridOptSubset.df <- hyperParamGrid.df %>%
  group_by(nClusters) %>%
  filter(meanEvalMetric == max(meanEvalMetric)) %>%
  ungroup()

set.seed(6022)
seuratQCMergedCleanedDS <- FindNeighbors(seuratQCMergedCleanedDS, dims = 1:14) # 14
seuratQCMergedCleanedDS <- FindClusters(seuratQCMergedCleanedDS, resolution = 0.25) # 0.4)

set.seed(6022)
seuratQCMergedCleanedDS <- RunUMAP(object = seuratQCMergedCleanedDS,
  reduction = "pca",
  return.l.l = TRUE,
  dims = 1:14,
  n.neighbors = 5, # 30
  min.dist = 0.6) # 0.1

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["RNA"]], "\\.", "p"))

# Add metadata to the Seurat object
seuratQCMergedCleanedDS <- seuratQCMergedCleanedDS %>%
  Seurat::AddMetaData(Idents(seuratQCMergedCleanedDS), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratQCMergedCleanedDS) <- seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]

# Ensure data layers are joined
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratQCMergedCleanedDS, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])

palRNAClusters <-
  big_colorblind_pal(
    n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]),
    shuffle_colors = TRUE,
    drop_yellow = TRUE, drop_black = TRUE) %>%
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])

# Get the "ggsci::uniform_startrek" palette and adjust it
palRNAClusters <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))

# this version has blueish colors for Treg clusters (3,4) and reddish/warm colors for Tconv clusters (0, 1, 2, 5, 6)
palRNAClusters2 <- paletteer_d("RColorBrewer::RdBu")

palRNAClusters2 <- c(
  "0" = "#67001FFF",
  "1" = "#B2182BFF",
  "2" = "#D6604DFF",
  "3" = "#053061FF",
  "4" = "#4393C3FF",
  "5" = "#F4A582FF",
  "6" = "#FDBF6F"
)

# palRNAClusters2 <- c(
#   "0" = "#E41A1C",  # red
#   "1" = "#FF7F00",  # orange
#   "2" = "#FDBF6F",  # light orange
#   "3" = "#1F78B4",  # blue
#   "4" = "#A6CEE3",  # light blue
#   "5" = "#FB9A99",  # pinkish
#   "6" = "#FC8D62"   # warm orange
# )
```

```{r optRNAseqClusteringFunctionDraft}
# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS, layers = c("RNA"))
seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratQCMergedCleanedDS <- FindVariableFeatures(object = seuratQCMergedCleanedDS,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleanedDS <- ScaleData(object = seuratQCMergedCleanedDS, verbose = FALSE)
seuratQCMergedCleanedDS <- RunPCA(object = seuratQCMergedCleanedDS, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleanedDS, reduction = "pca")

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 7, 14, 16, 18, 20), # these values were chosen after examining the elbow plot.
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5) # these values were chosen somewhat arbitrarily
)

# the size of these vectors largely determines the cost of this function in walltime
min.dist.vector <-  c(0.1, 0.2) # c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
n_neighbors.vector <- c(5, 20) # c(5, 20, 30, 40, 50)

optimizeRNAseqClustering <- function(seuratObject,
                                     hyperParamGridPCA.df,
                                     min.dist.vector,
                                     n_neighbors.vector,
                                     maxNClusters = 10,
                                     minNClusters = 2) {
  # ------------------------------------------------INPUTS------------------------------------------------
  # seuratObject is... a seurat object
  # hyperParamGridPCA.df is an expanded grid for a full grid search for PCA clustering. type: dataframe
  # hyperParamGridUMAP.list is a list (of lists) of UMAP hyperparameters. type: list
  # min.dist.vector is a vector of min.dist values to pass to UMAP (via scDEED())
  # n_neighbors.vector is a vector of n_neighbors values to pass to UMAP (via scDEED())
  # maxNClusters is the maximum number of clusters to be considered (will evaluate 2 through maxNClusters)
  #-------------------------------------------------------------------------------------------------------

  #----------------------------------------------OUTPUTS--------------------------------------------------
  # result contains $hyperParamGridOptClusterAndUMAP.df and $hyperParamGridClusterOnly.df
  #   Extract like:
  #     hyperParamGridOptClusterAndUMAP.df <- result$hyperParamGridOptClusterAndUMAP.df (smaller output with opt PCA clustering and UMAP embedding params)
  #     hyperParamGridClusterOnly.df <- result$hyperParamGridClusterOnly.df (larger output with full PCA clustering gridsearch and results)
  #--------------------------------------------------------------------------------------------------------

  #-----------------------------------------REQUIRED PACKAGES----------------------------------------------
  # Seurat, parallel, doParallel, foreach, clusterSim, cluster, dplyr, scDEED, stringr
  #--------------------------------------------------------------------------------------------------------

  # STEP 1: grid search over FindNeighbors() and FindClusters() hyperparameters to find
  # the best combinations for each nClusters obtained

  # detect nuymber of cores, leave one available for the machine to do other things
  nCores <- parallel::detectCores() - 1

  # create the cluster for parallel computation
  myCluster <- parallel::makeCluster(
    nCores,
    type = "FORK"
  )

  # register it to be used by %dopar%
  doParallel::registerDoParallel(cl = myCluster)

  # Hyperparameter grid search
  clusteringMetrics <- foreach(
    findNeighborsDim = hyperParamGridPCA.df$findNeighborsDim,
    findClustersRes = hyperParamGridPCA.df$findClustersRes,
    .combine = "cbind"
  ) %dopar% {
    # do the UMAP clustering on the Seurat object
    set.seed(6022)
    seuratObject <- FindNeighbors(seuratObject, dims = 1:findNeighborsDim, verbose = FALSE)
    seuratObject <- FindClusters(seuratObject, resolution = findClustersRes, verbose = FALSE)

    # extract the cluster information
    metaData.df <- seuratObject@meta.data

    # Extract PCA embeddings
    pcaEmbeddings <- seuratObject@reductions$pca@cell.embeddings

    clusterMat <- pcaEmbeddings
    clusterVect <- as.numeric(metaData.df$seurat_clusters)
    nClusters <- dim(table(metaData.df$seurat_clusters))

    # calculate clustering metrics
    daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
    calinskiHarabasz <- index.G1(clusterMat, clusterVect)
    silScore <- silhouette(clusterVect, dist(clusterMat))
    if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
      medianSilScore <- NaN
    } else {
      silScoreSummary <- summary(silScore)
      medianSilScore <- silScoreSummary$si.summary["Median"]
    }

    clusteringMetrics <- c("nClusters" = nClusters,
      "DBIndex" = daviesBouldinIdx$DB,
      "CHMetric" = calinskiHarabasz,
      "medianSilScore" = medianSilScore)
    return(clusteringMetrics)
  }

  # transpose the result
  clusteringMetrics <- t(clusteringMetrics)

  # adding the prediction error column
  hyperParamGridPCA.df$DBIndex <- clusteringMetrics[, "DBIndex"]
  hyperParamGridPCA.df$CHMetric <- clusteringMetrics[, "CHMetric"]
  hyperParamGridPCA.df$medianSilScore <- clusteringMetrics[, "medianSilScore"]
  hyperParamGridPCA.df$nClusters <- clusteringMetrics[, "nClusters"]

  # stop cluster after we're done
  parallel::stopCluster(cl = myCluster)

  # scale the clustering metrics to fall between 0 and 1
  hyperParamGridPCA.df$DBIndex <- (hyperParamGridPCA.df$DBIndex - min(hyperParamGridPCA.df$DBIndex, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$DBIndex, na.rm = TRUE) - min(hyperParamGridPCA.df$DBIndex, na.rm = TRUE))

  hyperParamGridPCA.df$CHMetric <- (hyperParamGridPCA.df$CHMetric - min(hyperParamGridPCA.df$CHMetric, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$CHMetric, na.rm = TRUE) - min(hyperParamGridPCA.df$CHMetric, na.rm = TRUE))

  hyperParamGridPCA.df$medianSilScore <- (hyperParamGridPCA.df$medianSilScore - min(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE) - min(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE))

  # make an inverse DB score so that it is more easily compared to the other two metrics
  # (small DB is best, but large CH and silscore are best)
  hyperParamGridPCA.df$DBIndexInverse <- 1 - hyperParamGridPCA.df$DBIndex

  # create hyperParamGridPCA.df$meanEvalMetric, as the mean of $DBIndex, $CHMetric, $medianSilScore
  hyperParamGridPCA.df$meanEvalMetric <- rowMeans(hyperParamGridPCA.df[, c("DBIndexInverse", "CHMetric", "medianSilScore")], na.rm = TRUE)

  # sort and export (optional) the hyperparamgrid
  hyperParamGridPCA.df <- hyperParamGridPCA.df %>%
    arrange(nClusters, desc(meanEvalMetric))

  # TODO: wrap this in an if statement to print out a file if the user requests it with a true/false function parameter
  # write.xlsx(hyperParamGridPCA.df, file = file.path(dataOutputDir, "20242017_RNA_clustering_hyperParamGrid.xlsx"))

  # create a subset of hyperParamGridPCA.df with the best option for each nClusters
  hyperParamGridOptSubset.df <- hyperParamGridPCA.df %>%
    group_by(nClusters) %>%
    filter(meanEvalMetric == max(meanEvalMetric)) %>%
    ungroup()

  # Pre-allocate min.dist and n_neighbors columns with NA values
  hyperParamGridOptSubset.df$min.dist <- NA
  hyperParamGridOptSubset.df$n_neighbors <- NA

  # STEP 2: use scDEED to optimize the UMAP hyperparameters
  # ---------------------------start of scDEED UMAP opt---------------------------------------
  # if nrow(hyperParamGridOptSubset.df) is smaller than maxNClusters, then set maxNClusters to nrow(hyperParamGridOptSubset.df)
  if (nrow(hyperParamGridOptSubset.df) < maxNClusters) {
    maxNClusters <- nrow(hyperParamGridOptSubset.df)
  }

  # Loop over the rows of hyperParamGridOptSubset.df, finding the best UMAP embedding for each nClusters
  for (i in minNClusters:maxNClusters) {
    # Extract necessary values from hyperParamGridOptSubset.df
    nClusters <- hyperParamGridOptSubset.df$nClusters[i]
    numPCs <- hyperParamGridOptSubset.df$findNeighborsDim[i]
    findClustersRes <- hyperParamGridOptSubset.df$findClustersRes[i]

    set.seed(6022)
    seuratObject <- FindNeighbors(seuratObject, dims = 1:numPCs)
    seuratObject <- FindClusters(seuratObject, resolution = findClustersRes)

    scDEEDResult <- scDEED(seuratObject, # input Seurat object (must have UMAP or t-SNE already run)
      K = numPCs, # number of PCs
      reduction.method = "umap", # 'umap' or 'tsne'
      min.dist =  min.dist.vector, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
      n_neighbors = n_neighbors.vector, # scDEED defaults are c(5, 20, 30, 40, 50). Seurat default is 30.
      similarity_percent = 0.5, # scDEECD default
      dubious_cutoff = 0.05, # scDEED default
      trustworthy_cutoff = 0.95) # scDEED default

    # add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
    scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
    scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1

    # utile scDEED output
    optIdx <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells)) # find the result with the fewest 'dubiously' embedded cells
    # min.distOpt <- scDEEDResult$num_dubious$min.dist[optIdx]
    # n_neighborsOpt <- scDEEDResult$num_dubious$n_neighbors[optIdx]

    # just output the optimal hyperparams into hyperParamGridOptSubset.df
    hyperParamGridOptSubset.df$min.dist[i] <- scDEEDResult$num_dubious$min.dist[optIdx]
    hyperParamGridOptSubset.df$n_neighbors[i] <- scDEEDResult$num_dubious$n_neighbors[optIdx]
  }

  # Reorder columns to place min.dist and n_neighbors after findClustersRes
  hyperParamGridOptSubset.df <- hyperParamGridOptSubset.df %>%
    dplyr::select(findNeighborsDim, findClustersRes, min.dist, n_neighbors, everything())

  # Return the hyperparam dataframes
  return(list(hyperParamGridOptClusterAndUMAP.df = hyperParamGridOptSubset.df, hyperParamGridClusterOnly.df = hyperParamGridPCA.df))
}

# ---------------------chunk cut out of function for now (adds umap embeddings to meta.data)-------------------------------------------
# set.seed(6022)
# seuratObject <- RunUMAP(seuratObject,
#                         dims = 1:numPCs,
#                         min.dist = min.distOpt[1],
#                         n.neighbors = n_neighborsOpt[1])
# seed.use = 100)
#-------------------------------end of scDEED UMAP opt--------------------------------------------------------

# Note 20241205: commenting out this chunk in favor of just passing back the optimal params. The Seurat object can be reprocessed manually for each nCluster that we want to look at.
# # store cluster info in seurat object metadata
# # Initialize clusterName and clusterMarkers
# clusterName <- character()
# clusterMarkers <- list()

# # Create the cluster name for RNA
# clusterName <- paste0("seurat", as.character(nClusters), "Clusters")

# # Add metadata to the Seurat object
# seuratObject <- seuratObject %>%
#   Seurat::AddMetaData(Idents(seuratObject), col.name = clusterName)

# # Set the identifiers
# Idents(seuratObject) <- seuratObject@meta.data[[clusterName]]

# # Ensure data layers are joined (note: tried moving this outside of the loop, and it broke everything. TODO: investigate)
# seuratObject <- JoinLayers(seuratObject)

# # Store the UMAP embeddings in the meta.data (we'll have to use ggplot rather than dimPlot and etc later.)
# # First extract the embeddings
# UMAPEmbeddings <- seuratObject@reductions$umap@cell.embeddings

# # Create dynamic column names for the UMAP coordinates
# colname_UMAP1 <- paste0("UMAP1_", nClusters, "Clusters")
# colname_UMAP2 <- paste0("UMAP2_", nClusters, "Clusters")

# # Store the UMAP coordinates in these columns
# seuratObject@meta.data[[colname_UMAP1]] <- UMAPEmbeddings[, 1]
# seuratObject@meta.data[[colname_UMAP2]] <- UMAPEmbeddings[, 2]
# ------------------------------------------------------------------------------------------------------------

# testing
seuratObject <- seuratTreg
startTime <- Sys.time()

result <- optimizeRNAseqClustering(seuratObject,
  hyperParamGridPCA.df,
  min.dist.vector,
  n_neighbors.vector,
  maxNClusters = 6)

endTime <- Sys.time()
timeElapsed <- endTime - startTime
print(timeElapsed)

# Extract the data frames from the result
hyperParamGridOptClusterAndUMAP.df <- result$hyperParamGridOptClusterAndUMAP.df
hyperParamGridClusterOnly.df <- result$hyperParamGridClusterOnly.df
```

```{r saveOptClusteringOutputs}
# save Treg Only files
write.xlsx(hyperParamGridClusterOnly.df, file.path(dataOutputDir, "20241205_RNAClusteringPCATregOnly.xlsx"))
write.xlsx(hyperParamGridOptClusterAndUMAP.df, file.path(dataOutputDir, "20241205_RNAClusteringPCAAndUMAPTregOnly.xlsx"))
```

```{r hierarchicalClusteringAnalysis}
# generate 5 cluster and 7 cluster options and then create tree diagrams or alluvial plots or similar

# set up dataframe of hyperparameters for different levels of clustering
# todo: clean up the hyperparam opt code sections so that these values get populated into a .csv automatically.
optHyperParams.df <- data.frame(
  nClust = c(3, 4, 5, 6, 7, 8, 9, 10),
  findNeighborsDim = c(20, 16, 16, 5, 14, 16, 5, 7),
  findNeighborsRes = c(0.05, 0.1, 0.2, 0.3, 0.25, 0.5, 0.5, 0.75),
  numUMAPDims = c(20, 16, 16, 5, 14, 16, 5, 7),
  numNeighborsUMAP = c(40, 5, 5, 5, 5, 5, 5, 5),
  minDist = c(0.2, 0.4, 0.4, 0.9, 0.6, 0.4, 0.9, 0.9)
)


seuratQCMergedCleanedDS5Clust.tmp <- seuratQCMergedCleanedDS
seuratQCMergedCleanedDS7Clust.tmp <- seuratQCMergedCleanedDS

seuratQCMergedCleanedDS5Clust.tmp <- FindNeighbors(seuratQCMergedCleanedDS5Clust.tmp, dims = 1:16)
seuratQCMergedCleanedDS5Clust.tmp <- FindClusters(seuratQCMergedCleanedDS5Clust.tmp, resolution = 0.2)

seuratQCMergedCleanedDS7Clust.tmp <- FindNeighbors(seuratQCMergedCleanedDS7Clust.tmp, dims = 1:14)
seuratQCMergedCleanedDS7Clust.tmp <- FindClusters(seuratQCMergedCleanedDS7Clust.tmp, resolution = 0.25)

set.seed(6022)
seuratQCMergedCleanedDS5Clust.tmp  <- RunUMAP(object = seuratQCMergedCleanedDS5Clust.tmp, reduction = "pca",
  dims = 1:16,
  n.neighbors = 5,
  min.dist = 0.4)

set.seed(6022)
seuratQCMergedCleanedDS7Clust.tmp <- RunUMAP(object = seuratQCMergedCleanedDS7Clust.tmp, reduction = "pca",
  dims = 1:14,
  n.neighbors = 5,
  min.dist = 0.8)

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", as.character())

# Add metadata to the Seurat object
seuratQCMergedCleanedDS <- seuratQCMergedCleanedDS %>%
  Seurat::AddMetaData(Idents(seuratQCMergedCleanedDS), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratQCMergedCleanedDS) <- seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]

# Ensure data layers are joined
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratQCMergedCleanedDS, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])

palRNAClusters <-
  big_colorblind_pal(
    n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]),
    shuffle_colors = TRUE,
    drop_yellow = TRUE, drop_black = TRUE) %>%
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])

# Get the "ggsci::uniform_startrek" palette and adjust it
palRNAClusters <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))
```

```{r integration}
seuratQCMergedCleanedDSInteg <- JoinLayers(seuratQCMergedCleanedDS)
seuratQCMergedCleanedDSInteg[["RNA"]] <- split(seuratQCMergedCleanedDSInteg[["RNA"]], f = seuratQCMergedCleanedDSInteg$donorId)

# This will normalize and find variable features for each layer separately. A consensus set of variable features is automatically identified by Seurat
seuratQCMergedCleanedDSInteg <- NormalizeData(seuratQCMergedCleanedDSInteg)
seuratQCMergedCleanedDSInteg <- FindVariableFeatures(seuratQCMergedCleanedDSInteg)
seuratQCMergedCleanedDSInteg <- ScaleData(seuratQCMergedCleanedDSInteg)
seuratQCMergedCleanedDSInteg <- RunPCA(seuratQCMergedCleanedDSInteg)

seuratQCMergedCleanedDSInteg <- IntegrateLayers(
  object = seuratQCMergedCleanedDSInteg, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.rpca",
  verbose = FALSE
)
```

```{r scDEED}
# use scDEED to optimize the UMAP hyperparameters
K_ <- 14 # 14 # number of PCs

start_time.tmp <- Sys.time()

scDEEDResult <- scDEED(seuratQCMergedCleanedDS, # input Seurat object (must have UMAP or t-SNE already run)
  K = K_, # number of PCs
  reduction.method = "umap", # 'umap' or 'tsne'
  min.dist =  0.6, # c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), # 0.4, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
  n_neighbors = 5, # c(5, 20, 30, 40, 50), # 5, # c(5, 20, 30, 40, 50), #scDEED defaults. Seurat default is 30.
  similarity_percent = 0.5, # default
  dubious_cutoff = 0.05, # default
  trustworthy_cutoff = 0.95) # default

end_time.tmp <- Sys.time()

time_elapsed <- end_time.tmp - start_time.tmp
print(time_elapsed) # Time difference of 19.69495 mins

rm_tmp(ask = FALSE)

# add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1

# utilizing scDEED output
min(scDEEDResult$num_dubious$number_dubious_cells) # 437 # 26 with opt
opt <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells))
m <- scDEEDResult$num_dubious$min.dist[opt] # 0.1 # 0.3 #0.5
n <- scDEEDResult$num_dubious$n_neighbors[opt] # 30 (only value tested) # 5 #5

dubious_cells <- scDEEDResult$full_results$dubious_cells[opt]
dubious_cells <- as.numeric(strsplit(dubious_cells, ",")[[1]])
trustworthy_cells <- scDEEDResult$full_results$trustworthy_cells[opt]
trustworthy_cells <- as.numeric(strsplit(trustworthy_cells, ",")[[1]])
set.seed(6022)
SeuratUMAPscDEEDOpt <- RunUMAP(seuratQCMergedCleanedDS,
  dims = 1:K_,
  min.dist = m,
  n.neighbors = n)
# seed.use = 100)

# match up the dubious/trustworthy lists with the seurat data
rownames_seurat <- rownames(SeuratUMAPscDEEDOpt@meta.data)
rownames_dubious <- rownames_seurat[dubious_cells]
rownames_trustworthy <- rownames_seurat[trustworthy_cells]

designation <- rep("intermediate", length(rownames_seurat))

designation[rownames_seurat %in% rownames_dubious] <- "dubious"
designation[rownames_seurat %in% rownames_trustworthy] <- "trustworthy"

SeuratUMAPscDEEDOpt@meta.data$designation <- designation

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDoptUMAPdubiosityDS.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDOpt,
  reduction = "umap",
  # cells.highlight = list('dubious' = rownames_dubious, 'trustworthy' = rownames_trustworthy)) +
  group = "designation") +
  scale_color_manual(values = c("dubious" = "red", "intermediate" = "gray", "trustworthy" = "blue"))

dev.off()

rm_tmp(ask = FALSE)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDoptUMAPDS.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDOpt,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1)

dev.off()

rm_tmp(ask = FALSE)

# utilizing scDEED output (non-opt)
max(scDEEDResult$num_dubious$number_dubious_cells) # 453
opt <- which(scDEEDResult$num_dubious$number_dubious_cells == max(scDEEDResult$num_dubious$number_dubious_cells))
m <- scDEEDResult$num_dubious$min.dist[opt] # 0.4
n <- scDEEDResult$num_dubious$n_neighbors[opt] # 30 (only value tested)

dubious_cells <- scDEEDResult$full_results$dubious_cells[opt]
dubious_cells <- as.numeric(strsplit(dubious_cells, ",")[[1]])
trustworthy_cells <- scDEEDResult$full_results$trustworthy_cells[opt]
trustworthy_cells <- as.numeric(strsplit(trustworthy_cells, ",")[[1]])
set.seed(6022)
SeuratUMAPscDEEDNonOpt <- RunUMAP(seuratQCMergedCleanedDS,
  dims = 1:K_,
  min.dist = m,
  n.neighbors = n)
# seed.use = 100)

# match up the dubious/trustworthy lists with the seurat data
rownames_seurat <- rownames(SeuratUMAPscDEEDNonOpt@meta.data)
rownames_dubious <- rownames_seurat[dubious_cells]
rownames_trustworthy <- rownames_seurat[trustworthy_cells]

designation <- rep("intermediate", length(rownames_seurat))

designation[rownames_seurat %in% rownames_dubious] <- "dubious"
designation[rownames_seurat %in% rownames_trustworthy] <- "trustworthy"

SeuratUMAPscDEEDNonOpt@meta.data$designation <- designation

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDnonOptUMAPdubiosity.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDNonOpt,
  reduction = "umap",
  # cells.highlight = list('dubious' = rownames_dubious, 'trustworthy' = rownames_trustworthy)) +
  group = "designation") +
  scale_color_manual(values = c("dubious" = "red", "intermediate" = "gray", "trustworthy" = "blue"))

dev.off()

rm_tmp(ask = FALSE)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDnonOptUMAP.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDNonOpt,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1)

dev.off()

rm_tmp(ask = FALSE)
```

```{r lookAtClusters}

set.seed(6022)
plot.tmp <- DimPlot(object = seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  group = "seurat_clusters_DS",
  shuffle = TRUE,
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

savePlot(
  plot = plot.tmp,
  plotDir = plotDir,
  filename = paste0(filenameSuffix, "_UMAP_RNA"),
  height = 6,
  width = 10,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_clusterFacet.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "ref.map_DS",
  group = "seurat_clusters_DS",
  shuffle = TRUE,
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()
```

```{r lookAtClustersDS}

nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_downsampled.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_downsampled_newPalette.pdf")),
height = 6,
width = 10)

seurat.tmp <- subset(seuratQCMergedCleanedDS, cellType %in% c("Treg", "Tconv"))

DimPlot(object = seurat.tmp,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1,
  shuffle = TRUE) +
  scale_color_manual(values = palRNAClusters2) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")
set.seed(314)
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_noDownsample_newPalette.pdf")),
height = 6,
width = 10)

seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_DS",
  group = "seurat_clusters_DS",
  pt.size = 1,
  shuffle = TRUE) +
  scale_color_manual(values = palRNAClusters2) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# version where we use a contour plot instead..
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Extract UMAP coordinates and metadata
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))
umap_data <- as.data.frame(seurat.tmp@reductions$ref.umap_DS@cell.embeddings)
umap_data$seurat_clusters <- seurat.tmp@meta.data$seurat_clusters_DS
# umap_data$stimulationFigures <- seurat.tmp@meta.data$stimulationFigures

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_noDownsample_contours.pdf")),
height = 6,
width = 10)

contourPlot.tmp <- ggplot(umap_data, aes(x = refumapds_1, y = refumapds_2)) +
  geom_density2d(aes(color = factor(seurat_clusters)), size = 1, bins = 10, contour_var = "ndensity") +
  scale_color_manual(name = "Cluster", values = palRNAClusters2) +
  coord_fixed(ratio = 1) +
  theme_classic() +
  labs(
    x = "UMAP 1",
    y = "UMAP 2",
    title = "UMAP Density Contours by RNA Cluster"
  )

print(contourPlot.tmp)

dev.off()



# Extract UMAP coordinates and metadata
seurat.tmp <- subset(seuratQCMergedCleanedDS, cellType %in% c("Treg", "Tconv"))
umap_data <- as.data.frame(seurat.tmp@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seurat.tmp@meta.data$seurat_clusters
# umap_data$stimulationFigures <- seurat.tmp@meta.data$stimulationFigures

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_Downsample_contours.pdf")),
height = 6,
width = 10)

contourPlot.tmp <- ggplot(umap_data, aes(x = umap_1, y = umap_2)) +
  geom_density2d(aes(color = factor(seurat_clusters)), size = 1, bins = 10, contour_var = "ndensity") +
  scale_color_manual(name = "Cluster", values = palRNAClusters2) +
  coord_fixed(ratio = 1) +
  theme_classic() +
  labs(
    x = "UMAP 1",
    y = "UMAP 2",
    title = "UMAP Density Contours by RNA Cluster"
  )

print(contourPlot.tmp)

dev.off()





pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_clusterFacet_downsampled.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seuratQCMergedCleanedDS@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seuratQCMergedCleanedDS@meta.data$seurat_clusters
umap_data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_stimulationFacet_downsampled.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = seurat_clusters)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r clusterProportionPlots}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratQCMergedCleanedDS@meta.data$studyGroup <- as.factor(seuratQCMergedCleanedDS@meta.data$studyGroup)
seuratQCMergedCleanedDS@meta.data$stimulationFigures <- as.factor(seuratQCMergedCleanedDS@meta.data$stimulationFigures)
seuratQCMergedCleanedDS@meta.data$donorIdFigures <- as.factor(seuratQCMergedCleanedDS@meta.data$donorIdFigures)
seuratQCMergedCleanedDS@meta.data$seurat_clusters <- as.factor(seuratQCMergedCleanedDS@meta.data$seurat_clusters)

# Extract metadata
metadata <- seuratQCMergedCleanedDS@meta.data

# Plot proportions of studyGroup in each seurat_clusters
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_studyGroup_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal()
dev.off()

# Plot proportions of stimulation in each seurat_clusters
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_stimulation_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  theme_minimal()
dev.off()

# Plot proportions of donorId in each seurat_clusters
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_donorId_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  theme_minimal()
dev.off()

# Plot proportions of donorId in each seurat_clusters, facet on stimulation
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_donorId_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  facet_wrap(~stimulationFigures, ncol = 1) +
  theme_minimal()
dev.off()

# all together now
# Create the three plots
plot1 <- ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

# all together now (POSTER
fontSize <- 14

# Create the three plots
plot1 <- ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot2 <- ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v", rel_heights = c(1, 1, 1.2))

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_poster.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()
```

```{r clusterProportionBarPlotsManuscript}
# subset down to called cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_DS))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seurat.tmp@meta.data$studyGroup <- as.factor(seurat.tmp@meta.data$studyGroup)
seurat.tmp@meta.data$stimulationFigures <- as.factor(seurat.tmp@meta.data$stimulationFigures)
seurat.tmp@meta.data$donorIdFigures <- as.factor(seurat.tmp@meta.data$donorIdFigures)
seurat.tmp@meta.data$seurat_clusters_DS <- as.factor(seurat.tmp@meta.data$seurat_clusters_DS)

# Extract metadata
metadata.tmp <- seurat.tmp@meta.data

# Create the three plots
plot1 <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

# plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
#   geom_bar(position = "fill") +
#   labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
#   scale_fill_manual(values = palDonorId) +
#   theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_studyGroup_stimulation_Proportions_in_seurat_clusters.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

rm_tmp(ask = FALSE)

# subset down to Tregs
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Treg))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seurat.tmp@meta.data$studyGroup <- as.factor(seurat.tmp@meta.data$studyGroup)
seurat.tmp@meta.data$stimulationFigures <- as.factor(seurat.tmp@meta.data$stimulationFigures)
seurat.tmp@meta.data$donorIdFigures <- as.factor(seurat.tmp@meta.data$donorIdFigures)
seurat.tmp@meta.data$seurat_clusters_Treg <- as.factor(seurat.tmp@meta.data$seurat_clusters_Treg)

# Extract metadata
metadata.tmp <- seurat.tmp@meta.data

# Create the three plots
plot1 <- ggplot(metadata.tmp, aes(x = seurat_clusters_Treg, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Treg Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata.tmp, aes(x = seurat_clusters_Treg, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Treg Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

# plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
#   geom_bar(position = "fill") +
#   labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
#   scale_fill_manual(values = palDonorId) +
#   theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_studyGroup_stimulation_Proportions_in_seurat_clusters_Treg.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

rm_tmp(ask = FALSE)

# subset down to Tconvs
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Tconv))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seurat.tmp@meta.data$studyGroup <- as.factor(seurat.tmp@meta.data$studyGroup)
seurat.tmp@meta.data$stimulationFigures <- as.factor(seurat.tmp@meta.data$stimulationFigures)
seurat.tmp@meta.data$donorIdFigures <- as.factor(seurat.tmp@meta.data$donorIdFigures)
seurat.tmp@meta.data$seurat_clusters_Tconv <- as.factor(seurat.tmp@meta.data$seurat_clusters_Tconv)

# Extract metadata
metadata.tmp <- seurat.tmp@meta.data

# Create the three plots
plot1 <- ggplot(metadata.tmp, aes(x = seurat_clusters_Tconv, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Tconv Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata.tmp, aes(x = seurat_clusters_Tconv, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Tconv Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

# plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
#   geom_bar(position = "fill") +
#   labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
#   scale_fill_manual(values = palDonorId) +
#   theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_studyGroup_stimulation_Proportions_in_seurat_clusters_Tconv.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

rm_tmp(ask = FALSE)

gc()

# Let's look at the downsampled seuratTreg object...
seurat.tmp <- seuratTreg

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seurat.tmp@meta.data$studyGroup <- as.factor(seurat.tmp@meta.data$studyGroup)
seurat.tmp@meta.data$stimulationFigures <- as.factor(seurat.tmp@meta.data$stimulationFigures)
seurat.tmp@meta.data$donorIdFigures <- as.factor(seurat.tmp@meta.data$donorIdFigures)
seurat.tmp@meta.data$seurat_clusters <- as.factor(seurat.tmp@meta.data$seurat_clusters)
seurat.tmp@meta.data$cellType <- as.factor(seurat.tmp@meta.data$cellType)

# Extract metadata
metadata.tmp <- seurat.tmp@meta.data

# Create the three plots
plot1 <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Treg Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Treg Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

plot3 <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellType)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Cell Type", title = "Proportions of Cell Type in Treg Clusters") +
  scale_fill_manual(values = palCellType) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_studyGroup_stimulation_cellType_Proportions_in_seurat_clusters_Treg.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

rm_tmp(ask = FALSE)

# Let's look at the downsampled seuratTconv object...
seurat.tmp <- seuratTconv

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seurat.tmp@meta.data$studyGroup <- as.factor(seurat.tmp@meta.data$studyGroup)
seurat.tmp@meta.data$stimulationFigures <- as.factor(seurat.tmp@meta.data$stimulationFigures)
seurat.tmp@meta.data$donorIdFigures <- as.factor(seurat.tmp@meta.data$donorIdFigures)
seurat.tmp@meta.data$seurat_clusters <- as.factor(seurat.tmp@meta.data$seurat_clusters)
seurat.tmp@meta.data$cellType <- as.factor(seurat.tmp@meta.data$cellType)

# Extract metadata
metadata.tmp <- seurat.tmp@meta.data

# Create the three plots
plot1 <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Tconv Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Tconv Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

plot3 <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellType)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Cell Type", title = "Proportions of Cell Type in Tconv Clusters") +
  scale_fill_manual(values = palCellType) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_studyGroup_stimulation_cellType_Proportions_in_seurat_clusters_Tconv.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

rm_tmp(ask = FALSE)
```

```{r CITEseqMarkersPerCluster}
fb_data <- as.data.frame(t(as.matrix(seuratQCMergedCleanedDS@assays$FB@data)))

fb_data$seurat_clusters <- seuratQCMergedCleanedDS@meta.data$seurat_clusters

fb_data_long <- melt(fb_data, id.vars = "seurat_clusters", variable.name = "Feature", value.name = "Expression")

combined_plot <- ggplot(fb_data_long, aes(x = seurat_clusters, y = Expression, fill = seurat_clusters)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, size = 0.5, alpha = 0.5) +
  facet_wrap(~Feature, scales = "free_y") +
  labs(x = "Seurat Clusters", y = "Expression", title = "Boxplots of FB Features per Seurat Clusters") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

pdf(file.path(plotDir, paste0(filenameSuffix, "_Boxplots_FB_per_seurat_clusters.pdf")), height = 7, width = 12)
print(combined_plot)
dev.off()
```

```{r getTopClusterDefiningGenesDownsampled}
nGenes <- 20
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
Idents(seuratQCMergedCleanedDS) <- "seurat_clusters"
# Join the data layers
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

clusterMarkers <- FindAllMarkers(seuratQCMergedCleanedDS)

# implement a filter so that we only consider genes expressed in a certain percentage of cells
# Calculate the percentage of cells with non-zero expression for each gene in each cluster
expressionData <- FetchData(seuratQCMergedCleanedDS, vars = unique(clusterMarkers$gene))
metadata <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::select(seurat_clusters) %>%
  rownames_to_column("cell")

expressionData <- expressionData %>%
  rownames_to_column("cell") %>%
  left_join(metadata, by = "cell")

expressionDataLong <- expressionData %>%
  pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

expressionDataSummary <- expressionDataLong %>%
  group_by(seurat_clusters, gene) %>%
  summarise(percent_expressed = mean(expression > 0) * 100)

min_percent_expressed <- 30
clusterMarkers <- clusterMarkers %>%
  left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
  filter(percent_expressed >= min_percent_expressed)
# end of expressed in x% of cells filtering


topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = nGenes) %>%
  dplyr::slice_min(p_val_adj, n = nGenes) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters)) # , each = 4

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataOutputDir, paste0("top", as.character(nGenes), "_genes_per_cluster_downsampled.csv")), quote = FALSE, row.names = TRUE)
```

```{r clusterDefiningGenesDotPlot}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 12

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
dotPlot.tmp <- DotPlot(seuratQCMergedCleanedDS, features = genes.tmp) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
    text = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize)) +
  labs(y = "Clusters", x = "Genes")

# Print the DotPlot
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_clusterDefiningGenesDotPlot.pdf")), height = 5, width = 12)
print(dotPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r calculateDiversityMetricsForClusterDefiningGenes}
library(vegan)
# Ensure the correct assay and identity class are set
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
Idents(seuratQCMergedCleanedDS) <- "seurat_clusters"

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Check if the genes are present in the dataset
genes_present <- genes.tmp %in% rownames(seuratQCMergedCleanedDS)

# Print the genes that are not found in the dataset
print(genes.tmp[!genes_present])

# Filter out the genes that are not present in the dataset
genes.tmp <- genes.tmp[genes_present]

# Calculate the mean expression of each gene in each cluster
mean_expression <- AverageExpression(seuratQCMergedCleanedDS, features = genes.tmp, assays = "RNA")

# Convert the mean expression data to a data frame
mean_expression_df <- as.data.frame(mean_expression$RNA)

# Calculate the Bray-Curtis dissimilarity between clusters
bray_curtis_dissimilarity <- vegdist(t(mean_expression_df), method = "bray")

# Convert the Bray-Curtis dissimilarity object to a matrix
bray_curtis_matrix <- as.matrix(bray_curtis_dissimilarity)

# Extract the off-diagonal elements
off_diagonal_elements <- bray_curtis_matrix[upper.tri(bray_curtis_matrix)]
rownames(bray_curtis_matrix) <- gsub("g", "cluster ", rownames(bray_curtis_matrix))
colnames(bray_curtis_matrix) <- gsub("g", "cluster ", colnames(bray_curtis_matrix))

# Calculate the mean of the off-diagonal elements
meanBrayCurtis <- mean(off_diagonal_elements)
meanBrayCurtis <- round(meanBrayCurtis, digits = 3)


columnTitleString <- paste0("Mean Bray-Curtis Dissimilarity = ", as.character(meanBrayCurtis))

# Create a heatmap from the Bray-Curtis dissimilarity matrix using ComplexHeatmap
BCHeatmap.tmp <- Heatmap(bray_curtis_matrix,
  name = "Bray-Curtis \nDissimilarity",
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_dend = TRUE,
  show_column_dend = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  column_title = columnTitleString)

# Print the heatmap
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_clusterBrayCurtisHeatmap.pdf")), height = 5, width = 6)
print(BCHeatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r setHTAsColumn}
# Fetch the data from the "HT" assay
ht_data <- seuratQCMergedCleanedDS[["HT"]]@data

# Get the names of the HT assay for each cell
ht_names <- colnames(ht_data)

# Add the HT names to the metadata
seuratQCMergedCleanedDS[["HT_names"]] <- ht_names

# Fetch the data from the "HT" assay
ht_data <- seuratQCMergedCleaned[["HT"]]@data

# Get the names of the HT assay for each cell
ht_names <- colnames(ht_data)

# Add the HT names to the metadata
seuratQCMergedCleaned[["HT_names"]] <- ht_names
```

```{r defineGenesOfInterestTregTconv}
genesOfInterest <- c("LDHB", "FABP5", "MYO1B", "ACSL6", "FZD3", "FASLG",
  "SPRY1", "UBE2E2", "RGCC", "TNFSF11", "ZNF704", "RAI2",
  "TTC8", "IL2", "DHRS3", "NELL2", "MAMLD1", "MAP7",
  "ARMH1", "IL3", "CSF2", "XCL1", "LRRN3", "FHL1",
  "RRAGD", "ADORA2B", "CNN3", "JAK1", "FTL", "CTLA4",
  "SYTL3", "ZNF292", "CHST11", "IL2RA", "PICALM", "IL2RB",
  "GNG2", "IL32", "CD74", "CD74", "ARL6IP5", "TIGIT",
  "IKZF2", "CTTNBP2NL", "FUT7", "MAN1A2", "ENTPD1", "LRRC32",
  "CCR8", "HLA-DQA1", "HLA-DRB1", "HLA-DRB5", "HLA-DQA2", "IL1R2",
  "FOXP3", "IL1R1", "CISH", "TXN", "TNFRSF18", "TPMT",
  "SFT2D1")

genesOfInterestTreg <- c("JAK1", "FTL", "CTLA4",
  "SYTL3", "ZNF292", "CHST11", "IL2RA", "PICALM", "IL2RB",
  "GNG2", "IL32", "CD74", "CD74", "ARL6IP5", "TIGIT",
  "IKZF2", "CTTNBP2NL", "FUT7", "MAN1A2", "ENTPD1", "LRRC32",
  "CCR8", "HLA-DQA1", "HLA-DRB1", "HLA-DRB5", "HLA-DQA2", "IL1R2",
  "FOXP3", "IL1R1", "CISH", "TXN", "TNFRSF18", "TPMT",
  "SFT2D1")

genesOfInterestTconv <- c("LDHB", "FABP5", "MYO1B", "ACSL6", "FZD3", "FASLG",
  "SPRY1", "UBE2E2", "RGCC", "TNFSF11", "ZNF704", "RAI2",
  "TTC8", "IL2", "DHRS3", "NELL2", "MAMLD1", "MAP7",
  "ARMH1", "IL3", "CSF2", "XCL1", "LRRN3", "FHL1",
  "RRAGD", "ADORA2B", "CNN3")
```

```{r TregTconvHeatmap}
## Fetch data for genes of interest
heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, genesOfInterest)
heatmapCounts.tmp <- t(heatmapCounts.tmp)

# Ensure metadata order matches data columns
hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ]
sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # Check ordering

# Arrange metadata by clusters
hMapAnno.tmp <- hMapAnno.tmp %>%
  dplyr::arrange(seurat_clusters)

# Reorder columns of heatmapCounts.tmp to match metadata
heatmapCounts.tmp <- heatmapCounts.tmp[, hMapAnno.tmp$HT_names]

# Scale the rows via z-score
heatmapCounts.tmp <- t(scale(t(heatmapCounts.tmp)))

# Reorder rows to group Treg and Tconv genes
genesOfInterestOrdered <- c(genesOfInterestTreg, genesOfInterestTconv)
heatmapCounts.tmp <- heatmapCounts.tmp[genesOfInterestOrdered, ]

# Create a vector indicating the group of each gene
row_split <- c(rep("Treg", length(genesOfInterestTreg)), rep("Tconv", length(genesOfInterestTconv)))

# Define custom color scale with white at 0
col_fun <- colorRamp2(c(-2, 0, 4), c("blue", "white", "red"))

# Generate heatmap with columns grouped by studygroup within each cluster
columnAnno.tmp <- HeatmapAnnotation(stimulationFigures = hMapAnno.tmp$stimulationFigures,
  cluster = hMapAnno.tmp$seurat_clusters,
  col = list(stimulationFigures = palStimulation,
    cluster = palRNAClusters))

heatmap.tmp <- Heatmap(heatmapCounts.tmp,
  top_annotation = columnAnno.tmp,
  name = "gene expr. (z-score)",
  col = col_fun,
  cluster_columns = F,
  show_column_names = F,
  row_names_gp = grid::gpar(fontsize = 8),
  row_split = row_split)  # Add row split to separate Treg and Tconv genes

# Save the heatmap to a PDF file
pdf(
  file = file.path(plotDir, paste0("TregTconvGenesHeatmap.", filenameSuffix, ".pdf")),
  width = 6, height = 6)

print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r TregTconvHeatmapGatedCellsOnly}
# Subset the Seurat object to include only Treg and Tconv cells
seuratQCMergedCleanedDS <- subset(seuratQCMergedCleanedDS, subset = cellType %in% c("Treg", "Tconv"))

# Fetch data for genes of interest
heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, vars = genesOfInterest)
heatmapCounts.tmp <- t(heatmapCounts.tmp)

# Ensure metadata order matches data columns
hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ]
sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # Check ordering

# Calculate log CPM counts
library(edgeR)
dge <- DGEList(counts = heatmapCounts.tmp)
dge <- calcNormFactors(dge)
logCpm.tmp <- cpm(dge, log = TRUE)

# Arrange metadata by clusters
hMapAnno.tmp <- hMapAnno.tmp %>%
  dplyr::arrange(seurat_clusters)

# Reorder columns of logCpm.tmp to match metadata
logCpm.tmp <- logCpm.tmp[, hMapAnno.tmp$HT_names]

# Scale the rows via z-score
logCpm.zscore.tmp <- t(scale(t(logCpm.tmp)))

# Reorder rows to group Treg and Tconv genes
genesOfInterestOrdered <- c(genesOfInterestTreg, genesOfInterestTconv)
logCpm.zscore.tmp <- logCpm.zscore.tmp[genesOfInterestOrdered, ]

# Create a vector indicating the group of each gene
row_split <- c(rep("Treg", length(genesOfInterestTreg)), rep("Tconv", length(genesOfInterestTconv)))

# Define custom color scale with white at 0
col_fun <- colorRamp2(c(-2, 0, 4), c("blue", "white", "red"))

# Define column annotations
columnAnno.tmp <- HeatmapAnnotation(
  stimulationFigures = hMapAnno.tmp$stimulationFigures,
  cluster = hMapAnno.tmp$seurat_clusters,
  col = list(
    stimulationFigures = palStimulation,
    cluster = palRNAClusters
  )
)

# Generate the heatmap
heatmap.tmp <- Heatmap(
  logCpm.zscore.tmp,
  top_annotation = columnAnno.tmp,
  name = "gene expr. (z-score)",
  col = col_fun,
  cluster_columns = FALSE,
  show_column_names = FALSE,
  row_names_gp = grid::gpar(fontsize = 8),
  row_split = row_split  # Add row split to separate Treg and Tconv genes
)

# Save the heatmap to a PDF file
pdf(
  file = file.path(plotDir, paste0("TregTconvGenesHeatmap.", filenameSuffix, ".pdf")),
  width = 6, height = 6
)

print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r top10ClusterDefiningGenesHeatmap}
# Average top marker expr by cluster.
nGenes <- 10

clusterMarkers.tmp <- FindAllMarkers(seuratQCMergedCleanedDS)

topMarkersHmap.tmp <- clusterMarkers.tmp %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>% # means up in this cluster relative to everything else
  dplyr::slice_max(avg_log2FC, n = nGenes) %>%
  dplyr::slice_min(p_val_adj, n = nGenes) %>%
  dplyr::mutate(fc_order = order(avg_log2FC)) # ordered high to low

selectedFeatures.tmp <- unique(topMarkersHmap.tmp$gene)

heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, selectedFeatures.tmp)
heatmapCounts.tmp <- t(heatmapCounts.tmp)
# heatmapCounts.tmp <- scale(t(heatmapCounts.tmp))
# heatmapCounts.tmp <- t(scale(log10(heatmapCounts.tmp + 0.5)))
# heatmapCounts.tmp <- t(log10(heatmapCounts.tmp + 0.5))
hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ] # make the orders match
sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # check to make sure the ordering is correct

hMapAnno.tmp <- hMapAnno.tmp %>%
  dplyr::arrange(seurat_clusters)

heatmapCounts.tmp <- heatmapCounts.tmp[, hMapAnno.tmp$HT_names]
# generate a heatmap with columns grouped by studygroup within each cluster

columnAnno.tmp <- HeatmapAnnotation(stimulationFigures = hMapAnno.tmp$stimulationFigures,
  cluster = hMapAnno.tmp$seurat_clusters,
  col = list(stimulationFigures = palStimulation,
    cluster = palRNAClusters))

heatmap.tmp <- Heatmap(heatmapCounts.tmp,
  top_annotation = columnAnno.tmp,
  name = "log10(gene expr.) (z-score)",
  cluster_columns = F,
  show_column_names = F,
  row_names_gp = grid::gpar(fontsize = 8))

pdf(
  file =
    file.path(
      plotDir,
      paste0("top10ClusterDefiningGenesHeatmap.", filenameSuffix, ".pdf")),
  width = 10, height = 7)

print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r clusterDefiningGenesHeatmaps}
# Average top marker expr by cluster.
nGenes <- 50

# Loop through clusters 0 to 8
for (clusterOfInterest.tmp in 0:6) {

  clusterMarkers.tmp <- FindAllMarkers(seuratQCMergedCleanedDS)

  topMarkersHmap.tmp <- clusterMarkers.tmp %>%
    dplyr::filter(cluster == clusterOfInterest.tmp) %>%  # Restrict to current cluster
    dplyr::filter(avg_log2FC > 0) %>% # means up in this cluster relative to everything else
    dplyr::slice_max(avg_log2FC, n = nGenes) %>%
    dplyr::slice_min(p_val_adj, n = nGenes) %>%
    dplyr::mutate(fc_order = order(avg_log2FC))

  selectedFeatures.tmp <- unique(topMarkersHmap.tmp$gene)

  heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, selectedFeatures.tmp)
  # heatmapCounts.tmp <- scale(t(heatmapCounts.tmp))
  # heatmapCounts.tmp <- t(scale(heatmapCounts.tmp))
  heatmapCounts.tmp <- t(heatmapCounts.tmp)
  hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
  hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ] # make the orders match
  sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # check to make sure the ordering is correct

  hMapAnno.tmp <- hMapAnno.tmp %>%
    dplyr::arrange(seurat_clusters)

  heatmapCounts.tmp <- heatmapCounts.tmp[, hMapAnno.tmp$HT_names]
  # generate a heatmap with columns grouped by studygroup within each cluster

  columnAnno.tmp <- HeatmapAnnotation(stimulationFigures = hMapAnno.tmp$stimulationFigures,
    cluster = hMapAnno.tmp$seurat_clusters,
    col = list(stimulationFigures = palStimulation,
      cluster = palRNAClusters))

  heatmap.tmp <- Heatmap(heatmapCounts.tmp,
    top_annotation = columnAnno.tmp,
    name = "gene expr. (z-score)",
    cluster_columns = F,
    show_column_names = F,
    row_names_gp = grid::gpar(fontsize = 8))

  pdf(
    file =
      file.path(
        plotDir,
        paste0("top50Cluster", clusterOfInterest.tmp, "DefiningGenesHeatmap.", filenameSuffix, ".pdf")),
    width = 10, height = 7)

  print(heatmap.tmp)

  dev.off()
}

rm_tmp(ask = FALSE)
```

```{r defineGeneOfInterestPlotFunction}
plotGenesOfInterest <- function(seuratObject, geneList, fileName, reductionName = "umap", nCols = 2) {
  pdf(
    file =
      file.path(
        plotDir,
        paste0(fileName, filenameSuffix, ".pdf")),
    width = 6, height = 5)

  genesOfInterestPlot <- FeaturePlot(
    object = seuratObject,
    reduction = reductionName,
    features = geneList,
    ncol = nCols,
    order = TRUE
  ) &
    scale_color_viridis_c() &
    labs(x = "UMAP 1", y = "UMAP 2") &
    theme(aspect.ratio = 1)

  print(genesOfInterestPlot)
  dev.off()
}
```

```{r defineGeneOfInterestPlotFunctionStimulationFacet}
# Define the function to plot genes of interest with facet wrap by stimulationFigures
# Define the function to plot a single gene of interest with facet wrap by stimulationFigures
plotGenesOfInterestStimFacet <- function(seuratObject, gene, fileName, reductionName = "umap", nCols = 2) {
  pdf(
    file = file.path(plotDir, paste0(fileName, filenameSuffix, ".pdf")),
    width = 9, height = 5.5
  )

  # Get UMAP coordinates directly from reduction
  umap_coords <- Embeddings(seuratObject, reduction = reductionName)

  # Get other data
  other_data <- FetchData(seuratObject, vars = c("stimulationFigures", gene))

  # Combine data
  data <- data.frame(
    umap_1 = umap_coords[, 1],
    umap_2 = umap_coords[, 2],
    other_data
  )

  # Create a custom ggplot
  genesOfInterestPlot <- ggplot(data, aes(x = umap_1, y = umap_2, color = .data[[gene]])) +
    geom_point(size = 0.5) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2") +
    theme(aspect.ratio = 1) +
    facet_wrap(~stimulationFigures, ncol = nCols)

  print(genesOfInterestPlot)
  dev.off()
}
```

```{r genesOfInterestOnUMAP_wFunction}
# prints out a separate expression UMAP for each gene in genesOfInterest
for (gene in genesOfInterest) {
  plotGenesOfInterest(
    seuratQCMergedCleaned,
    gene,
    reductionName = "ref.umap_DS",
    paste0("seuratUMAP_", gene),
    nCols = 1
  )
}
```

```{r GLP1RExpressionOnUMAPForSarahKobernat}
# 20250513 reqeust for GLP1R expression
genesOfInterest.tmp <- "GLP1R"

for (gene in genesOfInterest.tmp) {
  plotGenesOfInterest(
    seuratQCMergedCleaned,
    gene,
    reductionName = "ref.umap_DS",
    paste0("seuratUMAP_", gene),
    nCols = 1
  )
}

pdf(
  file = file.path(plotDir, paste0("GLP1R_UMAPStimulationFacet", filenameSuffix, ".pdf")),
  width = 12, height = 8
)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleaned, "ref.umap_DS")
colnames(umap_data) <- c("UMAP_1", "UMAP_2")
umap_data_df <- as.data.frame(umap_data)
umap_data_df$cells <- rownames(umap_data_df)

# Extract GLP1R expression (assumes RNA assay, adjust if needed)
glp1r_expr <- FetchData(seuratQCMergedCleaned, vars = "GLP1R")
glp1r_expr$cells <- rownames(glp1r_expr)
colnames(glp1r_expr)[1] <- "GLP1R_expression"

# Merge UMAP and expression data
plot_data <- merge(umap_data_df, glp1r_expr, by = "cells")

# Optionally add metadata and facets if needed
metadata <- seuratQCMergedCleaned@meta.data
metadata$cells <- rownames(metadata)
plot_data <- merge(plot_data, metadata, by = "cells")

# Shuffle rows for plotting
set.seed(314)
plot_data <- plot_data[sample(nrow(plot_data)), ]

# Plot GLP1R expression on UMAP
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = GLP1R_expression)) +
  geom_point(size = 1) +
  scale_color_viridis_c(option = "viridis", name = "GLP1R Expression") +
  labs(x = "UMAP 1", y = "UMAP 2") +
  theme(
    aspect.ratio = 1,
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 12)
  ) +
  facet_wrap(~stimulationFigures)

print(p)
dev.off()
```

```{r plotTH2aGenesOnUMAPTomoakiTakao}
genesOfInterest.tmp <- c("CD3D", "CD3E", "CD3G", "CD4", "HPGDS", "PTGDR2", "KLRB1", "IL1RL1", "ITGA4", "CD27", "LARP1")

# genes on UMAP
for (gene in genesOfInterest.tmp) {
  plotGenesOfInterest(
    seuratQCMergedCleaned,
    gene,
    reductionName = "ref.umap_DS",
    paste0("seuratUMAP_", gene),
    nCols = 1
  )
}

# genes on UMAP, facet by stimulation
for (gene in genesOfInterest.tmp) {
  plotGenesOfInterestStimFacet(
    seuratQCMergedCleaned,
    gene,
    reductionName = "ref.umap_DS",
    paste0("seuratUMAP_stimulationFacet_", gene),
    nCols = 3
  )
}

rm_tmp(ask = FALSE)
```

```{r genesOfInterestOnUMAP_TregModuleExpression}
# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTreg)
)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTregExpressionOnUMAP", filenameSuffix, ".pdf")),
  width = 6, height = 5)

# Plot the UMAP with the mean expression of genesOfInterestTreg
TregUMAP.plt.tmp <- FeaturePlot(
  seuratQCMergedCleanedDS,
  features = "meanExpressionTreg",
  reduction = "umap"
) + ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean expression \nZ-score")

print(TregUMAP.plt.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r genesOfInterestOnUMAP_TregModuleExpression_stimulationFacet}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTreg)
)

# Extract UMAP coordinates and mean expression data
umap_data.tmp <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
umap_data.tmp$meanExpressionTreg <- FetchData(seuratQCMergedCleanedDS, "meanExpressionTreg")$meanExpressionTreg
umap_data.tmp$stimulationFigures <- as.factor(seuratQCMergedCleanedDS$stimulationFigures)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTregExpressionOnUMAPStimulationFacet", nClustString, filenameSuffix, ".pdf")),
  width = 12, height = 3)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTreg)) +
  geom_point(size = 1) +
  ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean expression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() +
  theme_minimal()

print(TregUMAP.plt.tmp)
dev.off()

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTregExpressionOnUMAPStimulationFacetPoster", nClustString, filenameSuffix, ".pdf")),
  width = 10, height = 3.5)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTreg)) +
  geom_point(size = 1) +
  # ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean \nTreg gene \nexpression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() + # scale_color_gradient(low = "lightgrey", high = "blue") +
  theme_minimal() +
  theme(
    text = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16),
    plot.title = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(TregUMAP.plt.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r meanExpressionTregHistogram}
# generate a histogram of meanExpressionTreg

# Calculate the mean expression of the genes in genesOfInterestTreg for all cells
seuratQCMergedCleaned$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTreg)
)

# Calculate the 75th percentile of meanExpressionTreg
percentile_75_Treg <- quantile(seuratQCMergedCleaned$meanExpressionTreg, 0.75, na.rm = TRUE)

# Generate a histogram of meanExpressionTreg with a vertical line at the 75th percentile
histogramPlot.tmp <- ggplot(data.frame(meanExpressionTreg = seuratQCMergedCleaned$meanExpressionTreg), aes(x = meanExpressionTreg)) +
  geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) +
  geom_vline(aes(xintercept = percentile_75_Tconv), color = "red", linetype = "dashed", size = 1) +
  labs(title = "Histogram of meanExpressionTreg",
    x = "Mean Expression Treg",
    y = "Frequency") +
  theme_minimal()

# Start PDF printing
pdf(file.path(plotDir, paste0(filenameSuffix, "meanExpressionTreg_Histogram.pdf")),
  height = 5,
  width = 7)

# Print the histogram
print(histogramPlot.tmp)

# Close the PDF device
dev.off()

# rm_tmp(ask = FALSE)
```

```{r meanExpressionTconvHistogram}
# generate a histogram of meanExpressionTreg

# Calculate the mean expression of the genes in genesOfInterestTreg for all cells
seuratQCMergedCleaned$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTconv)
)

# Calculate the 75th percentile of meanExpressionTconv
percentile_75_Tconv <- quantile(seuratQCMergedCleaned$meanExpressionTconv, 0.75, na.rm = TRUE)

# Generate a histogram of meanExpressionTconv with a vertical line at the 75th percentile
histogramPlot.tmp <- ggplot(data.frame(meanExpressionTconv = seuratQCMergedCleaned$meanExpressionTconv), aes(x = meanExpressionTconv)) +
  geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) +
  geom_vline(aes(xintercept = percentile_75_Tconv), color = "red", linetype = "dashed", size = 1) +
  labs(title = "Histogram of meanExpressionTconv",
    x = "Mean Expression Tconv",
    y = "Frequency") +
  theme_minimal()

# Start PDF printing
pdf(file.path(plotDir, paste0(filenameSuffix, "meanExpressionTconv_Histogram.pdf")),
  height = 5,
  width = 7)

# Print the histogram
print(histogramPlot.tmp)

# Close the PDF device
dev.off()

# rm_tmp(ask = FALSE)
```

```{r genesOfInterestOnUMAP_TconvModuleExpression}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTconv)
)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTconvExpressionOnUMAP", nClustString, filenameSuffix, ".pdf")),
  width = 6, height = 5)

# Plot the UMAP with the mean expression of genesOfInterestTreg
TregUMAP.plt.tmp <- FeaturePlot(
  seuratQCMergedCleanedDS,
  features = "meanExpressionTconv",
  reduction = "umap"
) + ggtitle("Mean Expression of Tconv Genes") +
  labs(color = "Mean expression")

print(TregUMAP.plt.tmp)
dev.off()
rm_tmp(ask = FALSE)
```


```{r genesOfInterestOnUMAP_TconvModuleExpression_stimulationFacet}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTconv)
)

# Extract UMAP coordinates and mean expression data
umap_data.tmp <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
umap_data.tmp$meanExpressionTconv <- FetchData(seuratQCMergedCleanedDS, "meanExpressionTconv")$meanExpressionTconv
umap_data.tmp$stimulationFigures <- as.factor(seuratQCMergedCleanedDS$stimulationFigures)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTconvExpressionOnUMAPStimulationFacet", nClustString, filenameSuffix, ".pdf")),
  width = 12, height = 3)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTconv)) +
  geom_point(size = 1) +
  ggtitle("Mean Expression of Tconv Genes") +
  labs(color = "Mean expression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() +
  theme_minimal()

print(TregUMAP.plt.tmp)
dev.off()

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTconvExpressionOnUMAPStimulationFacetPoster", nClustString, filenameSuffix, ".pdf")),
  width = 10, height = 3.5)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTconv)) +
  geom_point(size = 1) +
  # ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean \nTconv gene \nexpression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() + # scale_color_gradient(low = "lightgrey", high = "blue") +
  theme_minimal() +
  theme(
    text = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16),
    plot.title = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(TregUMAP.plt.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r showHashtagsOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()
```

```{r showHashtagsOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Hashtag", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()
```

```{r showDonorIDOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "donorId",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_Facet.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "donorId",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~donorId)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_clusterFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleaned, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleaned@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = donorId)) +
  geom_point(size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Donor ID", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters) # Now using the combined data

print(p)
dev.off()
```

```{r showDonorIDOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "donorIdFigures",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_FacetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "donorIdFigures",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~donorIdFigures)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_clusterFacetDS.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleanedDS@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = donorIdFigures)) +
  geom_point(size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Donor ID", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters) # Now using the combined data

print(p)
dev.off()
```

```{r showstemnessScoreOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScoreDS.pdf")),
height = 6,
width = 12)

FeaturePlot(object = seuratQCMergedCleanedDS,
  features = "stemnessScore",
  reduction = "umap",
  pt.size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1)
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScore_FacetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "donorIdFigures",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~donorIdFigures)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_clusterFacetDS.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleanedDS@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = donorIdFigures)) +
  geom_point(size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Donor ID", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters) # Now using the combined data

print(p)
dev.off()
```

```{r showCellTypistCallingOnUMAPDS}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_celltypistLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "cellTypistCalling",
  pt.size = 1) +
  scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCallingL3", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_UMAP_RNA_cellTypistLabel_stimulationFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleanedDS@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCalling)) +
  geom_point(size = 1) +
  scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()
```

```{r showTotalSeqCallingOnUMAP}
nClust <- length(table(seuratQCMergedCleaned@meta.data$seurat_clusters_DS))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# set levels
levels(seuratQCMergedCleaned@meta.data$cellTypeTotalSeq) <- c("Treg", "Tconv", "Other")

# Get the current levels
celltype_levels <- levels(seuratQCMergedCleaned@meta.data$cellTypeTotalSeq)

# Create new labels, replacing "Other" with "Not Ag-specific"
new_labels <- celltype_levels
new_labels[new_labels == "Other"] <- "Not Ag-specific"
names(new_labels) <- celltype_levels

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_TotalSeqGatingLabel.pdf")),
height = 6,
width = 12)

set.seed(314)
p <- DimPlot(
  object = seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  group.by = "cellTypeTotalSeq",   # use group.by, not group
  shuffle = TRUE,
  pt.size = 1
) +
  scale_color_manual(
    values = palCellType,           # must be in the same order as levels
    labels = new_labels             # just a character vector, not named
  ) +
  labs(
    x = "UMAP 1",
    y = "UMAP 2",
    color = "TotalSeq Gating",
    title = ""
  ) +
  theme(aspect.ratio = 1)

print(p)
dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_UMAP_RNA_cellTypeTotalSeq_stimulationFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleaned, "ref.umap_DS")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleaned@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
# Shuffle the rows of plot_data
set.seed(314)
plot_data <- plot_data[sample(nrow(plot_data)), ]

# Create the plot
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypeTotalSeq)) +
  geom_point(size = 1) +
  scale_color_manual(values = palCellType) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "TotalSeq Calling", title = "") +
  theme(
    aspect.ratio = 1,
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 12)
  ) +
  facet_wrap(~stimulationFigures)


print(p)
dev.off()
```

```{r showCellTypistCallingOnUMAP}
nClust <- length(table(seuratQCMergedCleaned@meta.data$seurat_clusters_DS))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_celltypistLabel.pdf")),
height = 6,
width = 12)

set.seed(314)
DimPlot(object = seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  group = "cellTypistCalling",
  shuffle = TRUE,
  pt.size = 1) +
  scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_UMAP_RNA_cellTypistLabel_stimulationFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleaned, "ref.umap_DS")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleaned@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
# Shuffle the rows of plot_data
set.seed(314)
plot_data <- plot_data[sample(nrow(plot_data)), ]

# Create the plot
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCalling)) +
  geom_point(size = 1) +
  scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "CellTypist Calling", title = "") +
  theme(
    aspect.ratio = 1,
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 12)
  ) +
  facet_wrap(~stimulationFigures)


print(p)
dev.off()
```

```{r showCellTypistCallingL3OnUMAPDS}
nClust <- length(table(seuratTreg@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_TregUMAP_RNA_celltypistLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratTreg,
  reduction = "umap",
  group = "cellTypistCallingL3",
  pt.size = 1) +
  # scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCallingL3", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "Treg_UMAP_RNA_cellTypistLabel_stimulationFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratTreg, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTreg@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCallingL3)) +
  geom_point(size = 1) +
  # scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "Treg_UMAP_RNA_cellTypistLabel_callingFacet.pdf")), height = 7, width = 14)

# Extract UMAP data
umap_data <- Embeddings(seuratTreg, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTreg@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCallingL3)) +
  geom_point(size = 1) +
  # scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~cellTypistCallingL3) # Now using the combined data

print(p)
dev.off()
```

```{r showCellTypistCallingOnUMAPDSTconv}
nClust <- length(table(seuratTconv@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_TconvUMAP_RNA_celltypistLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratTconv,
  reduction = "umap",
  group = "cellTypistCallingL3",
  pt.size = 1) +
  # scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCallingL3", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "Tconv_UMAP_RNA_cellTypistLabel_stimulationFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratTconv, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTconv@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCallingL3)) +
  geom_point(size = 1) +
  # scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "Tconv_UMAP_RNA_cellTypistLabel_callingFacet.pdf")), height = 7, width = 14)

# Extract UMAP data
umap_data <- Embeddings(seuratTconv, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTconv@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCallingL3)) +
  geom_point(size = 1) +
  # scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~cellTypistCallingL3) # Now using the combined data

print(p)
dev.off()
```

```{r cellTypistVsP390}
# Extract the relevant metadata
meta_data <- seuratQCMergedCleanedDS@meta.data

# Create a long format data frame for ggplot2
long_data <- meta_data %>%
  dplyr::select(cellTypistCalling, meanExpressionTreg, meanExpressionTconv) %>%
  pivot_longer(cols = c(meanExpressionTreg, meanExpressionTconv),
    names_to = "ExpressionType",
    values_to = "ExpressionValue")

pdf(file.path(plotDir,
  paste0(filenameSuffix, "P390ModulesCellTypistBoxPlots.pdf")),
height = 6,
width = 12)
# Create boxplots with points displayed
boxplot.tmp <- ggplot(long_data, aes(x = cellTypistCalling, y = ExpressionValue, color = ExpressionType)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  labs(title = "Mean Treg and Tconv Expression by Cell Typist Calling",
    x = "Cell Typist Calling",
    y = "Mean Expression",
    color = "Expression Type") +
  theme_minimal() +
  theme(text = element_text(size = 16))

print(boxplot.tmp)
dev.off()
```

```{r plotPropCellsPerClusterDataQcCd4ByDonorId from MattD}
propCellsPerClusterseuratByDonorId <-
  seuratQCMergedCleaned@meta.data %>%
  dplyr::count(donorIdFigures, studyGroup, !!rlang::sym(clusterName[["RNA"]])) %>%
  tidyr::complete(
    tidyr::expand(., nesting(donorIdFigures, studyGroup), !!rlang::sym(clusterName[["RNA"]])),
    fill = list(n = 0)) %>%
  group_by(donorIdFigures) %>%
  mutate(
    nTotal = sum(n),
    prop = n / nTotal) %>%
  ungroup()

plot.tmp <-
  propCellsPerClusterseuratByDonorId %>%
  ggplot(mapping = aes(x = studyGroup, y = prop, color = studyGroup)) +
  geom_beeswarm(size = 3, cex = 3, groupOnX = TRUE) +
  scale_color_manual(values = palStudyGroup) +
  guides(color = "none") +
  labs(x = NULL, y = "Proportion of CD4 cells in cluster") +
  facet_wrap(vars(!!rlang::sym(clusterName[["rnaCD4"]]))) +
  theme(axis.text.x = element_text(hjust = 0, angle = -45, size = 14),
    plot.margin = margin(t = 10, r = 60, b = 10, l = 10))

pdf(
  file.path(
    plotDir,
    paste0("plotPropCellsPerClusterseuratByDonorId.", filenameSuffix, ".pdf")),
  w = 10, h = 7)
print(plot.tmp)
invisible(dev.off())

rm_tmp(ask = FALSE)
```

```{r showCITEseqOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Save the original default assay
original_default_assay <- DefaultAssay(seuratQCMergedCleaned)

# Set the default assay to 'FB'
DefaultAssay(seuratQCMergedCleaned) <- "FB"

# Define the markers you want to plot
markers <- rownames(seuratQCMergedCleaned@assays$FB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_HTLabel_", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratQCMergedCleaned,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# Reset the default assay to its original
DefaultAssay(seuratQCMergedCleaned) <- original_default_assay
```

```{r showCITEseqOnUMAPDS}
# Save the original default assay
original_default_assay <- DefaultAssay(seuratQCMergedCleanedDS)

# Set the default assay to 'FB'
DefaultAssay(seuratQCMergedCleanedDS) <- "FB"

# Define the markers you want to plot
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_HTLabel_", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratQCMergedCleanedDS,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# now a version that facet_wraps by stimulation
# Define the function to plot a single marker with facet wrap by stimulationFigures
plotMarkerWithFacets <- function(seuratObject, marker) {
  pdf(
    file = file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TotalSeq_stimulationFacet_", marker, ".pdf")),
    width = 10, height = 6
  )

  # Extract the data for the marker of interest
  data <- FetchData(seuratObject, vars = c("umap_1", "umap_2", "stimulationFigures", marker))

  # Create a custom ggplot
  p <- ggplot(data, aes(x = .data$umap_1, y = .data$umap_2, color = .data[[marker]])) +
    geom_point(size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker) +
    theme(aspect.ratio = 1) +
    facet_wrap(~stimulationFigures)

  print(p)
  dev.off()
}

for (marker in markers) {
  plotMarkerWithFacets(seuratQCMergedCleanedDS, marker)
}


# Reset the default assay to its original
DefaultAssay(seuratQCMergedCleanedDS) <- original_default_assay
```

```{r showCITEseqOnUMAPDS_DSB}

# Save the original default assay
original_default_assay <- DefaultAssay(seuratQCMergedCleanedDS)

# Set the default assay to 'FB'
DefaultAssay(seuratQCMergedCleanedDS) <- "DSB"

# Define the markers you want to plot
markers <- rownames(seuratQCMergedCleanedDS@assays$DSB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_HTLabel_DSB", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratQCMergedCleanedDS,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# Reset the default assay to its original
DefaultAssay(seuratQCMergedCleanedDS) <- original_default_assay
```

```{r CD45RACD45ROScatterPlots}
# Extract the expression data for anti-human CD45RO and anti-human CD45RA
CD45ROExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RO", assay = "FB")
CD45RAExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RA", assay = "FB")

# Extract the metadata for stimulationFigures
stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Combine the expression data and metadata into a data frame
expressionData <- data.frame(
  CD45RO = CD45ROExpression$`fb_anti-human CD45RO`,
  CD45RA = CD45RAExpression$`fb_anti-human CD45RA`,
  stimulationFigures = stimulationFigures
)


pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlot.pdf")), height = 6, width = 12)

# Create the scatterplot
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16))

print(scatterPlot.tmp)
dev.off()

pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlotStimulationFacet.pdf")), height = 6, width = 12)

# Create the scatterplot with best fit line, CI, R value, and facet wrap by stimulationFigures
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16)) +
  facet_wrap(~stimulationFigures)

print(scatterPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r CD45RACD45ROScatterPlotsDSB}
# Extract the expression data for anti-human CD45RO and anti-human CD45RA
CD45ROExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RO", assay = "DSB")
CD45RAExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RA", assay = "DSB")

# Extract the metadata for stimulationFigures
stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Combine the expression data and metadata into a data frame
expressionData <- data.frame(
  CD45RO = CD45ROExpression$`anti-human CD45RO`,
  CD45RA = CD45RAExpression$`anti-human CD45RA`,
  stimulationFigures = stimulationFigures
)


pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlotDSB.pdf")), height = 6, width = 12)

# Create the scatterplot
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16))

print(scatterPlot.tmp)
dev.off()

pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlotStimulationFacet.pdf")), height = 6, width = 12)

# Create the scatterplot with best fit line, CI, R value, and facet wrap by stimulationFigures
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16)) +
  facet_wrap(~stimulationFigures)

print(scatterPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r showStudyGroupOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# # Extract UMAP coordinates and mean expression data
# umap_data.tmp <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
# umap_data.tmp$stimulation <- as.factor(seuratQCMergedCleanedDS$stimulation)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel_facet.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~studyGroup)

dev.off()
rm_tmp(ask = FALSE)
```

```{r showStudyGroupOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "study group", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel_facetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "study group", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~studyGroup)

dev.off()

# Ensure the 'stimulation' variable is a factor (if needed)
seuratQCMergedCleanedDS@meta.data$stimulation <- as.factor(seuratQCMergedCleanedDS@meta.data$stimulation)

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
umap_data$studyGroup <- seuratQCMergedCleanedDS@meta.data$studyGroup
umap_data$stimulation <- seuratQCMergedCleanedDS@meta.data$stimulation

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel_facetByStimDS.pdf")),
height = 6,
width = 12)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = studyGroup)) +
  geom_point(size = 1) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "study group", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulation)

dev.off()
```


```{r UMAPDensityPlotsHDeberg}
# subset seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))
seurat.tmp <- subset(seurat.tmp, stimulationFigures %in% c("IAR", "Microbial"))

# Extract UMAP to make dim red plots
umapCoords <- Embeddings(object = seurat.tmp, reduction = "ref.umap_DS")
umapCoords <- as.data.frame(umapCoords)
umapCoords <- cbind(umapCoords, seurat.tmp@meta.data) # add all metadata to the UMAP coordinates
# gDensityPlot <- ggplot(umapCoords)+
#   geom_point(aes(x=umap_1,
#                  y=umap_2,
#                  color = studyGroup)) +
#   scale_color_manual(values = studyGroupColors) +
#   geom_density2d(aes(x=umap_1,
#                      y=umap_2),
#                  color = "black",
#                  bins = 10) +
#   facet_wrap(~studyGroup)

# Calculate difference between 2D densities
# Based on https://stackoverflow.com/questions/28521145/r-calculate-and-plot-difference-between-two-density-countours
# Calculate the common x and y range
rangeFudgeFactor <- 0.5 # this number helps ensure that contours don't get cut off at the edges of the figure
umapIAR <- umapCoords %>%
  dplyr::filter(stimulationFigures == "IAR")
umapCEFX <- umapCoords %>%
  dplyr::filter(stimulationFigures == "Microbial")
xrng <- range(c(umapIAR$refumapds_1 - rangeFudgeFactor, umapCEFX$refumapds_1 + rangeFudgeFactor))
yrng <- range(c(umapIAR$refumapds_2 - rangeFudgeFactor, umapCEFX$refumapds_2 + rangeFudgeFactor))

# Set KDE bandwidth manually
kdeBandwidthIAR <- 0.5 # 1.25
kdeBandwidthMicrobial <- 1.25

# Calculate the 2d density estimate over the common range
densityIAR <- kde2d(umapIAR$refumapds_1, umapIAR$refumapds_2, h = kdeBandwidthIAR, lims = c(xrng, yrng), n = 200)
densityMicrobial <- kde2d(umapCEFX$refumapds_1, umapCEFX$refumapds_2, h = kdeBandwidthMicrobial, lims = c(xrng, yrng), n = 200)

# Confirm that the grid points for each density estimate are identical
identical(densityIAR$x, densityMicrobial$x) # TRUE
identical(densityIAR$y, densityMicrobial$y) # TRUE

# Calculate the difference between the 2d density estimates
diffDensity <- densityIAR # Get x and y coords
diffDensity$z <- densityMicrobial$z - densityIAR$z

## Melt data into long format
# First, add row and column names (x and y grid values) to the z-value matrix
rownames(diffDensity$z) <- diffDensity$x
colnames(diffDensity$z) <- diffDensity$y
diffDensity <- diffDensity$z %>% as.data.frame()
diffDensity$xcoord <- rownames(diffDensity)

# Now melt it to long format
diffLong <- diffDensity %>%
  pivot_longer(cols = setdiff(colnames(diffDensity), "xcoord"),
    names_to = "ycoord",
    values_to = "zcoord") %>%
  dplyr::mutate(xcoord = as.numeric(xcoord),
    ycoord = as.numeric(ycoord))
names(diffLong) <- c("umap_1", "umap_2", "z")

# calculate overall density and log-transform it
# Compute the overall 2D density (no grouping)
dens <- with(umapCoords, kde2d(refumapds_1, refumapds_2, n = 200))
# Apply a log transformation (adding a small constant to avoid log(0))
dens$z <- log10(dens$z + 1e-6)

# Melt the density matrix into a data frame for ggplot
dens_df <- expand.grid(x = dens$x, y = dens$y)
dens_df$z <- as.vector(dens$z)
```
```{r plot_density_diff}
# Plot difference between densities
gDiffDensity.tmp <- ggplot() +
  geom_tile(data = diffLong,
    aes(x = umap_1,
      y = umap_2,
      z = z,
      fill = z)) +
  geom_density2d(data = umapCoords,
    aes(x = refumapds_1,
      y = refumapds_2),
    color = "black",
    alpha = 0.5,
    contour_var = "ndensity",
    bins = 20) +

  # geom_point(data = umapCoords,
  #          aes(x = umap_1,
  #          y = umap_2),
  #          color = "black",
  #          alpha = 0.03) +
  # stat_contour(aes(x = umap_1,
  #            y = umap_2,
  #            z=z,
  #            fill=z,
  #            colour=..level..), binwidth=0.005) +
  scale_fill_gradient2(low = palStimulation["IAR"], mid = "white", high = palStimulation["Microbial"], midpoint = 0) +
  # scale_fill_gradient2(low = "blue", mid= "white", high = "orange", midpoint = 0) +
  labs(x = "UMAP 1",
    y = "UMAP 2",
    fill = "Microbial vs IAR\ndensity") +
  theme(aspect.ratio = 1)
# print(gDiffDensity.tmp)
png(file.path(plotDir, "IARCEFX_UMAP_DifferentialDensityWithContours.png"),
  height = 5.5,
  width = 8,
  units = "in",
  res = 600)
print(gDiffDensity.tmp)
invisible(dev.off())

# version with log-scaled density in the contour plot
gDiffDensity.tmp <- ggplot() +
  geom_tile(data = diffLong,
    aes(x = umap_1, y = umap_2, fill = z)) +
  geom_contour(data = dens_df,
    aes(x = x, y = y, z = z),
    color = "black", alpha = 0.7, bins = 10) +
  coord_fixed(ratio = 1) +
  scale_fill_gradient2(low = "skyblue", # palStimulation["IAR"],
    mid = "white",
    high = palStimulation["Microbial"],
    midpoint = 0) +
  labs(x = "UMAP 1",
    y = "UMAP 2",
    fill = "Microbial vs IAR\ndensity") +
  theme(aspect.ratio = 1)

png(file.path(plotDir, "IARCEFX_UMAP_DifferentialDensityWithContours.png"),
  height = 5.5,
  width = 8,
  units = "in",
  res = 600)
print(gDiffDensity.tmp)
invisible(dev.off())



pdf(file.path(plotDir, "Lymphocytes_UMAP_GenotypeDifferentialDensityWithCellDots.pdf"),
  height = 6,
  width = 8)
ggplot() +
  geom_tile(data = diffLong,
    aes(x = umap_1,
      y = umap_2,
      z = z,
      fill = z)) +
  # geom_density2d(data = umapCoords,
  #            aes(x = umap_1,
  #            y = umap_2),
  #            color = "black",
  #            bins = 10) +
  geom_point(data = umapCoords,
    aes(x = umap_1,
      y = umap_2),
    color = "black",
    alpha = 0.02) +
  # stat_contour(aes(x = umap_1,
  #            y = umap_2,
  #            z=z,
  #            fill=z,
  #            colour=..level..), binwidth=0.005) +
  scale_fill_gradient2(low = studyGroupColors["HC"], mid = "white", high = studyGroupColors["MAS"], midpoint = 0) +
  labs(x = "umap 1",
    y = "umap 2",
    fill = "MAS vs HC\ndensity") +
  theme(aspect.ratio = 1)
invisible(dev.off())
```

```{r showStimulationOnUMAP}

plot_umap_contours <- function(seurat_obj,
                               reduction = "ref.umap_DS",
                               grouping_col,       # e.g., "stimulationFigures" or "seurat_clusters"
                               clusters_col,       # e.g., "seurat_clusters_DS"
                               file_suffix,        # e.g., "UMAP_RNA_noDownsample_contours.pdf"
                               palette,
                               plot_title = NULL,
                               nBins = 10, # number of bins for the geom_density2d() call
                               width = 8,
                               height = 6) {
  # Extract UMAP coordinates from the specified reduction
  umap_data <- as.data.frame(Embeddings(seurat_obj, reduction = reduction))

  # Add the grouping variable for plotting and the clusters variable
  umap_data[[grouping_col]] <- seurat_obj@meta.data[[grouping_col]]
  umap_data[[clusters_col]] <- seurat_obj@meta.data[[clusters_col]]

  # Use the first two columns for x and y
  x_col <- colnames(umap_data)[1]
  y_col <- colnames(umap_data)[2]

  # Compute cluster string from the clusters column
  nClust <- length(unique(umap_data[[clusters_col]]))
  nClustString <- paste0("_", nClust, "Clusters")

  # Build the plot; using aes_string to allow dynamic variable names
  p <- ggplot(umap_data, aes_string(x = x_col, y = y_col)) +
    geom_density2d(aes_string(color = paste0("factor(", grouping_col, ")")),
      size = 1, bins = nBins, contour_var = "ndensity") +
    scale_color_manual(name = grouping_col, values = palette) +
    coord_fixed(ratio = 1) +
    theme_classic() +
    labs(x = x_col,
      y = y_col,
      title = plot_title)

  # Construct the full file name (here we assume plotDir and filenameSuffix exist in your workspace)
  full_file_name <- file.path(plotDir,
    paste0(filenameSuffix, nClustString, "_", file_suffix))

  # Save the plot to a PDF file
  pdf(file = full_file_name, width = width, height = height)
  print(p)
  dev.off()

  return(p)
}

plot_umap_contours_with_points <- function(seurat_obj,
                                           reduction = "ref.umap_DS",
                                           grouping_col,       # e.g., "stimulationFigures" or "seurat_clusters"
                                           clusters_col,       # e.g., "seurat_clusters_DS"
                                           file_suffix,        # e.g., "UMAP_RNA_noDownsample_contours.pdf"
                                           palette,
                                           plot_title = NULL,
                                           nBins = 10, # number of bins for the geom_density2d() call
                                           point_size = 0.5,  # Size of the points
                                           point_alpha = 0.5, # Transparency of the points
                                           width = 8,
                                           height = 6) {
  # Extract UMAP coordinates from the specified reduction
  umap_data <- as.data.frame(Embeddings(seurat_obj, reduction = reduction))

  # Add the grouping variable for plotting and the clusters variable
  umap_data[[grouping_col]] <- seurat_obj@meta.data[[grouping_col]]
  umap_data[[clusters_col]] <- seurat_obj@meta.data[[clusters_col]]

  # Use the first two columns for x and y
  x_col <- colnames(umap_data)[1]
  y_col <- colnames(umap_data)[2]

  # Compute cluster string from the clusters column
  nClust <- length(unique(umap_data[[clusters_col]]))
  nClustString <- paste0("_", nClust, "Clusters")

  # Build the plot; using aes_string to allow dynamic variable names
  p <- ggplot(umap_data, aes_string(x = x_col, y = y_col)) +
    # Add points first so contours will be drawn on top
    geom_point(aes_string(color = paste0("factor(", grouping_col, ")")),
      size = point_size, alpha = point_alpha) +
    # Then add the density contours
    geom_density2d(aes_string(color = paste0("factor(", grouping_col, ")")),
      size = 1, bins = nBins, contour_var = "ndensity") +
    scale_color_manual(name = grouping_col, values = palette) +
    coord_fixed(ratio = 1) +
    theme_classic() +
    labs(x = x_col,
      y = y_col,
      title = plot_title)

  # Construct the full file name (here we assume plotDir and filenameSuffix exist in your workspace)
  full_file_name <- file.path(plotDir,
    paste0(filenameSuffix, nClustString, "_", file_suffix))

  # Save the plot to a PDF file
  pdf(file = full_file_name, width = width, height = height)
  print(p)
  dev.off()

  return(p)
}

plot_umap_alphahulls_with_points <- function(seurat_obj,
                                             reduction = "umap",
                                             grouping_col = "seurat_clusters",
                                             clusters_col = "seurat_clusters",
                                             file_suffix = "_UMAP_with_alphahulls.pdf",
                                             plot_dir = NULL,
                                             filename_prefix = "",
                                             palette = NULL,
                                             plot_title = NULL,
                                             alpha = 0.7,
                                             point_size = 0.5,
                                             point_alpha = 0.5,
                                             hull_alpha = 0.7,
                                             hull_size = 1,
                                             width = 8,
                                             height = 6) {
  # Extract the UMAP coordinates
  umap_data <- as.data.frame(Seurat::Embeddings(seurat_obj, reduction = reduction))
  colnames(umap_data) <- c("UMAP_1", "UMAP_2")

  # Add cluster information
  umap_data[[grouping_col]] <- Seurat::Idents(seurat_obj)
  if (grouping_col %in% colnames(seurat_obj@meta.data)) {
    umap_data[[grouping_col]] <- seurat_obj@meta.data[[grouping_col]]
  }

  # For coloring by clusters
  umap_data[[clusters_col]] <- seurat_obj@meta.data[[clusters_col]]

  # Convert grouping column to factor if it's not already
  umap_data[[grouping_col]] <- as.factor(umap_data[[grouping_col]])

  # Generate a color palette if not provided
  if (is.null(palette)) {
    num_groups <- length(unique(umap_data[[grouping_col]]))
    palette <- scales::hue_pal()(num_groups)
  }

  # Initialize an empty list to store alpha hull data frames
  all_hulls_list <- list()

  # Process each group
  for (group in levels(umap_data[[grouping_col]])) {
    # Subset data for this group
    group_data <- umap_data[umap_data[[grouping_col]] == group, ]
    group_size <- nrow(group_data)

    # Print group info for debugging
    cat("Group", group, ":", group_size, "points\n")
    cat("Valid x range:", sprintf("[%.2f, %.2f]", min(group_data$UMAP_1), max(group_data$UMAP_1)),
      ", length:", length(group_data$UMAP_1), "\n")
    cat("Valid y range:", sprintf("[%.2f, %.2f]", min(group_data$UMAP_2), max(group_data$UMAP_2)),
      ", length:", length(group_data$UMAP_2), "\n")

    # Skip if too few points
    if (group_size < 5) {
      warning(paste("Group", group, "has fewer than 5 points. Skipping alpha hull calculation."))
      next
    }

    # Calculate alpha hull
    tryCatch(
      {
        # Create a matrix from the UMAP coordinates
        points <- cbind(group_data$UMAP_1, group_data$UMAP_2)

        # Calculate alpha hull
        hull <- alphahull::ashape(points, alpha = alpha)

        # Extract the edges of the alpha hull
        edges <- hull$edges

        # Create a data frame for the hull edges
        if (nrow(edges) > 0) {
          for (i in 1:nrow(edges)) {
            # Extract the two points that make up this edge
            x1 <- points[edges[i, 1], 1]
            y1 <- points[edges[i, 1], 2]
            x2 <- points[edges[i, 2], 1]
            y2 <- points[edges[i, 2], 2]

            # Create a data frame for this edge
            edge_df <- data.frame(
              UMAP_1 = c(x1, x2),
              UMAP_2 = c(y1, y2),
              group_id = group,
              edge_id = i  # Add a unique edge identifier
            )

            # Add to the list
            all_hulls_list[[length(all_hulls_list) + 1]] <- edge_df
          }
        }
      },
      error = function(e) {
        warning(paste("Error calculating alpha hull for group", group, ":", e$message))
      })
  }

  # Combine all hull edges into a single data frame
  if (length(all_hulls_list) > 0) {
    all_hulls <- do.call(rbind, all_hulls_list)
  } else {
    # Create an empty data frame if no hulls were calculated
    all_hulls <- data.frame(UMAP_1 = numeric(0), UMAP_2 = numeric(0),
      group_id = character(0), edge_id = numeric(0))
  }

  # Create the plot
  p <- ggplot2::ggplot(umap_data, ggplot2::aes(x = UMAP_1, y = UMAP_2)) +
    ggplot2::geom_point(ggplot2::aes(color = .data[[clusters_col]]),
      size = point_size, alpha = point_alpha) +
    ggplot2::theme_classic() +
    ggplot2::theme(legend.position = "right") +
    ggplot2::scale_color_manual(values = palette)

  # Add alpha hulls if any were calculated
  if (nrow(all_hulls) > 0) {
    p <- p + ggplot2::geom_path(
      data = all_hulls,
      ggplot2::aes(x = UMAP_1, y = UMAP_2, group = interaction(group_id, edge_id), color = factor(group_id)),
      linewidth = hull_size, alpha = hull_alpha
    )
  }

  # Add title if provided
  if (!is.null(plot_title)) {
    p <- p + ggplot2::ggtitle(plot_title)
  }

  # Save the plot if a directory is provided
  if (!is.null(plot_dir)) {
    if (!dir.exists(plot_dir)) {
      dir.create(plot_dir, recursive = TRUE)
    }

    filename <- file.path(plot_dir, paste0(filename_prefix, file_suffix))
    ggplot2::ggsave(filename, plot = p, width = width, height = height)
  }

  return(p)
}

plot_umap_alphahulls_with_points(seurat_obj = seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  grouping_col = "seurat_clusters_DS",       # e.g., "stimulationFigures" or "seurat_clusters"
  clusters_col = "seurat_clusters_DS",       # e.g., "seurat_clusters_DS"
  file_suffix = "UMAP_RNAClustersWithAlphaHullsTrial.pdf",        # e.g., "UMAP_RNA_noDownsample_alphahulls.pdf"
  plot_dir = plotDir, # Directory to save plots
  filename_prefix = filenameSuffix, # Prefix for the filename
  palette = palRNAClusters,
  plot_title = NULL,
  alpha = 0.2,        # Alpha value for alphahull calculation
  point_size = 0.5,   # Size of the points
  point_alpha = 0.5,  # Transparency of the points
  hull_alpha = 0.9,   # Alpha transparency for the hull lines
  hull_size = 1,      # Size/thickness of the hull lines
  width = 8,
  height = 6)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_DS_stimulationLabel.pdf")),
height = 6,
width = 12)

seurat.tmp <- subset(seuratQCMergedCleanedDS, cellType %in% c("Treg", "Tconv"))

DimPlot(object = seurat.tmp,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "umap",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters",
  file_suffix = "UMAP_RNA_Downsample_Stimulationcontours.pdf",
  palette = palStimulation,
  plot_title = "UMAP Density Contours by Stimulation",
  nBins = 7,
  width = 8,
  height = 6)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_DS_UMAP_RNA_AllCellsStimulationLabel.pdf")),
height = 5.5,
width = 8)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters_DS",
  file_suffix = "UMAP_RNA_allCells_Stimulationcontours.pdf",
  palette = palStimulation,
  plot_title = "UMAP Density Contours by Stimulation",
  nBins = 7,
  width = 8,
  height = 6)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_DS_UMAP_RNA_TregTconvStimulationLabel.pdf")),
height = 6,
width = 8)

seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_DS",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "ref.umap_DS",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters_DS",
  file_suffix = "UMAP_RNA_noDownsample_Stimulationcontours.pdf",
  palette = palStimulation,
  plot_title = "UMAP Density Contours by Stimulation",
  nBins = 7,
  width = 8,
  height = 6)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel_facet.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "stimulation",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulation)

dev.off()
```

```{r showIARandCEFXOnUMAPs}
# non-downsampled, treg+tconv clusters
seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures %in% c("Microbial", "IAR"))
seurat.tmp <- subset(seurat.tmp, cellType %in% c("Treg", "Tconv"))

set.seed(314) # for reproducibility of the point shuffling in DimPlot()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_DS_UMAP_RNA_AllCEFXIARStimulationLabel.pdf")),
height = 6,
width = 8)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_DS",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "ref.umap_DS",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters_DS",
  file_suffix = "UMAP_RNA_noDownsample_IARCEFXStimulationcontours.pdf",
  palette = palStimulation,
  plot_title = "UMAP Density Contours by Stimulation",
  nBins = 15,
  width = 8,
  height = 6)

# downsampled, treg + tconv clusters
seurat.tmp <- subset(seuratQCMergedCleanedDS, stimulationFigures %in% c("Microbial", "IAR"))
seurat.tmp <- subset(seurat.tmp, cellType %in% c("Treg", "Tconv"))

set.seed(314) # for reproducibility of the point shuffling in DimPlot()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_DS_UMAP_RNA_DSCEFXIARStimulationLabel.pdf")),
height = 6,
width = 8)

DimPlot(object = seurat.tmp,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "umap",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters",
  file_suffix = "UMAP_RNA_Downsample_IARCEFXStimulationcontours.pdf",
  palette = palStimulation,
  plot_title = "UMAP Density Contours by Stimulation",
  nBins = 10,
  width = 8,
  height = 6)

# non-downsampled, treg clusters
seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures %in% c("Microbial", "IAR"))
seurat.tmp <- subset(seurat.tmp, cellType == "Treg")

set.seed(314) # for reproducibility of the point shuffling in DimPlot()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Treg_UMAP_RNA_AllCEFXIARStimulationLabel.pdf")),
height = 6,
width = 8)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_Treg",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "ref.umap_Treg",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters_Treg",
  file_suffix = "UMAP_RNA_noDownsample_IARCEFXStimulationcontours_Tregs.pdf",
  palette = palStimulation,
  plot_title = "Treg UMAP Density Contours by Stimulation",
  nBins = 10,
  width = 8,
  height = 6)

# downsampled, treg clusters
seurat.tmp <- subset(seuratTreg, stimulationFigures %in% c("Microbial", "IAR"))

set.seed(314) # for reproducibility of the point shuffling in DimPlot()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Treg_UMAP_RNA_DSCEFXIARStimulationLabel.pdf")),
height = 6,
width = 8)

DimPlot(object = seurat.tmp,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "umap",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters",
  file_suffix = "UMAP_RNA_Downsample_IARCEFXStimulationcontours_Tregs.pdf",
  palette = palStimulation,
  plot_title = "Treg UMAP Density Contours by Stimulation",
  nBins = 10,
  width = 8,
  height = 6)

# non-downsampled, tconv clusters
seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures %in% c("Microbial", "IAR"))
seurat.tmp <- subset(seurat.tmp, cellType == "Tconv")

set.seed(314) # for reproducibility of the point shuffling in DimPlot()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Tconv_UMAP_RNA_AllCEFXIARStimulationLabel.pdf")),
height = 6,
width = 8)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_Tconv",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "ref.umap_Tconv",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters_Tconv",
  file_suffix = "UMAP_RNA_noDownsample_IARCEFXStimulationcontours_Tconvs.pdf",
  palette = palStimulation,
  plot_title = "Tconv UMAP Density Contours by Stimulation",
  nBins = 10,
  width = 8,
  height = 6)

# downsampled, tconv clusters
seurat.tmp <- subset(seuratTconv, stimulationFigures %in% c("Microbial", "IAR"))

set.seed(314) # for reproducibility of the point shuffling in DimPlot()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Tconv_UMAP_RNA_DSCEFXIARStimulationLabel.pdf")),
height = 6,
width = 8)

DimPlot(object = seurat.tmp,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1,
  shuffle = TRUE) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

plot_umap_contours(seurat_obj = seurat.tmp,
  reduction = "umap",
  grouping_col = "stimulationFigures",
  clusters_col = "seurat_clusters",
  file_suffix = "UMAP_RNA_Downsample_IARCEFXStimulationcontours_Tconvs.pdf",
  palette = palStimulation,
  plot_title = "Tconv UMAP Density Contours by Stimulation",
  nBins = 10,
  width = 8,
  height = 6)


rm_tmp(ask = FALSE)
gc()
```

```{r showStimulationOnUMAPTregOnlyTconvOnly}
# non-downsampled, treg clusters
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

# Extract UMAP coordinates
umap.df.tmp <- as.data.frame(Embeddings(seurat.tmp, "ref.umap_Treg"))
umap.df.tmp$cell <- rownames(umap.df.tmp)
umap.df.tmp$stimulationFigures <- seurat.tmp$stimulationFigures[umap.df.tmp$cell]

# Set the factor levels (just to be sure)
umap.df.tmp$stimulationFigures <- factor(
  umap.df.tmp$stimulationFigures,
  levels = c("Microbial", "Polyclonal", "IAR")
)

# Reorder the data frame so "Microbial" is first, then "Polyclonal", then "IAR"
umap.df.tmp <- umap.df.tmp %>%
  arrange(stimulationFigures)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Treg_UMAP_RNA_AllStimulationLabel.pdf")),
height = 6,
width = 8
)

ggplot(umap.df.tmp, aes(x = refumaptreg_1, y = refumaptreg_2, color = stimulationFigures)) +
  geom_point(size = 1, alpha = 1) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) +
  guides(color = guide_legend(override.aes = list(size = 4)))

dev.off()

# non-downsampled, tconv clusters
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

# Extract UMAP coordinates
umap.df.tmp <- as.data.frame(Embeddings(seurat.tmp, "ref.umap_Tconv"))
umap.df.tmp$cell <- rownames(umap.df.tmp)
umap.df.tmp$stimulationFigures <- seurat.tmp$stimulationFigures[umap.df.tmp$cell]

# Set the factor levels (just to be sure)
umap.df.tmp$stimulationFigures <- factor(
  umap.df.tmp$stimulationFigures,
  levels = c("Microbial", "Polyclonal", "IAR")
)

# Reorder the data frame so "Microbial" is first, then "Polyclonal", then "IAR"
umap.df.tmp <- umap.df.tmp %>%
  arrange(stimulationFigures)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Tconv_UMAP_RNA_AllStimulationLabel.pdf")),
height = 6,
width = 8
)

ggplot(umap.df.tmp, aes(x = refumaptconv_1, y = refumaptconv_2, color = stimulationFigures)) +
  geom_point(size = 1, alpha = 1) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
  scale_color_manual(values = palStimulation) +
  theme(aspect.ratio = 1) +
  guides(color = guide_legend(override.aes = list(size = 4)))

dev.off()

rm_tmp(ask = FALSE)
gc()
```

```{r showStimulationOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel_facetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel_facetDS_poster.pdf")),
height = 6,
width = )

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r showPoolOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_poolLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "pool",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Pool", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_poolLabel_facetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "pool",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Pool", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~pool)

dev.off()
```

```{r CITEseqMarkerScatterPlots}

# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))
sanitized_markers <- make.names(markers)

# Ensure the data frame and metadata are aligned
data <- data[rownames(filtered_meta_data), ]
data$stimulation <- filtered_meta_data$stimulation

# TODO move this filtering up higher to where we actually do the doublet filtering!!!!!!

# Function to create scatterplots for a given marker against all other markers
create_scatterplots <- function(marker, data, sanitized_markers) {
  plots <- list()
  other_markers <- setdiff(sanitized_markers, marker)

  for (other_marker in other_markers) {
    p <- ggplot(data, aes(x = !!sym(marker), y = !!sym(other_marker))) +
      geom_pointdensity(alpha = 0.5) +
      scale_color_viridis_c() +
      labs(title = paste(marker, "vs", other_marker), x = marker, y = other_marker) +
      theme_minimal()
    plots[[other_marker]] <- p
  }

  return(plots)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulation)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulation == stimulation, ]

  # Create and save scatterplot grids for each marker
  for (i in seq_along(sanitized_markers)) {
    sanitized_marker <- sanitized_markers[i]
    original_marker <- markers[i]
    scatterplots <- create_scatterplots(sanitized_marker, data_filtered, sanitized_markers)
    grid <- marrangeGrob(scatterplots, nrow = 3, ncol = 3, top = paste(original_marker, "-", stimulation))

    # Save the grid to a file
    png(file.path(plotDir,
      paste0(filenameSuffix, sanitized_marker, "_", stimulation, "_scatterplots.png")),
    height = 6,
    width = 12,
    units = "in",
    res = 600)

    print(grid)

    dev.off()
  }
}
```

```{r CITEseqMarkerScatterPlotsStimulationSplit}
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))
sanitized_markers <- make.names(markers)

# Add stimulation information to the data
data$stimulation <- seuratQCMergedCleanedDS@meta.data$stimulation

# Function to create scatterplots for a given marker against all other markers
create_scatterplots <- function(marker, data, sanitized_markers) {
  plots <- list()
  other_markers <- setdiff(sanitized_markers, marker)

  for (other_marker in other_markers) {
    p <- ggplot(data, aes(x = !!sym(marker), y = !!sym(other_marker))) +
      geom_pointdensity(alpha = 0.5) +
      scale_color_viridis_c() +
      labs(title = paste(marker, "vs", other_marker), x = marker, y = other_marker) +
      theme_minimal()
    plots[[other_marker]] <- p
  }

  return(plots)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulation)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulation == stimulation, ]

  # Create and save scatterplot grids for each marker
  for (i in seq_along(sanitized_markers)) {
    sanitized_marker <- sanitized_markers[i]
    original_marker <- markers[i]
    scatterplots <- create_scatterplots(sanitized_marker, data_filtered, sanitized_markers)
    grid <- marrangeGrob(scatterplots, nrow = 3, ncol = 3, top = paste(original_marker, "-", stimulation))

    # Save the grid to a file
    png(file.path(plotDir,
      paste0(filenameSuffix, sanitized_marker, "_", stimulation, "_scatterplots.png")),
    height = 6,
    width = 12,
    units = "in",
    res = 600)

    print(grid)

    dev.off()
  }
}
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_logNorm_noDownsample_densityPlot}
# manuscript figure 4 B
# set plot sizes
plotHeight <- 2
plotWidth <- 4
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleaned@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleaned@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleaned@meta.data$stimulationFigures

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation, xminTreg, xmaxTreg, yminTreg, ymaxTreg, xminTconv, xmaxTconv, yminTconv, ymaxTconv) {
  # Add jitter to the data
  set.seed(6022)
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "Density") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()) +
    ylim(-0.25, 8) +
    xlim(-0.25, 9) +
    annotate("rect", xmin = xminTreg, xmax = xmaxTreg, ymin = yminTreg, ymax = ymaxTreg,
      alpha = 1, fill = NA, color = "blue") +
    annotate("rect", xmin = xminTconv, xmax = xmaxTconv, ymin = yminTconv, ymax = ymaxTconv,
      alpha = 1, fill = NA, color = "red")
  return(p)
}

# set gate cutoffs
gate_cutoffs <- list(
  "Microbial" = list(xminTreg = 2.5, xmaxTreg = Inf, yminTreg = -0.25, ymaxTreg = 4, xminTconv = 7.5, xmaxTconv = Inf, yminTconv = 4.5, ymaxTconv = Inf),
  "IAR" = list(xminTreg = 2.5, xmaxTreg = Inf, yminTreg = -0.25, ymaxTreg = 4, xminTconv = 7.5, xmaxTconv = Inf, yminTconv = 4.5, ymaxTconv = Inf),
  "Polyclonal" = list(xminTreg = 2.5, xmaxTreg = Inf, yminTreg = -0.25, ymaxTreg = 4, xminTconv = 7.5, xmaxTconv = Inf, yminTconv = 4.5, ymaxTconv = Inf)
)

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Get the gate cutoffs for the current stimulation
  cutoffs <- gate_cutoffs[[stimulation]]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation,
    cutoffs$xminTreg, cutoffs$xmaxTreg, cutoffs$yminTreg, cutoffs$ymaxTreg,
    cutoffs$xminTconv, cutoffs$xmaxTconv, cutoffs$yminTconv, cutoffs$ymaxTconv)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "density_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()

  pdf(paste0(plotDir, "/", filenameSuffix, "CD69_CD154_", stimulation, "density_scatterplot_logNorm.pdf"),
    height = plotHeight,
    width = plotWidth)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleaned@meta.data$HT_names

set.seed(6022)
# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria (step 1/3 for Tregs)
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Apply gating to find Tconvs (step 1/1 for Tconvs)
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.5, ]
cellsTconv  <- cellsTconv$HT_names

set.seed(6022)
# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()

  pdf(paste0(plotDir, "/", filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_logNorm.pdf"),
    height = plotHeight,
    width = plotWidth)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
set.seed(6022)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD127, amount = 0.2)
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]
# gated_data_2 <- gated_data[is_inside_ellipse(data$CD25_jittered, data$CD137_jittered, center_x, center_y, width, height, angle), ]


# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTreg") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()

  pdf(paste0(plotDir, "/", filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_logNorm.pdf"),
    height = plotHeight,
    width = plotWidth)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_logNorm.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()

  pdf(paste0(plotDir, "/", filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_logNorm.pdf"),
    height = plotHeight,
    width = plotWidth)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```


```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_showRNAClusters_logNorm}
# # set plot sizes
# plotHeight <- 5
# plotWidth <- 6
# # Extract the data for the markers
# markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
# data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# # Sanitize column names
# colnames(data) <- make.names(colnames(data))

# sanitized_markers <- make.names(markers)
# # c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# # Add stimulation information to the data
# data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# # Add RNA clusters to the dataframe
# data$cluster <- seuratQCMergedCleanedDS@meta.data$seurat_clusters

# # Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
# create_scatterplot_CD154_CD69 <- function(data, stimulation) {
#   # Add jitter to the data
#   data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
#   data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

#   # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
#   #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
#   #     alpha = 0.2, fill = "blue", color = "blue") +
#   #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
#   #     alpha = 0.2, fill = "red", color = "red") +
#   #   geom_pointdensity(alpha = 0.5) +
#   #   scale_color_viridis_c() +
#   #   labs(title = stimulation, x = "CD69", y = "CD154") +
#   #   theme_minimal() +
#   #   theme(legend.position = "none")
#   p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = cluster)) +
#     annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
#       alpha = 0.2, fill = NA, color = "blue") +
#     annotate("rect", xmin = 7.5, xmax = Inf, ymin = 5, ymax = Inf,
#       alpha = 0.2, fill = NA, color = "red") +
#     geom_point(alpha = 0.5) +
#     scale_color_manual(values = palRNAClusters) +
#     labs(title = stimulation, x = "CD69", y = "CD154", color = "cluster") +
#     theme_minimal() +
#     theme(legend.position = "none", # "bottom",
#       panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank())
#   return(p)
# }

# # Loop over each unique stimulation
# for (stimulation in unique(data$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- data[data$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD154 vs CD69
#   scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD69_CD154_", stimulation, "RNAcluster_scatterplot_logNorm.png")),
#   height = plotHeight,
#   width = plotWidth,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }

# # Add HT_names to the data
# data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# # Add jitter to the data
# data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
# data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# # Apply gating criteria
# gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# # Add jitter to the data
# gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
# gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# # Apply gating to find Tconvs
# cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 5, ]
# cellsTconv  <- cellsTconv$HT_names

# # Extract the HT_names for the filtered cells
# HT_names_filtered <- gated_data$HT_names

# # Print the filtered HT_names
# print(HT_names_filtered)

# # Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
# create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
#   # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
#   #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
#   #     alpha = 0.2, fill = "blue", color = "blue") +
#   #   geom_pointdensity(alpha = 0.5) +
#   #   scale_color_viridis_c() +
#   #   labs(title = stimulation, x = "CD25", y = "CD137") +
#   #   theme_minimal() +
#   #   theme(legend.position = "none")
#   # return(p)

#   p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = cluster)) +
#     annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
#       alpha = 0.2, fill = NA, color = "blue") +
#     geom_point(alpha = 0.5) +
#     scale_color_manual(values = palRNAClusters) +
#     labs(title = stimulation, x = "CD25", y = "CD137", color = "cluster") +
#     theme_minimal() +
#     theme(legend.position = "none", # "bottom",
#       panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank())
#   return(p)

# }

# # Loop over each unique stimulation
# for (stimulation in unique(gated_data$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD154 vs CD69
#   scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD137_CD25_", stimulation, "RNAcluster_scatterplot_logNorm.png")),
#   height = plotHeight,
#   width = plotWidth,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }


# # Apply gating criteria CD25/CD137
# gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

# gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# # Function to create a scatterplot for CD127 and CD25 with jittered points and point density
# create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
#   # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
#   #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
#   #     alpha = 0.2, fill = "blue", color = "blue") +
#   #   geom_pointdensity(alpha = 0.5) +
#   #   scale_color_viridis_c() +
#   #   labs(title = stimulation, x = "CD25", y = "CD127") +
#   #   xlim(0, 10) +
#   #   ylim(0, 8) +
#   #   theme_minimal() +
#   #   theme(legend.position = "none")
#   # return(p)

#   p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = cluster)) +
#     annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
#       alpha = 0.2, fill = NA, color = "blue") +
#     geom_point(alpha = 0.5) +
#     scale_color_manual(values = palRNAClusters) +
#     labs(title = stimulation, x = "CD25", y = "CD127", color = "cluster") +
#     xlim(0, 10) +
#     ylim(0, 8) +
#     theme_minimal() +
#     theme(legend.position = "none", # "bottom",
#       panel.grid.major = element_blank(),
#       panel.grid.minor = element_blank())
#   return(p)


# }

# # Loop over each unique stimulation
# for (stimulation in unique(gated_data_2$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD127 vs CD25
#   scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD127_CD25_", stimulation, "RNAcluster_scatterplot_logNorm.png")),
#   height = plotHeight,
#   width = plotWidth,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }


# # Function to create a scatterplot for CD127 and CD25--ungated
# create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


#   p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127, color = cluster)) +
#     geom_pointdensity(alpha = 0.5) +
#     scale_color_manual(values = palRNAClusters) +
#     labs(title = stimulation, x = "CD25", y = "CD127") +
#     xlim(0, 10) +
#     ylim(0, 8) +
#     theme_minimal()
#   return(p)
# }

# # Loop over each unique stimulation
# for (stimulation in unique(data$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- data[data$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD127 vs CD25
#   scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_RNACluster_logNorm.png")),
#   height = 3,
#   width = 12,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }

# # Apply gating criteria CD25/CD127
# gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

# cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_cellTypist}
# # Extract the data for the markers
# markers <- rownames(seuratQCMergedCleaned@assays$FB@data)
# data <- as.data.frame(t(seuratQCMergedCleaned@assays$FB@data[markers, ]))

# # Sanitize column names
# colnames(data) <- make.names(colnames(data))

# sanitized_markers <- make.names(markers)
# # c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# # Add stimulation information to the data
# data$stimulationFigures <- seuratQCMergedCleaned@meta.data$stimulationFigures

# # Add meanExpressionTreg to the data
# data$meanExpressionTreg <- seuratQCMergedCleaned@meta.data$meanExpressionTreg

# # Add cellTypistCalling to the data
# data$cellTypistCalling <- seuratQCMergedCleaned@meta.data$cellTypistCalling

# # Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
# create_scatterplot_CD154_CD69 <- function(data, stimulation) {
#   # Add jitter to the data
#   data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
#   data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

#   # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
#   #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
#   #     alpha = 0.2, fill = "blue", color = "blue") +
#   #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
#   #     alpha = 0.2, fill = "red", color = "red") +
#   #   geom_pointdensity(alpha = 0.5) +
#   #   scale_color_viridis_c() +
#   #   labs(title = stimulation, x = "CD69", y = "CD154") +
#   #   theme_minimal() +
#   #   theme(legend.position = "none")
#   p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = cellTypistCalling)) +
#     annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
#       alpha = 0.2, fill = NA, color = "blue") +
#     annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
#       alpha = 0.2, fill = NA, color = "red") +
#     geom_point(alpha = 0.5) +
#     scale_color_manual(values = palCellTypist) +
#     labs(title = stimulation, x = "CD69", y = "CD154", color = "cellTypistCalling") +
#     theme_minimal() +
#     theme(legend.position = "bottom") +
#     guides(color = guide_legend(nrow = 2))
#   return(p)
# }

# # Loop over each unique stimulation
# for (stimulation in unique(data$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- data[data$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD154 vs CD69
#   scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD69_CD154_", stimulation, "_cellTypist_scatterplot.png")),
#   height = 5,
#   width = 6,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }

# # Add HT_names to the data
# data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# # Add jitter to the data
# data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
# data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# # Apply gating criteria
# gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# # Add jitter to the data
# gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
# gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# # Apply gating to find Tconvs
# cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
# cellsTconv  <- cellsTconv$HT_names

# # Extract the HT_names for the filtered cells
# HT_names_filtered <- gated_data$HT_names

# # Print the filtered HT_names
# print(HT_names_filtered)

# # Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
# create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
#   # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
#   #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
#   #     alpha = 0.2, fill = "blue", color = "blue") +
#   #   geom_pointdensity(alpha = 0.5) +
#   #   scale_color_viridis_c() +
#   #   labs(title = stimulation, x = "CD25", y = "CD137") +
#   #   theme_minimal() +
#   #   theme(legend.position = "none")
#   # return(p)

#   p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = cellTypistCalling)) +
#     annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
#       alpha = 0.2, fill = NA, color = "blue") +
#     geom_point(alpha = 0.5) +
#     scale_color_manual(values = palCellTypist) +
#     labs(title = stimulation, x = "CD25", y = "CD137", color = "cellTypistCalling") +
#     theme_minimal() +
#     theme(legend.position = "bottom") +
#     guides(color = guide_legend(nrow = 2))
#   return(p)

# }

# # Loop over each unique stimulation
# for (stimulation in unique(gated_data$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD154 vs CD69
#   scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD137_CD25_", stimulation, "_cellTypist_scatterplot.png")),
#   height = 4,
#   width = 4,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }


# # Apply gating criteria CD25/CD137
# gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

# gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# # Function to create a scatterplot for CD127 and CD25 with jittered points and point density
# create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
#   # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
#   #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
#   #     alpha = 0.2, fill = "blue", color = "blue") +
#   #   geom_pointdensity(alpha = 0.5) +
#   #   scale_color_viridis_c() +
#   #   labs(title = stimulation, x = "CD25", y = "CD127") +
#   #   xlim(0, 10) +
#   #   ylim(0, 8) +
#   #   theme_minimal() +
#   #   theme(legend.position = "none")
#   # return(p)

#   p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = cellTypistCalling)) +
#     annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
#       alpha = 0.2, fill = NA, color = "blue") +
#     geom_point(alpha = 0.5) +
#     scale_color_manual(values = palCellTypist) +
#     labs(title = stimulation, x = "CD25", y = "CD127", color = "cellTypistCalling") +
#     xlim(0, 10) +
#     ylim(0, 8) +
#     theme_minimal() +
#     theme(legend.position = "bottom") +
#     guides(color = guide_legend(nrow = 2))
#   return(p)


# }

# # Loop over each unique stimulation
# for (stimulation in unique(gated_data_2$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD127 vs CD25
#   scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD127_CD25_", stimulation, "_cellTypist_scatterplot.png")),
#   height = 4,
#   width = 4,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }


# # Function to create a scatterplot for CD127 and CD25--ungated
# create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {

#   p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127, color = cellTypistCalling)) +
#     geom_pointdensity(alpha = 0.5) +
#     scale_color_manual(values = palCellTypist) +
#     labs(title = stimulation, x = "CD25", y = "CD127") +
#     xlim(0, 10) +
#     ylim(0, 8) +
#     theme_minimal()
#   return(p)
# }

# # Loop over each unique stimulation
# for (stimulation in unique(data$stimulationFigures)) {
#   # Filter data for the current stimulation
#   data_filtered <- data[data$stimulationFigures == stimulation, ]

#   # Create the scatterplot for CD127 vs CD25
#   scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

#   # Save the scatterplot to a file
#   png(file.path(plotDir,
#     paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_cellTypist.png")),
#   height = 3,
#   width = 12,
#   units = "in",
#   res = 600)

#   print(scatterplot)

#   dev.off()
# }

# # Apply gating criteria CD25/CD127
# gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

# cellsTreg <- gated_data_3$HT_names
```

```{r AgSpecificCellsPerStimLogNorm}
# Extract the relevant metadata for cellsTreg and cellsTconv
metaData.df.tmp <- seuratQCMergedCleaned@meta.data

# Filter metadata for cellsTreg and cellsTconv
metaDataTreg.df.tmp <- metaData.df.tmp %>% filter(barcode %in% cellsTreg)
metaDataTconv.df.tmp <- metaData.df.tmp %>% filter(barcode %in% cellsTconv)

# Create contingency tables
table_treg <- metaDataTreg.df.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(count = n()) %>%
  spread(stimulationFigures, count, fill = 0) %>%
  mutate(cellType = "Treg")

table_tconv <- metaDataTconv.df.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(count = n()) %>%
  spread(stimulationFigures, count, fill = 0) %>%
  mutate(cellType = "Tconv")

# Combine the tables into a single data frame
combined_table <- bind_rows(table_treg, table_tconv)

# Print the combined table
print(combined_table)

# Define the output file path
output_file <- file.path(dataOutputDir, "totalSeqTregTconvCountsPerDonorStimulationNoDownsample.xlsx")

# Save the combined_table to an Excel file
write.xlsx(combined_table, output_file)

rm_tmp(ask = FALSE)
```

```{r addTotalSeqCellTypesToSeurat}
# Set default cell type to "Other"
seuratQCMergedCleanedDS$cellType <- "Other"

# Set cell type for Tregs
seuratQCMergedCleanedDS$cellType[
  seuratQCMergedCleanedDS$HT_names %in% cellsTreg &
    seuratQCMergedCleanedDS$seurat_clusters %in% c(3, 4)
] <- "Treg"

# Set cell type for Tconvs
seuratQCMergedCleanedDS$cellType[
  seuratQCMergedCleanedDS$HT_names %in% cellsTconv &
    seuratQCMergedCleanedDS$seurat_clusters %in% c(0, 1, 2, 5, 6)
] <- "Tconv"
```

```{r referenceMapNonDSCells}
# Ensure both datasets are normalized and have the same set of features
seuratQCMergedCleaned <- NormalizeData(seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "RNA")
seuratQCMergedCleanedDS <- NormalizeData(seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "RNA")

# Find variable features for both datasets
seuratQCMergedCleaned <- FindVariableFeatures(seuratQCMergedCleaned,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)
seuratQCMergedCleanedDS <- FindVariableFeatures(seuratQCMergedCleanedDS,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

# Find the intersection of variable features
featuresShared <- intersect(VariableFeatures(seuratQCMergedCleaned), VariableFeatures(seuratQCMergedCleanedDS))

# Find transfer anchors
anchors <- FindTransferAnchors(reference = seuratQCMergedCleanedDS, query = seuratQCMergedCleaned, features = featuresShared, reference.reduction = "pca")

# Transfer cluster labels
predictions <- TransferData(anchorset = anchors, refdata = seuratQCMergedCleanedDS$seurat_clusters, dims = 1:30)

# Rename the predicted cluster labels to seurat_clusters_DS
colnames(predictions) <- gsub("predicted.id", "seurat_clusters_DS", colnames(predictions))

# Add the predicted cluster labels to the metadata of seuratQCMergedCleaned
seuratQCMergedCleaned <- Seurat::AddMetaData(seuratQCMergedCleaned, metadata = predictions)

# Project UMAP embeddings from seuratQCMergedCleanedDS onto seuratQCMergedCleaned
# NOTE: the reference RunUMAP() call has to include "return.model = TRUE"
seuratQCMergedCleaned <- MapQuery(
  anchorset = anchors,
  reference = seuratQCMergedCleanedDS,
  query = seuratQCMergedCleaned,
  # refdata = list(UMAP = Embeddings(seuratQCMergedCleanedDS, "umap")),
  reference.reduction = "pca",
  reduction.model = "umap"
)

# Copy the first projection to a new slot
seuratQCMergedCleaned[["ref.umap_DS"]] <- seuratQCMergedCleaned[["ref.umap"]]

# Plot the UMAP embeddings
umap.trial.tmp <- DimPlot(seuratQCMergedCleaned,
  reduction = "ref.umap_DS",
  group.by = "seurat_clusters_DS",
  cols = palRNAClusters)

# Save the scatterplot to a file
png(file.path(plotDir,
  paste0(filenameSuffix, "CEFX_projectedOnDSUMAP.png")),
height = 7,
width = 8,
units = "in",
res = 600)

print(umap.trial.tmp)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "CEFX_projectedOnDSUMAP.pdf")),
height = 7,
width = 8)

print(umap.trial.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r addCellTypeToFullSeurat}
# uses the TotalSeq gating in concert with inferred seurat_cluster identity from chunk "referenceMapNonDSCells"
# Add a new metadata column for cell type
seuratQCMergedCleaned$cellType <- "Other"

# Set cell type for Tregs
seuratQCMergedCleaned$cellType[
  seuratQCMergedCleaned$HT_names %in% cellsTreg &
    seuratQCMergedCleaned$seurat_clusters_DS %in% c(3, 4)
] <- "Treg"

# Set cell type for Tconvs
seuratQCMergedCleaned$cellType[
  seuratQCMergedCleaned$HT_names %in% cellsTconv &
    seuratQCMergedCleaned$seurat_clusters_DS %in% c(0, 1, 2, 5, 6)
] <- "Tconv"

# also add the gating results on their own
seuratQCMergedCleaned$cellTypeTotalSeq <- "Other"

# Set TotalSeq gating result for Tregs
seuratQCMergedCleaned$cellTypeTotalSeq[
  seuratQCMergedCleaned$HT_names %in% cellsTreg
] <- "Treg"

# Set TotalSeq gating result for Tconvs
seuratQCMergedCleaned$cellTypeTotalSeq[
  seuratQCMergedCleaned$HT_names %in% cellsTconv
] <- "Tconv"
```

```{r addCellTypeTocleanTCRs.df}
# Use the rownames as barcode identifiers
metadataSubset.tmp <- seuratQCMergedCleaned@meta.data
metadataSubset.tmp$barcode <- rownames(metadataSubset.tmp)

# Merge cleanTCRs.df with this updated metadata subset using the "barcode" column
cleanTCRs.df <- merge(cleanTCRs.df, metadataSubset.tmp[, c("barcode", "cellType", "donorIdFigures", "pool", "stimulationFigures")],
  by = "barcode", all.x = TRUE)

cleanTCRs.df$pool <- as.character(cleanTCRs.df$pool)

rm_tmp(ask = FALSE)
```

```{r RNAClusterStimulationOccupancyStatistics}
# Use the subset of Treg/Tconv cells and pull metadata
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure appropriate columns are factors
metadata.tmp$seurat_clusters_DS <- as.factor(metadata.tmp$seurat_clusters_DS)
metadata.tmp$stimulationFigures <- as.factor(metadata.tmp$stimulationFigures)
metadata.tmp$donorIdFigures <- as.factor(metadata.tmp$donorIdFigures)

# 1. Compute cell counts per donor, RNA cluster, and stimulation condition
cluster_counts <- metadata.tmp %>%
  group_by(donorIdFigures, seurat_clusters_DS, stimulationFigures) %>%
  summarize(cell_count = n(), .groups = "drop")

# 2. Compute total cells per donor and RNA cluster (ignoring stimulation)
total_cells_per_cluster <- metadata.tmp %>%
  group_by(donorIdFigures, seurat_clusters_DS) %>%
  summarize(total = n(), .groups = "drop")

# 3. Merge and compute within-cluster (per donor) proportions of each stimulation
prop_df <- left_join(cluster_counts, total_cells_per_cluster,
  by = c("donorIdFigures", "seurat_clusters_DS")) %>%
  mutate(occupancy = cell_count / total)

# For each cluster, test for differences in occupancy among stimulation groups
p_list <- lapply(unique(prop_df$seurat_clusters_DS), function(cl) {
  df_cl <- prop_df %>% filter(seurat_clusters_DS == cl)
  stim_groups <- unique(df_cl$stimulationFigures)
  # Only test if there is more than one stimulation group in this cluster
  if (length(stim_groups) > 1) {
    if (length(stim_groups) == 2) {
      test <- t.test(occupancy ~ stimulationFigures, data = df_cl)
      p_val <- test$p.value
    } else {
      model <- aov(occupancy ~ stimulationFigures, data = df_cl)
      p_val <- summary(model)[[1]][["Pr(>F)"]][1]
    }
    data.frame(seurat_clusters_DS = cl, raw_p = p_val)
  } else {
    data.frame(seurat_clusters_DS = cl, raw_p = NA)
  }
})

# Combine test results and adjust p-values using the BY ("Benjamini-Yekutieli") method
p_df <- do.call(rbind, p_list) %>%
  mutate(adj_p = p.adjust(raw_p, method = "BY"),
    label = paste("p_adj =", signif(adj_p, 3)))

print(p_df)

# 4. Plot boxplots (with jitter) where:
#    - x-axis: RNA cluster (seurat_clusters_DS)
#    - Each facet (row) is one stimulation
occupancy_plot <- ggplot(prop_df, aes(x = seurat_clusters_DS, y = occupancy, fill = seurat_clusters_DS)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palRNAClusters) +
  labs(x = "RNA Cluster", y = "Within-cluster Proportion",
    title = "Within-cluster Stimulation Proportions per Donor") +
  theme_minimal() +
  facet_wrap(~stimulationFigures, nrow = 3)

# Save the figure.
png(file.path(plotDir, paste0(filenameSuffix, "clusterOccupancyBoxPlot_perStimWithinCluster.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(occupancy_plot)
dev.off()

# Optionally, save as PDF:
pdf(file.path(plotDir, paste0(filenameSuffix, "clusterOccupancyBoxPlot_perStimWithinCluster.pdf")),
  height = 5.5, width = 8)
print(occupancy_plot)
dev.off()
rm_tmp(ask = FALSE)
```

```{r RNAClusterStimulationOccupancyStatistics_Tregs}
# Use the subset of Treg/Tconv cells and pull metadata
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg"))
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure appropriate columns are factors
metadata.tmp$seurat_clusters_DS <- as.factor(metadata.tmp$seurat_clusters_Treg)
metadata.tmp$stimulationFigures <- as.factor(metadata.tmp$stimulationFigures)
metadata.tmp$donorIdFigures <- as.factor(metadata.tmp$donorIdFigures)

# 1. Compute cell counts per donor, RNA cluster, and stimulation condition
cluster_counts <- metadata.tmp %>%
  group_by(donorIdFigures, seurat_clusters_Treg, stimulationFigures) %>%
  summarize(cell_count = n(), .groups = "drop")

# 2. Compute total cells per donor and RNA cluster (ignoring stimulation)
total_cells_per_cluster <- metadata.tmp %>%
  group_by(donorIdFigures, seurat_clusters_Treg) %>%
  summarize(total = n(), .groups = "drop")

# 3. Merge and compute within-cluster (per donor) proportions of each stimulation
prop_df <- left_join(cluster_counts, total_cells_per_cluster,
  by = c("donorIdFigures", "seurat_clusters_Treg")) %>%
  mutate(occupancy = cell_count / total)

# For each cluster, test for differences in occupancy among stimulation groups
p_list <- lapply(unique(prop_df$seurat_clusters_Treg), function(cl) {
  df_cl <- prop_df %>% filter(seurat_clusters_Treg == cl)
  stim_groups <- unique(df_cl$stimulationFigures)
  # Only test if there is more than one stimulation group in this cluster
  if (length(stim_groups) > 1) {
    if (length(stim_groups) == 2) {
      test <- t.test(occupancy ~ stimulationFigures, data = df_cl)
      p_val <- test$p.value
    } else {
      model <- aov(occupancy ~ stimulationFigures, data = df_cl)
      p_val <- summary(model)[[1]][["Pr(>F)"]][1]
    }
    data.frame(seurat_clusters_Treg = cl, raw_p = p_val)
  } else {
    data.frame(seurat_clusters_Treg = cl, raw_p = NA)
  }
})

# Combine test results and adjust p-values using the BY ("Benjamini-Yekutieli") method
p_df <- do.call(rbind, p_list) %>%
  mutate(adj_p = p.adjust(raw_p, method = "BY"),
    label = paste("p_adj =", signif(adj_p, 3)))

print(p_df)

# 4. Plot boxplots (with jitter) where:
#    - x-axis: RNA cluster (seurat_clusters_DS)
#    - Each facet (row) is one stimulation
occupancy_plot <- ggplot(prop_df, aes(x = seurat_clusters_Treg, y = occupancy, fill = seurat_clusters_Treg)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palRNAClustersTreg) +
  labs(x = "RNA Cluster", y = "Within-cluster Proportion",
    title = "Within-cluster Stimulation Proportions per Donor, Tregs") +
  theme_minimal() +
  facet_wrap(~stimulationFigures, scales = "free_y", nrow = 3)

# Save the figure.
png(file.path(plotDir, paste0(filenameSuffix, "clusterOccupancyBoxPlot_perStimWithinCluster_Tregs.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(occupancy_plot)
dev.off()

# Optionally, save as PDF:
pdf(file.path(plotDir, paste0(filenameSuffix, "clusterOccupancyBoxPlot_perStimWithinCluster_Tregs.pdf")),
  height = 5.5, width = 8)
print(occupancy_plot)
dev.off()
rm_tmp(ask = FALSE)
```

```{r RNAClusterStimulationOccupancyStatistics_Tconvs}
# Use the subset of Treg/Tconv cells and pull metadata
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Tconv"))
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure appropriate columns are factors
metadata.tmp$seurat_clusters_DS <- as.factor(metadata.tmp$seurat_clusters_Tconv)
metadata.tmp$stimulationFigures <- as.factor(metadata.tmp$stimulationFigures)
metadata.tmp$donorIdFigures <- as.factor(metadata.tmp$donorIdFigures)

# 1. Compute cell counts per donor, RNA cluster, and stimulation condition
cluster_counts <- metadata.tmp %>%
  group_by(donorIdFigures, seurat_clusters_Tconv, stimulationFigures) %>%
  summarize(cell_count = n(), .groups = "drop")

# 2. Compute total cells per donor and RNA cluster (ignoring stimulation)
total_cells_per_cluster <- metadata.tmp %>%
  group_by(donorIdFigures, seurat_clusters_Tconv) %>%
  summarize(total = n(), .groups = "drop")

# 3. Merge and compute within-cluster (per donor) proportions of each stimulation
prop_df <- left_join(cluster_counts, total_cells_per_cluster,
  by = c("donorIdFigures", "seurat_clusters_Tconv")) %>%
  mutate(occupancy = cell_count / total)

# For each cluster, test for differences in occupancy among stimulation groups
p_list <- lapply(unique(prop_df$seurat_clusters_Tconv), function(cl) {
  df_cl <- prop_df %>% filter(seurat_clusters_Tconv == cl)
  stim_groups <- unique(df_cl$stimulationFigures)
  # Only test if there is more than one stimulation group in this cluster
  if (length(stim_groups) > 1) {
    if (length(stim_groups) == 2) {
      test <- t.test(occupancy ~ stimulationFigures, data = df_cl)
      p_val <- test$p.value
    } else {
      model <- aov(occupancy ~ stimulationFigures, data = df_cl)
      p_val <- summary(model)[[1]][["Pr(>F)"]][1]
    }
    data.frame(seurat_clusters_Tconv = cl, raw_p = p_val)
  } else {
    data.frame(seurat_clusters_Tconv = cl, raw_p = NA)
  }
})

# Combine test results and adjust p-values using the BY ("Benjamini-Yekutieli") method
p_df <- do.call(rbind, p_list) %>%
  mutate(adj_p = p.adjust(raw_p, method = "BY"),
    label = paste("p_adj =", signif(adj_p, 3)))

print(p_df)

# 4. Plot boxplots (with jitter) where:
#    - x-axis: RNA cluster (seurat_clusters_DS)
#    - Each facet (row) is one stimulation
occupancy_plot <- ggplot(prop_df, aes(x = seurat_clusters_Tconv, y = occupancy, fill = seurat_clusters_Tconv)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palRNAClustersTconv) +
  labs(x = "RNA Cluster", y = "Within-cluster Proportion",
    title = "Within-cluster Stimulation Proportions per Donor, Tconvs") +
  theme_minimal() +
  facet_wrap(~stimulationFigures, scales = "free_y", nrow = 3)

# Save the figure.
png(file.path(plotDir, paste0(filenameSuffix, "clusterOccupancyBoxPlot_perStimWithinCluster_Tconvs.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(occupancy_plot)
dev.off()

# Optionally, save as PDF:
pdf(file.path(plotDir, paste0(filenameSuffix, "clusterOccupancyBoxPlot_perStimWithinCluster_Tconvs.pdf")),
  height = 5.5, width = 8)
print(occupancy_plot)
dev.off()
rm_tmp(ask = FALSE)
```

```{r RNAClusterStudyGroupOccupancyStatisticsTreg}
# Subset to only Treg and Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType == "Treg")
# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure these columns are factors
metadata.tmp$seurat_clusters_Treg <- as.factor(metadata.tmp$seurat_clusters_Treg)
metadata.tmp$studyGroup <- as.factor(metadata.tmp$studyGroup)
# donorIdFigures indicates donor identity

# 1. Compute cell counts per donor and RNA cluster
cluster_counts <- metadata.tmp %>%
  dplyr::group_by(donorIdFigures, seurat_clusters_Treg, studyGroup) %>%
  dplyr::summarize(cell_count = n(), .groups = "drop")

# 2. For each RNA cluster, calculate occupancy proportions so that the 6 donors proportions sum to 1
prop_df <- cluster_counts %>%
  dplyr::group_by(seurat_clusters_Treg) %>%
  dplyr::mutate(occupancy = cell_count / sum(cell_count)) %>%
  dplyr::ungroup()

# 3. For each RNA cluster, perform a student's t-test comparing occupancy proportions between study groups
p_list <- lapply(unique(prop_df$seurat_clusters_Treg), function(cl) {
  df_cl <- prop_df %>% dplyr::filter(seurat_clusters_Treg == cl)
  # Ensure that we have 2 study groups (3 donors each)
  if (length(unique(df_cl$studyGroup)) == 2) {
    test <- t.test(occupancy ~ studyGroup, data = df_cl)
    data.frame(seurat_clusters_Treg = cl, raw_p = test$p.value)
  } else {
    data.frame(seurat_clusters_Treg = cl, raw_p = NA)
  }
})
p_df <- do.call(rbind, p_list)
p_df <- p_df %>%
  dplyr::mutate(adj_p = p.adjust(raw_p, method = "BY"),
    label = paste0("p_adj=", signif(adj_p, 3)))

# 4. Plot boxplots of occupancy proportions by studyGroup for each RNA cluster.
# For the annotation, set a fixed y position slightly above the maximum occupancy.
annotation_y <- max(prop_df$occupancy) * 1.05
occupancy_plot <- ggplot(prop_df, aes(x = studyGroup, y = occupancy, fill = studyGroup)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palStudyGroup) +
  labs(x = "Study Group", y = "Occupancy Proportion (per cluster)",
    title = "Treg Cluster Occupancy Proportions per Donor") +
  theme_minimal() +
  facet_wrap(~seurat_clusters_Treg, nrow = 1) +
  geom_text(
    data = p_df,
    mapping = aes(x = 1.5, y = annotation_y, label = label),
    inherit.aes = FALSE,
    size = 3
  )

png(file.path(plotDir,
  paste0(filenameSuffix, "TregclusterOccupancyBoxPlotPerClusterStudyGroup.png")),
height = 3,
width = 6,
units = "in",
res = 600)

print(occupancy_plot)

dev.off()
rm_tmp(ask = FALSE)
```

```{r RNAClusterStudyGroupOccupancyStatisticsTconv}
# Subset to only Treg and Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType == "Tconv")
# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure these columns are factors
metadata.tmp$seurat_clusters_Tconv <- as.factor(metadata.tmp$seurat_clusters_Tconv)
metadata.tmp$studyGroup <- as.factor(metadata.tmp$studyGroup)
# donorIdFigures indicates donor identity

# 1. Compute cell counts per donor and RNA cluster
cluster_counts <- metadata.tmp %>%
  dplyr::group_by(donorIdFigures, seurat_clusters_Tconv, studyGroup) %>%
  dplyr::summarize(cell_count = n(), .groups = "drop")

# 2. For each RNA cluster, calculate occupancy proportions so that the 6 donors proportions sum to 1
prop_df <- cluster_counts %>%
  dplyr::group_by(seurat_clusters_Tconv) %>%
  dplyr::mutate(occupancy = cell_count / sum(cell_count)) %>%
  dplyr::ungroup()

# 3. For each RNA cluster, perform a student's t-test comparing occupancy proportions between study groups
p_list <- lapply(unique(prop_df$seurat_clusters_Tconv), function(cl) {
  df_cl <- filter(prop_df, seurat_clusters_Tconv == cl)
  if (length(unique(df_cl$studyGroup)) == 2) {
    group_counts <- group_by(df_cl, studyGroup) %>%
      summarize(n = n(), .groups = "drop")
    if (min(group_counts$n) >= 2) {
      test <- t.test(occupancy ~ studyGroup, data = df_cl)
      data.frame(seurat_clusters_Tconv = cl, raw_p = test$p.value)
    } else {
      data.frame(seurat_clusters_Tconv = cl, raw_p = NA)
    }
  } else {
    data.frame(seurat_clusters_Tconv = cl, raw_p = NA)
  }
})
p_df <- do.call(rbind, p_list)
p_df <- mutate(p_df,
  adj_p = p.adjust(raw_p, method = "BY"),
  label = paste0("p_adj=", signif(adj_p, 3)))

# 4. Plot boxplots of occupancy proportions by studyGroup for each RNA cluster.
# For the annotation, set a fixed y position slightly above the maximum occupancy.
annotation_y <- max(prop_df$occupancy) * 1.05
occupancy_plot <- ggplot(prop_df, aes(x = studyGroup, y = occupancy, fill = studyGroup)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palStudyGroup) +
  labs(x = "Study Group", y = "Occupancy Proportion (per cluster)",
    title = "Tconv Cluster Occupancy Proportions per Donor") +
  theme_minimal() +
  facet_wrap(~seurat_clusters_Tconv, nrow = 1) +
  geom_text(
    data = p_df,
    mapping = aes(x = 1.5, y = annotation_y, label = label),
    inherit.aes = FALSE,
    size = 3
  )

png(file.path(plotDir,
  paste0(filenameSuffix, "TconvclusterOccupancyBoxPlotPerClusterStudyGroup.png")),
height = 3,
width = 6.5,
units = "in",
res = 600)

print(occupancy_plot)

dev.off()
rm_tmp(ask = FALSE)
```

```{r RNAClusterStimulationOccupancyStatistics}
# Subset to only Treg and Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))
# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure these columns are factors
metadata.tmp$seurat_clusters_DS <- as.factor(metadata.tmp$seurat_clusters_DS)
metadata.tmp$stimulationFigures <- as.factor(metadata.tmp$stimulationFigures)
# donorIdFigures indicates donor identity

# 1. Compute cell counts per donor and RNA cluster using all stimulation figures
cluster_counts <- metadata.tmp %>%
  dplyr::group_by(donorIdFigures, seurat_clusters_DS, stimulationFigures) %>%
  dplyr::summarize(cell_count = n(), .groups = "drop")

# 2. For each RNA cluster, calculate occupancy proportions so that the 6 donors proportions sum to 1
prop_df <- cluster_counts %>%
  dplyr::group_by(seurat_clusters_DS) %>%
  dplyr::mutate(occupancy = cell_count / sum(cell_count)) %>%
  dplyr::ungroup()

# 3. For testing, restrict to only IAR and Microbial (but keep proportions computed with all data)
p_list <- lapply(unique(prop_df$seurat_clusters_DS), function(cl) {
  df_cl <- prop_df %>%
    dplyr::filter(seurat_clusters_DS == cl) # , stimulationFigures %in% c("IAR", "Microbial") (if we want to filter down to just IAR/Microbial)
  # Only perform t-test if 2 stimulation groups are present and both have at least 2 observations
  if (length(unique(df_cl$stimulationFigures)) == 2) {
    group_counts <- df_cl %>% dplyr::group_by(stimulationFigures) %>% dplyr::summarize(n = n(), .groups = "drop")
    if (min(group_counts$n) >= 2) {
      test <- t.test(occupancy ~ stimulationFigures, data = df_cl)
      data.frame(seurat_clusters_DS = cl, raw_p = test$p.value)
    } else {
      data.frame(seurat_clusters_DS = cl, raw_p = NA)
    }
  } else {
    data.frame(seurat_clusters_DS = cl, raw_p = NA)
  }
})
p_df <- do.call(rbind, p_list)
p_df <- p_df %>%
  dplyr::mutate(adj_p = p.adjust(raw_p, method = "BY"),
    label = paste0("p_adj=", signif(adj_p, 3)))

# 4. For plotting, restrict to IAR and Microbial
plot_df <- prop_df # %>% dplyr::filter(stimulationFigures %in% c("IAR", "Microbial"))
annotation_y <- max(plot_df$occupancy) * 1.05
occupancy_plot <- ggplot(plot_df, aes(x = stimulationFigures, y = occupancy, fill = stimulationFigures)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palStimulation) +
  labs(x = "Stimulation", y = "Occupancy Proportion (per cluster)",
    title = "Cluster Occupancy Proportions per Donor") +
  theme_minimal() +
  facet_wrap(~seurat_clusters_DS) +
  geom_text(
    data = p_df,
    mapping = aes(x = 1.5, y = annotation_y, label = label),
    inherit.aes = FALSE,
    size = 3
  )

png(file.path(plotDir,
  paste0(filenameSuffix, "clusterOccupancyBoxPlotPerClusterStimulation.png")),
height = 5.5,
width = 8,
units = "in",
res = 600)

print(occupancy_plot)

dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulations}
# plot, on a per-donor-basis, the percentage of each seurat_clusters_Treg per stimulationFigures
# Subset to Treg cells (adjust if needed)
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg")

# 1. Compute counts per donor, stimulation, and Treg cluster
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Treg cells per stimulation (ignoring donor)
stim_total <- metadata_treg %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Treg) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Plot the results: Facet by stimulation (3 subplots), x-axis is Treg cluster,
# and each donors percentage contribution (relative to the stimulation total) is shown.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Treg, y = percentage)) +
  geom_boxplot(outlier.shape = NA, fill = "grey90") +
  geom_jitter(aes(color = donorIdFigures), width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Treg Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Treg Clusters by Stimulation") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_color_manual(values = palDonorId)

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_Percent.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionsOfStimulationsInClustersTregs}
fontSize <- 8
# Subset to Treg cells (adjust if needed)
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg")

# Get all unique values
all_donors <- unique(metadata_treg$donorIdFigures)
all_stims <- unique(metadata_treg$stimulationFigures)
all_clusters <- unique(metadata_treg$seurat_clusters_Treg)

# 1. Create all possible combinations
all_combos <- expand_grid(
  donorIdFigures = unique(metadata_treg$donorIdFigures),
  stimulationFigures = unique(metadata_treg$stimulationFigures),
  seurat_clusters_Treg = unique(metadata_treg$seurat_clusters_Treg)
)

# 2. Count cells per combination
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# 3. Fill in missing combinations with zero
counts_df_full <- all_combos %>%
  left_join(counts_df, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_Treg")) %>%
  mutate(count = ifelse(is.na(count), 0L, count))

# 4. Get total cells per donor/stim
donor_stim_total <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 5. Calculate percentage
prop_df <- counts_df_full %>%
  left_join(donor_stim_total, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(percentage = ifelse(total > 0, (count / total) * 100, 0))

# (Optional) Verify that for each donor and stimulation the percentages sum to ~100%
prop_sum <- prop_df %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(sum_perc = sum(percentage))

print(prop_sum)

# --- Calculate p-values with BY correction (using only IAR vs Microbial) ---
p_values <- prop_df %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(p_val = t.test(percentage ~ stimulationFigures)$p.value, .groups = "drop") %>%
  mutate(adj_p = p.adjust(p_val, method = "BY"),
    label = paste0("p_adj = ", signif(adj_p, 3)))

# Compute a y-axis annotation position per cluster
annotation_df <- prop_df %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(ann_y = 80, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Treg")

# Create a named list of element_rect for each cluster
strip_colors <- lapply(palRNAClustersTreg, function(color) {
  element_rect(fill = color, color = "black", size = 0.5)
})

# Create significance labels
annotation_df <- prop_df %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(ann_y = max(percentage) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Treg") %>%
  mutate(label = case_when(
    adj_p > 0.05 ~ "ns",
    adj_p <= 0.05 & adj_p > 0.01 ~ "*",
    adj_p <= 0.01 & adj_p > 0.001 ~ "**",
    adj_p <= 0.001 ~ "***"
  ),
  group1 = "IAR",
  group2 = "Microbial",
  y.position = ann_y)

# Plot with significance bars
plot.tmp <- ggplot(prop_df, aes(x = stimulationFigures, y = percentage)) +
  geom_boxplot(aes(fill = stimulationFigures), alpha = 0.85, outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2) +
  facet_wrap2(~seurat_clusters_Treg, nrow = 1,
    strip = strip_themed(background_x = strip_colors)) +
  labs(x = "Stimulation", y = "Percentage of Treg cells per donor (within stimulation)") +
  theme_classic(base_size = fontSize) +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 0.5)) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  scale_color_manual(values = palStimulation) +
  stat_pvalue_manual(annotation_df,
    label = "label",
    xmin = "group1",
    xmax = "group2",
    y.position = "y.position",
    tip.length = 0.01,
    size = 4)




# --- Save the plot ---
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_Percent_stimulationColors.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r proportionOfStudyGroupInTregClusters}
# Subset to Treg cells (adjust if needed)
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg")

# Get all unique values
all_donors <- unique(metadata_treg$donorIdFigures)
all_stims <- unique(metadata_treg$stimulationFigures)
all_clusters <- unique(metadata_treg$seurat_clusters_Treg)

# 1. Create all possible combinations
all_combos <- expand_grid(
  donorIdFigures = all_donors,
  stimulationFigures = all_stims,
  seurat_clusters_Treg = all_clusters
)

# 2. Count cells per combination
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# 3. Fill in missing combinations with zero
counts_df_full <- all_combos %>%
  left_join(counts_df, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_Treg")) %>%
  mutate(count = ifelse(is.na(count), 0L, count))

# 4. Get total cells per donor/stim
donor_stim_total <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 5. Calculate percentage
prop_df <- counts_df_full %>%
  left_join(donor_stim_total, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(percentage = ifelse(total > 0, (count / total) * 100, 0))

# Add studyGroup info for each donor
donor2group <- metadata_treg %>%
  select(donorIdFigures, studyGroup) %>%
  distinct()
prop_df <- prop_df %>%
  left_join(donor2group, by = "donorIdFigures")

# --- Plotting: one plot per stimulation ---
for (stim in all_stims) {
  plot_df <- prop_df %>% filter(stimulationFigures == stim)

  # Optional: order clusters numerically
  plot_df$seurat_clusters_Treg <- factor(plot_df$seurat_clusters_Treg, levels = sort(unique(plot_df$seurat_clusters_Treg)))

  # Calculate p-values for Control vs T1D per cluster (within this stimulation)
  pval_df <- plot_df %>%
    group_by(seurat_clusters_Treg) %>%
    summarise(
      p_val = ifelse(length(unique(studyGroup)) == 2,
        t.test(percentage ~ studyGroup)$p.value,
        NA_real_),
      .groups = "drop"
    ) %>%
    mutate(adj_p = p.adjust(p_val, method = "BY"),
      label = ifelse(!is.na(adj_p), paste0("p_adj = ", signif(adj_p, 3)), ""))

  # Compute y-axis annotation position per cluster
  annotation_df <- plot_df %>%
    group_by(seurat_clusters_Treg) %>%
    summarise(ann_y = max(percentage, na.rm = TRUE) + 5, .groups = "drop") %>%
    left_join(pval_df, by = "seurat_clusters_Treg")

  # generate plot
  p <- ggplot(plot_df, aes(x = seurat_clusters_Treg, y = percentage, color = studyGroup, fill = studyGroup)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.3, position = position_dodge(width = 0.7)) +
    geom_jitter(
      aes(group = studyGroup),
      color = "black",         # <-- set dots to black
      size = 2, alpha = 0.8,
      position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.7)
    ) +
    labs(
      x = "Cluster",
      y = "Percentage of Treg cells per donor (within stimulation)",
      title = paste0("Treg Cluster Proportions per Donor\nStimulation: ", stim)
    ) +
    theme_classic() +
    scale_color_manual(values = palStudyGroup, name = "Study Group") +
    scale_fill_manual(values = palStudyGroup, name = "Study Group") +
    geom_text(
      data = annotation_df,
      aes(x = seurat_clusters_Treg, y = ann_y, label = label),
      inherit.aes = FALSE, color = "black", size = 3
    )

  # Save
  ggsave(
    filename = file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_", stim, "_PerCluster_Percent_StudyGroup.png")),
    plot = p, height = 5, width = 7, dpi = 300
  )
}
```

```{r proportionsOfStimulationsInClustersTconvs}
fontSize <- 8
# Subset to Tconv cells (adjust if needed)
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv")

# Get all unique values
all_donors <- unique(metadata_Tconv$donorIdFigures)
all_stims <- unique(metadata_Tconv$stimulationFigures)
all_clusters <- unique(metadata_Tconv$seurat_clusters_Tconv)

# 1. Create all possible combinations
all_combos <- expand_grid(
  donorIdFigures = unique(metadata_Tconv$donorIdFigures),
  stimulationFigures = unique(metadata_Tconv$stimulationFigures),
  seurat_clusters_Tconv = unique(metadata_Tconv$seurat_clusters_Tconv)
)

# 2. Count cells per combination
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# 3. Fill in missing combinations with zero
counts_df_full <- all_combos %>%
  left_join(counts_df, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_Tconv")) %>%
  mutate(count = ifelse(is.na(count), 0L, count))

# 4. Get total cells per donor/stim
donor_stim_total <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 5. Calculate percentage
prop_df <- counts_df_full %>%
  left_join(donor_stim_total, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(percentage = ifelse(total > 0, (count / total) * 100, 0))

# (Optional) Verify that for each donor and stimulation the percentages sum to ~100%
prop_sum <- prop_df %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(sum_perc = sum(percentage))

print(prop_sum)

# --- Calculate p-values with BY correction (using only IAR vs Microbial) ---
p_values <- prop_df %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(p_val = t.test(percentage ~ stimulationFigures)$p.value, .groups = "drop") %>%
  mutate(adj_p = p.adjust(p_val, method = "BY"),
    label = paste0("p_adj = ", signif(adj_p, 3)))

# Compute a y-axis annotation position per cluster
annotation_df <- prop_df %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(ann_y = 80, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Tconv")

# Create a named list of element_rect for each cluster
strip_colors <- lapply(palRNAClustersTconv, function(color) {
  element_rect(fill = color, color = "black", size = 0.5)
})

# Create significance labels
annotation_df <- prop_df %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(ann_y = max(percentage) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Tconv") %>%
  mutate(label = case_when(
    adj_p > 0.05 ~ "ns",
    adj_p <= 0.05 & adj_p > 0.01 ~ "*",
    adj_p <= 0.01 & adj_p > 0.001 ~ "**",
    adj_p <= 0.001 ~ "***"
  ),
  group1 = "IAR",
  group2 = "Microbial",
  y.position = ann_y)

# Plot with significance bars
plot.tmp <- ggplot(prop_df, aes(x = stimulationFigures, y = percentage)) +
  geom_boxplot(aes(fill = stimulationFigures), alpha = 0.85, outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2) +
  facet_wrap2(~seurat_clusters_Tconv, nrow = 1,
    strip = strip_themed(background_x = strip_colors)) +
  labs(x = "Stimulation", y = "Percentage of Tconv cells per donor (within stimulation)") +
  theme_classic(base_size = fontSize) +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 0.5)) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  scale_color_manual(values = palStimulation) +
  stat_pvalue_manual(annotation_df,
    label = "label",
    xmin = "group1",
    xmax = "group2",
    y.position = "y.position",
    tip.length = 0.01,
    size = 4)




# --- Save the plot ---
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_Percent_stimulationColors.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r proportionOfStudyGroupInTconvClusters}
# Subset to Tconv cells (adjust if needed)
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv")

# Get all unique values
all_donors <- unique(metadata_Tconv$donorIdFigures)
all_stims <- unique(metadata_Tconv$stimulationFigures)
all_clusters <- unique(metadata_Tconv$seurat_clusters_Tconv)

# 1. Create all possible combinations
all_combos <- expand_grid(
  donorIdFigures = all_donors,
  stimulationFigures = all_stims,
  seurat_clusters_Tconv = all_clusters
)

# 2. Count cells per combination
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# 3. Fill in missing combinations with zero
counts_df_full <- all_combos %>%
  left_join(counts_df, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_Tconv")) %>%
  mutate(count = ifelse(is.na(count), 0L, count))

# 4. Get total cells per donor/stim
donor_stim_total <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 5. Calculate percentage
prop_df <- counts_df_full %>%
  left_join(donor_stim_total, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(percentage = ifelse(total > 0, (count / total) * 100, 0))

# Add studyGroup info for each donor
donor2group <- metadata_Tconv %>%
  select(donorIdFigures, studyGroup) %>%
  distinct()
prop_df <- prop_df %>%
  left_join(donor2group, by = "donorIdFigures")

# --- Plotting: one plot per stimulation ---
for (stim in all_stims) {
  plot_df <- prop_df %>% filter(stimulationFigures == stim)

  # Optional: order clusters numerically
  plot_df$seurat_clusters_Tconv <- factor(plot_df$seurat_clusters_Tconv, levels = sort(unique(plot_df$seurat_clusters_Tconv)))

  # Calculate p-values for Control vs T1D per cluster (within this stimulation)
  pval_df <- plot_df %>%
    group_by(seurat_clusters_Tconv) %>%
    summarise(
      p_val = ifelse(length(unique(studyGroup)) == 2,
        t.test(percentage ~ studyGroup)$p.value,
        NA_real_),
      .groups = "drop"
    ) %>%
    mutate(adj_p = p.adjust(p_val, method = "BY"),
      label = ifelse(!is.na(adj_p), paste0("p_adj = ", signif(adj_p, 3)), ""))

  # Compute y-axis annotation position per cluster
  annotation_df <- plot_df %>%
    group_by(seurat_clusters_Tconv) %>%
    summarise(ann_y = max(percentage, na.rm = TRUE) + 5, .groups = "drop") %>%
    left_join(pval_df, by = "seurat_clusters_Tconv")

  # generate plot
  p <- ggplot(plot_df, aes(x = seurat_clusters_Tconv, y = percentage, color = studyGroup, fill = studyGroup)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.3, position = position_dodge(width = 0.7)) +
    geom_jitter(
      aes(group = studyGroup),
      color = "black",         # <-- set dots to black
      size = 2, alpha = 0.8,
      position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.7)
    ) +
    labs(
      x = "Cluster",
      y = "Percentage of Tconv cells per donor (within stimulation)",
      title = paste0("Tconv Cluster Proportions per Donor\nStimulation: ", stim)
    ) +
    theme_classic() +
    scale_color_manual(values = palStudyGroup, name = "Study Group") +
    scale_fill_manual(values = palStudyGroup, name = "Study Group") +
    geom_text(
      data = annotation_df,
      aes(x = seurat_clusters_Tconv, y = ann_y, label = label),
      inherit.aes = FALSE, color = "black", size = 3
    )

  # Save
  ggsave(
    filename = file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_", stim, "_PerCluster_Percent_StudyGroup.png")),
    plot = p, height = 5, width = 7, dpi = 300
  )
}
```

```{r proportionOfClustersInStimulationsStudyGroupSplit}
# Subset to Treg cells
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg")

# 1. Compute counts per donor, stimulation, and Treg cluster
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# If studyGroup is unique per donor, add studyGroup to counts_df
donor_study <- metadata_treg %>%
  distinct(donorIdFigures, studyGroup)
counts_df <- left_join(counts_df, donor_study, by = "donorIdFigures")

# 2. Compute total number of Treg cells per stimulation (ignoring donor)
stim_total <- metadata_treg %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Treg) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Create a plot that splits per-donor dots and boxplots by studyGroup within each Treg cluster.
#    We use position_dodge() to separate the studyGroup groups.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Treg, y = percentage, fill = studyGroup)) +
  geom_boxplot(position = position_dodge(width = 0.8), outlier.shape = NA, alpha = 0.5) +
  geom_jitter(aes(color = donorIdFigures),
    position = position_dodge(width = 0.8),
    size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Treg Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Treg Clusters by Stimulation\n(split by studyGroup)") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_fill_manual(values = palStudyGroup) +
  scale_color_manual(values = palDonorId)

# Save the updated plot:
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_Percent_byStudyGroupTogether.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r expansionProportionPlotsTregsAllDonorCellsDenom}
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg") %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata_treg <- metadata_treg %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# Only keep expanded cells
metadata_treg_expanded <- metadata_treg %>%
  filter(expanded)

# Calculate counts of expanded cells per group
expanded_counts <- metadata_treg_expanded %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(n_expanded = n(), .groups = "drop")

# Get all possible combinations from your metadata
all_combos <- metadata_treg %>%
  distinct(donorIdFigures, stimulationFigures, seurat_clusters_Treg)

# Complete the expanded_counts table with all possible combinations
expanded_counts <- expanded_counts %>%
  right_join(all_combos, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_Treg")) %>%
  mutate(n_expanded = ifelse(is.na(n_expanded), 0, n_expanded))

# Total expanded cells per donor
total_expanded_per_donor <- metadata_treg_expanded %>%
  group_by(donorIdFigures) %>%
  summarise(total_expanded = n(), .groups = "drop")

# Calculate proportion
expanded_counts <- expanded_counts %>%
  left_join(total_expanded_per_donor, by = "donorIdFigures") %>%
  mutate(prop_expanded = ifelse(total_expanded > 0, n_expanded / total_expanded * 100, 0))

# # Include zero counts cases
# expanded_counts <- expanded_counts %>%
#   complete(donorIdFigures, stimulationFigures, seurat_clusters_Treg, fill = list(n_expanded = 0))

# Only IAR vs Microbial
p_values <- expanded_counts %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(
    p_val = t.test(prop_expanded ~ stimulationFigures)$p.value,
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = paste0("p_adj = ", signif(adj_p, 3))
  )

# Annotation y-position
annotation_df <- expanded_counts %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Treg")

plot.tmp <- ggplot(expanded_counts, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_Treg, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClustersTreg, function(clr) element_rect(fill = clr)),
        names(palRNAClustersTreg)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded Treg cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Treg Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.5, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 3
  )

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_PercentExpanded_clusterColors.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```

```{r expansionProportionPlotsTregsDonorCellsInStimDenom}
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg") %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata_treg <- metadata_treg %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# 1. Get all unique donors, stimulations, and clusters
all_donors <- unique(metadata_treg$donorIdFigures)
all_stims <- unique(metadata_treg$stimulationFigures)
all_clusters <- unique(metadata_treg$seurat_clusters_Treg)

# 2. Create all combinations
all_combos <- expand.grid(
  donorIdFigures = all_donors,
  stimulationFigures = all_stims,
  seurat_clusters_Treg = all_clusters,
  stringsAsFactors = FALSE
)

# 3. Calculate total Treg cells per donor+stimulation
total_treg_per_donor_stim <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total_treg = n(), .groups = "drop")

# 4. Only keep expanded cells
metadata_treg_expanded <- metadata_treg %>%
  filter(expanded)

# 5. Calculate counts of expanded cells per group (donor, stim, cluster)
expanded_counts <- metadata_treg_expanded %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(n_expanded = n(), .groups = "drop")

# 6. Join with all combinations to fill in zeros for missing groups
expanded_counts_full <- all_combos %>%
  left_join(expanded_counts, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_Treg")) %>%
  mutate(n_expanded = ifelse(is.na(n_expanded), 0, n_expanded))

# 7. Join with total Treg cells per donor+stim
expanded_counts_full <- expanded_counts_full %>%
  left_join(total_treg_per_donor_stim, by = c("donorIdFigures", "stimulationFigures"))

# 8. Calculate proportion of expanded cells (as percent)
expanded_counts_full <- expanded_counts_full %>%
  mutate(prop_expanded = ifelse(total_treg > 0, n_expanded / total_treg * 100, NA_real_))

# Only IAR vs Microbial
p_values <- expanded_counts_full %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(
    p_val = t.test(prop_expanded ~ stimulationFigures)$p.value,
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = paste0("p_adj = ", signif(adj_p, 3))
  )

# Annotation y-position
annotation_df <- expanded_counts_full %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Treg")

plot.tmp <- ggplot(expanded_counts_full, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_Treg, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClustersTreg, function(clr) element_rect(fill = clr)),
        names(palRNAClustersTreg)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded Treg cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Treg Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.5, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 3
  )

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```

```{r expansionProportionPlotsAllAgReactiveDonorCellsInStimDenom}
fontSize <- 8

# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata.tmp <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType %in%  c("Treg", "Tconv")) %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata.tmp <- metadata.tmp %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# 1. Get all unique donors, stimulations, and clusters
all_donors <- unique(metadata.tmp$donorIdFigures)
all_stims <- unique(metadata.tmp$stimulationFigures)
all_clusters <- unique(metadata.tmp$seurat_clusters_DS)

# 2. Create all combinations
all_combos <- expand.grid(
  donorIdFigures = all_donors,
  stimulationFigures = all_stims,
  seurat_clusters_DS = all_clusters,
  stringsAsFactors = FALSE
)

# 3. Calculate total Treg cells per donor+stimulation
total_per_donor_stim <- metadata.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 4. Only keep expanded cells
metadataExpanded.tmp <- metadata.tmp %>%
  filter(expanded)

# 5. Calculate counts of expanded cells per group (donor, stim, cluster)
expanded_counts <- metadataExpanded.tmp %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_DS) %>%
  summarise(n_expanded = n(), .groups = "drop")

# 6. Join with all combinations to fill in zeros for missing groups
expanded_counts_full <- all_combos %>%
  left_join(expanded_counts, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_DS")) %>%
  mutate(n_expanded = ifelse(is.na(n_expanded), 0, n_expanded))

# 7. Join with total Treg cells per donor+stim
expanded_counts_full <- expanded_counts_full %>%
  left_join(total_per_donor_stim, by = c("donorIdFigures", "stimulationFigures"))

# 8. Calculate proportion of expanded cells (as percent)
expanded_counts_full <- expanded_counts_full %>%
  mutate(prop_expanded = ifelse(total > 0, n_expanded / total * 100, NA_real_))

# Only IAR vs Microbial
p_values <- expanded_counts_full %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_DS) %>%
  summarise(
    p_val = t.test(prop_expanded ~ stimulationFigures)$p.value,
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = paste0("p_adj = ", signif(adj_p, 3))
  )

# Annotation y-position
annotation_df <- expanded_counts_full %>%
  group_by(seurat_clusters_DS) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_DS")

plot.tmp <- ggplot(expanded_counts_full, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_DS, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClusters, function(clr) element_rect(fill = clr)),
        names(palRNAClusters)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded cells per donor (within cluster)"
  ) +
  theme_classic(base_size = fontSize) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.text.x = element_text(angle = 30, hjust = 1)   # <--- Tilt x-ticks
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.75, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 2.5    # <--- Smaller text
  )

# Save the plot
savePlot(
  plot = plot.tmp,
  plotDir = plotDir,
  filename = paste0(filenameSuffix, "agReactiveCellsClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom"),
  height = 5.5,
  width = 8,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
)
```

```{r expansionProportionPlotsAllAgReactiveDonorCellsInStimDenom_noPolyclonal}
fontSize <- 8

# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata.tmp <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType %in%  c("Treg", "Tconv")) %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata.tmp <- metadata.tmp %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# 1. Get all unique donors, stimulations, and clusters
all_donors <- unique(metadata.tmp$donorIdFigures)
all_stims <- unique(metadata.tmp$stimulationFigures)
all_clusters <- unique(metadata.tmp$seurat_clusters_DS)

# 2. Create all combinations
all_combos <- expand.grid(
  donorIdFigures = all_donors,
  stimulationFigures = all_stims,
  seurat_clusters_DS = all_clusters,
  stringsAsFactors = FALSE
)

# 3. Calculate total Treg cells per donor+stimulation
total_per_donor_stim <- metadata.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 4. Only keep expanded cells
metadataExpanded.tmp <- metadata.tmp %>%
  filter(expanded)

# ---- NEW: Filter to only IAR and Microbial ----
metadataExpanded.tmp <- metadataExpanded.tmp %>%
  filter(stimulationFigures %in% c("IAR", "Microbial"))

# 5. Calculate counts of expanded cells per group (donor, stim, cluster)
expanded_counts <- metadataExpanded.tmp %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_DS) %>%
  summarise(n_expanded = n(), .groups = "drop")

# 6. Join with all combinations to fill in zeros for missing groups
expanded_counts_full <- all_combos %>%
  left_join(expanded_counts, by = c("donorIdFigures", "stimulationFigures", "seurat_clusters_DS")) %>%
  mutate(n_expanded = ifelse(is.na(n_expanded), 0, n_expanded))

# 7. Join with total Treg cells per donor+stim
expanded_counts_full <- expanded_counts_full %>%
  left_join(total_per_donor_stim, by = c("donorIdFigures", "stimulationFigures"))

# 8. Calculate proportion of expanded cells (as percent)
expanded_counts_full <- expanded_counts_full %>%
  mutate(prop_expanded = ifelse(total > 0, n_expanded / total * 100, NA_real_))

# ---- Only IAR vs Microbial (already filtered above, but keep for clarity) ----
expanded_counts_full <- expanded_counts_full %>%
  filter(stimulationFigures %in% c("IAR", "Microbial"))

# Only IAR vs Microbial
p_values <- expanded_counts_full %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_DS) %>%
  summarise(
    p_val = t.test(prop_expanded ~ stimulationFigures)$p.value,
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = paste0("p_adj = ", signif(adj_p, 3))
  )

# Annotation y-position
annotation_df <- expanded_counts_full %>%
  group_by(seurat_clusters_DS) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_DS")

plot.tmp <- ggplot(expanded_counts_full, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_DS, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClusters, function(clr) element_rect(fill = clr)),
        names(palRNAClusters)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded cells per donor (within cluster)"
  ) +
  theme_classic(base_size = fontSize) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.text.x = element_text(angle = 30, hjust = 1)   # <--- Tilt x-ticks
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.75, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 2.5    # <--- Smaller text
  )

# Save the plot
savePlot(
  plot = plot.tmp,
  plotDir = plotDir,
  filename = paste0(filenameSuffix, "agReactiveCellsClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom_noPolyclonal"),
  height = 5.5,
  width = 8,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
)
```

```{r expansionProportionPlotsTregsClusterFacetDonorCellsInStimDenom_noPolyclonal}
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata_Treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg") %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata_Treg <- metadata_Treg %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# ---- NEW: Filter to only IAR and Microbial ----
metadata_Treg <- metadata_Treg %>%
  filter(stimulationFigures %in% c("IAR", "Microbial"))

# ---- Calculate total Treg cells per donor+stimulation ----
total_Treg_per_donor_stim <- metadata_Treg %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total_Treg = n(), .groups = "drop")

# Only keep expanded cells
metadata_Treg_expanded <- metadata_Treg %>%
  filter(expanded)

# Calculate counts of expanded cells per group (donor, stim, cluster)
expanded_counts <- metadata_Treg_expanded %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(n_expanded = n(), .groups = "drop")

# ---- Join with total Treg cells per donor+stim ----
expanded_counts <- expanded_counts %>%
  left_join(total_Treg_per_donor_stim, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(prop_expanded = n_expanded / total_Treg * 100)

# ---- Only IAR vs Microbial (already filtered above, but keep for clarity) ----
expanded_counts <- expanded_counts %>%
  filter(stimulationFigures %in% c("IAR", "Microbial"))

# ---- Per-cluster t-test ----
p_values <- expanded_counts %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(
    p_val = {
      # Only run t-test if both groups are present and have at least 2 values each
      groups <- unique(stimulationFigures)
      n_IAR <- sum(stimulationFigures == "IAR")
      n_Microbial <- sum(stimulationFigures == "Microbial")
      if (all(c("IAR", "Microbial") %in% groups) && n_IAR > 1 && n_Microbial > 1) {
        test <- try(t.test(prop_expanded ~ stimulationFigures), silent = TRUE)
        if (inherits(test, "try-error")) NA_real_ else test$p.value
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = ifelse(is.na(adj_p), "n/a", paste0("p_adj = ", signif(adj_p, 3)))
  )

# Annotation y-position
annotation_df <- expanded_counts %>%
  group_by(seurat_clusters_Treg) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Treg")

plot.tmp <- ggplot(expanded_counts, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_Treg, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClustersTreg, function(clr) element_rect(fill = clr)),
        names(palRNAClustersTreg)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded Treg cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Treg Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.5, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 3
  )

# Save the plot
# png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom_IARvsMicrobial.png")),
#   height = 5.5, width = 8, units = "in", res = 600)
# print(plot.tmp)
# dev.off()

savePlot(
  plot = plot.tmp,
  plotDir = plotDir,
  filename = paste0(filenameSuffix, "TregClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom_IARvsMicrobial"),
  height = 5.5,
  width = 8,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
)
```

```{r expansionProportionPlotsTconvsClusterFacetAllDonorCellsDenom}
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv") %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata_Tconv <- metadata_Tconv %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# Only keep expanded cells
metadata_Tconv_expanded <- metadata_Tconv %>%
  filter(expanded)

# Calculate counts of expanded cells per group
expanded_counts <- metadata_Tconv_expanded %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(n_expanded = n(), .groups = "drop")

# Total expanded cells per donor
total_expanded_per_donor <- metadata_Tconv_expanded %>%
  group_by(donorIdFigures) %>%
  summarise(total_expanded = n(), .groups = "drop")

# Calculate proportion
expanded_counts <- expanded_counts %>%
  left_join(total_expanded_per_donor, by = "donorIdFigures") %>%
  mutate(prop_expanded = n_expanded / total_expanded * 100)

# Only IAR vs Microbial
p_values <- expanded_counts %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(
    p_val = {
      # Only run t-test if both groups are present and have at least 2 values each
      groups <- unique(stimulationFigures)
      n_IAR <- sum(stimulationFigures == "IAR")
      n_Microbial <- sum(stimulationFigures == "Microbial")
      if (all(c("IAR", "Microbial") %in% groups) && n_IAR > 1 && n_Microbial > 1) {
        test <- try(t.test(prop_expanded ~ stimulationFigures), silent = TRUE)
        if (inherits(test, "try-error")) NA_real_ else test$p.value
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = ifelse(is.na(adj_p), "n/a", paste0("p_adj = ", signif(adj_p, 3)))
  )

# Annotation y-position
annotation_df <- expanded_counts %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Tconv")

plot.tmp <- ggplot(expanded_counts, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_Tconv, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClustersTconv, function(clr) element_rect(fill = clr)),
        names(palRNAClustersTconv)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded Tconv cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Tconv Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.5, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 3
  )

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_PercentExpanded_clusterColors.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```

```{r expansionProportionPlotsTconvsClusterFacetDonorCellsInStimDenom}
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv") %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata_Tconv <- metadata_Tconv %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# ---- NEW: Calculate total Tconv cells per donor+stimulation ----
total_Tconv_per_donor_stim <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total_Tconv = n(), .groups = "drop")

# Only keep expanded cells
metadata_Tconv_expanded <- metadata_Tconv %>%
  filter(expanded)

# Calculate counts of expanded cells per group (donor, stim, cluster)
expanded_counts <- metadata_Tconv_expanded %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(n_expanded = n(), .groups = "drop")

# ---- NEW: Join with total Tconv cells per donor+stim ----
expanded_counts <- expanded_counts %>%
  left_join(total_Tconv_per_donor_stim, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(prop_expanded = n_expanded / total_Tconv * 100)

# Only IAR vs Microbial
p_values <- expanded_counts %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(
    p_val = {
      # Only run t-test if both groups are present and have at least 2 values each
      groups <- unique(stimulationFigures)
      n_IAR <- sum(stimulationFigures == "IAR")
      n_Microbial <- sum(stimulationFigures == "Microbial")
      if (all(c("IAR", "Microbial") %in% groups) && n_IAR > 1 && n_Microbial > 1) {
        test <- try(t.test(prop_expanded ~ stimulationFigures), silent = TRUE)
        if (inherits(test, "try-error")) NA_real_ else test$p.value
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = ifelse(is.na(adj_p), "n/a", paste0("p_adj = ", signif(adj_p, 3)))
  )

# Annotation y-position
annotation_df <- expanded_counts %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Tconv")

plot.tmp <- ggplot(expanded_counts, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_Tconv, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClustersTconv, function(clr) element_rect(fill = clr)),
        names(palRNAClustersTconv)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded Tconv cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Tconv Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.5, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 3
  )

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```

```{r expansionProportionPlotsTconvsClusterFacetDonorCellsInStimDenom_noPolyclonal}
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv") %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata_Tconv <- metadata_Tconv %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# ---- NEW: Filter to only IAR and Microbial ----
metadata_Tconv <- metadata_Tconv %>%
  filter(stimulationFigures %in% c("IAR", "Microbial"))

# ---- Calculate total Tconv cells per donor+stimulation ----
total_Tconv_per_donor_stim <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total_Tconv = n(), .groups = "drop")

# Only keep expanded cells
metadata_Tconv_expanded <- metadata_Tconv %>%
  filter(expanded)

# Calculate counts of expanded cells per group (donor, stim, cluster)
expanded_counts <- metadata_Tconv_expanded %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(n_expanded = n(), .groups = "drop")

# ---- Join with total Tconv cells per donor+stim ----
expanded_counts <- expanded_counts %>%
  left_join(total_Tconv_per_donor_stim, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(prop_expanded = n_expanded / total_Tconv * 100)

# ---- Only IAR vs Microbial (already filtered above, but keep for clarity) ----
expanded_counts <- expanded_counts %>%
  filter(stimulationFigures %in% c("IAR", "Microbial"))

# ---- Per-cluster t-test ----
p_values <- expanded_counts %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(
    p_val = {
      # Only run t-test if both groups are present and have at least 2 values each
      groups <- unique(stimulationFigures)
      n_IAR <- sum(stimulationFigures == "IAR")
      n_Microbial <- sum(stimulationFigures == "Microbial")
      if (all(c("IAR", "Microbial") %in% groups) && n_IAR > 1 && n_Microbial > 1) {
        test <- try(t.test(prop_expanded ~ stimulationFigures), silent = TRUE)
        if (inherits(test, "try-error")) NA_real_ else test$p.value
      } else {
        NA_real_
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    adj_p = p.adjust(p_val, method = "BY"),
    label = ifelse(is.na(adj_p), "n/a", paste0("p_adj = ", signif(adj_p, 3)))
  )

# Annotation y-position
annotation_df <- expanded_counts %>%
  group_by(seurat_clusters_Tconv) %>%
  summarise(ann_y = max(prop_expanded, na.rm = TRUE) + 5, .groups = "drop") %>%
  left_join(p_values, by = "seurat_clusters_Tconv")

plot.tmp <- ggplot(expanded_counts, aes(x = stimulationFigures, y = prop_expanded)) +
  geom_boxplot(aes(fill = stimulationFigures), outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  ggh4x::facet_wrap2(
    ~seurat_clusters_Tconv, nrow = 1,
    strip = ggh4x::strip_themed(
      background_x = setNames(
        lapply(palRNAClustersTconv, function(clr) element_rect(fill = clr)),
        names(palRNAClustersTconv)
      )
    )
  ) +
  labs(
    x = "Stimulation",
    y = "Percentage of expanded Tconv cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Tconv Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  ) +
  scale_fill_manual(name = "Stimulation", values = palStimulation) +
  geom_text(
    data = annotation_df,
    aes(x = 1.5, y = ann_y, label = label),
    inherit.aes = FALSE, color = "black", size = 3
  )

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_PercentExpanded_clusterColors_donorInStimDenom_IARvsMicrobial.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```

```{r expansionProportionPlotsTconvsStimulationFacet}
# 1. Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# 2. Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# 3. Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# 4. Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# 5. Add expansion info to Seurat metadata
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv") %>%
  mutate(barcode = rownames(.))

# 6. Merge with TCR info
metadata_Tconv <- metadata_Tconv %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# 7. Calculate counts of expanded cells per group
expanded_counts <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(
    n_expanded = sum(expanded, na.rm = TRUE),
    n_total = n(),
    prop_expanded = n_expanded / n_total * 100,
    .groups = "drop"
  )

# 8. Plot: facet_wrap on stimulationFigures, color by seurat_clusters_Tconv
plot.tmp <- ggplot(expanded_counts, aes(x = seurat_clusters_Tconv, y = prop_expanded, fill = seurat_clusters_Tconv)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(
    x = "Tconv Cluster",
    y = "Percentage of expanded Tconv cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Tconv Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "white"),
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.text.x = element_text(angle = 30, hjust = 1)
  ) +
  scale_fill_manual(name = "Tconv Cluster", values = palRNAClustersTconv)

# 9. Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_PercentExpanded_clusterColors.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```


```{r expansionProportionPlotsTregsStimulationFacet}
# 1. Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# 2. Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# 3. Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# 4. Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# 5. Add expansion info to Seurat metadata
metadata_Treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg") %>%
  mutate(barcode = rownames(.))

# 6. Merge with TCR info
metadata_Treg <- metadata_Treg %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# 7. Calculate counts of expanded cells per group
expanded_counts <- metadata_Treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(
    n_expanded = sum(expanded, na.rm = TRUE),
    n_total = n(),
    prop_expanded = n_expanded / n_total * 100,
    .groups = "drop"
  )

# 8. Plot: facet_wrap on stimulationFigures, color by seurat_clusters_Treg
plot.tmp <- ggplot(expanded_counts, aes(x = seurat_clusters_Treg, y = prop_expanded, fill = seurat_clusters_Treg)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(
    x = "Treg Cluster",
    y = "Percentage of expanded Treg cells per donor (within cluster)",
    title = "Per-donor Breakdown of Expanded Treg Cells\nacross Stimulation and Clusters"
  ) +
  theme_classic() +
  theme(
    strip.background = element_rect(fill = "white"),
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.text.x = element_text(angle = 30, hjust = 1)
  ) +
  scale_fill_manual(name = "Treg Cluster", values = palRNAClustersTreg)

# 9. Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_PercentExpanded_clusterColors.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
```

```{r TCRStatistics}
# 1. Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# 2. Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# 3. Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# 4. Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Merge expanded status into Seurat metadata
expanded_status <- cleanTCRpairs.df %>%
  dplyr::select(barcode, expanded)

# cells together
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

# Add to Seurat metadata
seurat.tmp$expanded <- expanded_status$expanded[match(
  rownames(seurat.tmp@meta.data),
  expanded_status$barcode
)]

# Table of expanded vs not expanded by stimulation group
table_expanded <- table(
  seurat.tmp$stimulationFigures,
  seurat.tmp$expanded
)

# Calculate percentages
percent_expanded <- prop.table(table_expanded, 1)[, "TRUE"] * 100
percent_expanded

# For each pairwise comparison:
get_fisher_table <- function(group1, group2) {
  tab <- table(
    seurat.tmp$stimulationFigures,
    seurat.tmp$expanded
  )
  # Only keep rows for the two groups
  tab2 <- tab[c(group1, group2), ]
  # Remove NAs if present
  tab2 <- tab2[, c("TRUE", "FALSE"), drop = FALSE]
  return(tab2)
}

# Microbial vs Polyclonal
tab_micro_polyclonal <- get_fisher_table("Microbial", "Polyclonal")
fisher.test(tab_micro_polyclonal)

# IAR vs Polyclonal
tab_iar_polyclonal <- get_fisher_table("IAR", "Polyclonal")
fisher.test(tab_iar_polyclonal)

# Microbial vs IAR
tab_micro_iar <- get_fisher_table("Microbial", "IAR")
fisher.test(tab_micro_iar)

pvals <- c(
  fisher.test(tab_micro_polyclonal)$p.value,
  fisher.test(tab_iar_polyclonal)$p.value,
  fisher.test(tab_micro_iar)$p.value
)

# Bonferroni correction
p.adjust(pvals, method = "bonferroni")

# Benjamini-Hochberg correction
p.adjust(pvals, method = "BH")


# across-3 Chi-Squared test

# make a temporary cleanTCRpairs.df so that we don't screw up our data

cleanTCRpairs.df.tmp <- cleanTCRpairs.df

# 1. Create a clone ID in your TCR dataframe
cleanTCRpairs.df.tmp <- cleanTCRpairs.df.tmp %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# 2. Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df.tmp %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# 3. Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# 4. Annotate each cell as expanded or not
cleanTCRpairs.df.tmp <- cleanTCRpairs.df.tmp %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Merge expanded status into Seurat metadata
expanded_status <- cleanTCRpairs.df.tmp %>%
  dplyr::select(barcode, expanded)

# Subset cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

# Add expanded status to Seurat metadata
seurat.tmp$expanded <- expanded_status$expanded[match(
  rownames(seurat.tmp@meta.data),
  expanded_status$barcode
)]

# Create a contingency table of expanded vs not expanded by stimulation group
table_expanded <- table(
  seurat.tmp$stimulationFigures,
  seurat.tmp$expanded
)

# Perform Chi-Squared Test
chisq_test <- chisq.test(table_expanded)

# View the results
chisq_test




# version with 'pseudobulking'
# 1. Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# 2. Count how many cells per cloneID and donorIdFigures
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID, donorIdFigures) %>%
  summarise(n_cells = n(), .groups = "drop")

# 3. Mark expanded clones (more than 1 cell per donorIdFigures)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# 4. Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Merge expanded status into Seurat metadata
expanded_status <- cleanTCRpairs.df %>%
  dplyr::select(barcode, expanded, donorIdFigures)

# Subset cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

# Add expanded status to Seurat metadata using base R
expanded_vector <- expanded_status$expanded[match(rownames(seurat.tmp@meta.data), expanded_status$barcode)]
seurat.tmp@meta.data$expanded <- expanded_vector

# Aggregate data at the donor level
donor_expanded <- seurat.tmp@meta.data %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(expanded_count = sum(expanded, na.rm = TRUE), total_count = n(), .groups = "drop")

# Create a contingency table of expanded vs not expanded by stimulation group
table_expanded <- donor_expanded %>%
  pivot_wider(names_from = stimulationFigures, values_from = expanded_count, values_fill = list(expanded_count = 0))

# Ensure all entries are non-negative and finite
table_expanded[is.na(table_expanded)] <- 0

# Perform Chi-Squared Test
chisq_test <- chisq.test(as.matrix(table_expanded[, -1]))

# View the results
chisq_test




# End of across-3 Chi-Squared test

# Tregs
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg"))

# Add to Seurat metadata
seurat.tmp$expanded <- expanded_status$expanded[match(
  rownames(seurat.tmp@meta.data),
  expanded_status$barcode
)]

# Table of expanded vs not expanded by stimulation group
table_expanded <- table(
  seurat.tmp$stimulationFigures,
  seurat.tmp$expanded
)

# Calculate percentages
percent_expanded <- prop.table(table_expanded, 1)[, "TRUE"] * 100
percent_expanded

# For each pairwise comparison:
get_fisher_table <- function(group1, group2) {
  tab <- table(
    seurat.tmp$stimulationFigures,
    seurat.tmp$expanded
  )
  # Only keep rows for the two groups
  tab2 <- tab[c(group1, group2), ]
  # Remove NAs if present
  tab2 <- tab2[, c("TRUE", "FALSE"), drop = FALSE]
  return(tab2)
}

# Microbial vs Polyclonal
tab_micro_polyclonal <- get_fisher_table("Microbial", "Polyclonal")
fisher.test(tab_micro_polyclonal)

# IAR vs Polyclonal
tab_iar_polyclonal <- get_fisher_table("IAR", "Polyclonal")
fisher.test(tab_iar_polyclonal)

# Microbial vs IAR
tab_micro_iar <- get_fisher_table("Microbial", "IAR")
fisher.test(tab_micro_iar)

pvals <- c(
  fisher.test(tab_micro_polyclonal)$p.value,
  fisher.test(tab_iar_polyclonal)$p.value,
  fisher.test(tab_micro_iar)$p.value
)

# Bonferroni correction
p.adjust(pvals, method = "bonferroni")

# Benjamini-Hochberg correction
p.adjust(pvals, method = "BH")

comparisons <- c("Microbial vs Polyclonal", "IAR vs Polyclonal", "Microbial vs IAR")
results_df <- data.frame(
  Comparison = comparisons,
  P_value = pvals,
  P_adj_bonferroni = p.adjust(pvals, method = "bonferroni"),
  P_adj_BH = p.adjust(pvals, method = "BH")
)
print(results_df)



# Tconv
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Tconv"))

# Add to Seurat metadata
seurat.tmp$expanded <- expanded_status$expanded[match(
  rownames(seurat.tmp@meta.data),
  expanded_status$barcode
)]

# Table of expanded vs not expanded by stimulation group
table_expanded <- table(
  seurat.tmp$stimulationFigures,
  seurat.tmp$expanded
)

# Calculate percentages
percent_expanded <- prop.table(table_expanded, 1)[, "TRUE"] * 100
percent_expanded

# For each pairwise comparison:
get_fisher_table <- function(group1, group2) {
  tab <- table(
    seurat.tmp$stimulationFigures,
    seurat.tmp$expanded
  )
  # Only keep rows for the two groups
  tab2 <- tab[c(group1, group2), ]
  # Remove NAs if present
  tab2 <- tab2[, c("TRUE", "FALSE"), drop = FALSE]
  return(tab2)
}

# Microbial vs Polyclonal
tab_micro_polyclonal <- get_fisher_table("Microbial", "Polyclonal")
fisher.test(tab_micro_polyclonal)

# IAR vs Polyclonal
tab_iar_polyclonal <- get_fisher_table("IAR", "Polyclonal")
fisher.test(tab_iar_polyclonal)

# Microbial vs IAR
tab_micro_iar <- get_fisher_table("Microbial", "IAR")
fisher.test(tab_micro_iar)

pvals <- c(
  fisher.test(tab_micro_polyclonal)$p.value,
  fisher.test(tab_iar_polyclonal)$p.value,
  fisher.test(tab_micro_iar)$p.value
)

# Bonferroni correction
p.adjust(pvals, method = "bonferroni")

# Benjamini-Hochberg correction
p.adjust(pvals, method = "BH")

comparisons <- c("Microbial vs Polyclonal", "IAR vs Polyclonal", "Microbial vs IAR")
results_df <- data.frame(
  Comparison = comparisons,
  P_value = pvals,
  P_adj_bonferroni = p.adjust(pvals, method = "bonferroni"),
  P_adj_BH = p.adjust(pvals, method = "BH")
)
print(results_df)



# Version with per-donor breakdowns:
# Create a clone ID in your TCR dataframe
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(cloneID = paste(fullLengthNTa, fullLengthNTb, sep = "_"))

# Count how many cells per cloneID
clone_counts <- cleanTCRpairs.df %>%
  group_by(cloneID) %>%
  summarise(n_cells = n(), .groups = "drop")

# Mark expanded clones (more than 1 cell)
expanded_clones <- clone_counts %>%
  filter(n_cells > 1) %>%
  pull(cloneID)

# Annotate each cell as expanded or not
cleanTCRpairs.df <- cleanTCRpairs.df %>%
  mutate(expanded = cloneID %in% expanded_clones)

# Add expansion info to Seurat metadata
metadata.tmp <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType %in%  c("Treg", "Tconv")) %>%
  mutate(barcode = rownames(.))

# Merge with TCR info
metadata.tmp <- metadata.tmp %>%
  left_join(cleanTCRpairs.df %>% select(barcode, expanded), by = "barcode") %>%
  mutate(expanded = ifelse(is.na(expanded), FALSE, expanded))

# 1. Get all unique donors, stimulations, and clusters
all_donors <- unique(metadata.tmp$donorIdFigures)
all_stims <- unique(metadata.tmp$stimulationFigures)
all_clusters <- unique(metadata.tmp$seurat_clusters_DS)

# 2. Create all combinations
all_combos <- expand.grid(
  donorIdFigures = all_donors,
  stimulationFigures = all_stims,
  seurat_clusters_DS = all_clusters,
  stringsAsFactors = FALSE
)

# 3. Calculate total Treg cells per donor+stimulation
total_per_donor_stim <- metadata.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# Calculate expanded cells per donor+stim
expanded_per_donor_stim <- metadata.tmp %>%
  filter(expanded) %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(n_expanded = n(), .groups = "drop")

# Merge and calculate proportion
expanded_summary <- total_per_donor_stim %>%
  left_join(expanded_per_donor_stim, by = c("donorIdFigures", "stimulationFigures")) %>%
  mutate(n_expanded = ifelse(is.na(n_expanded), 0, n_expanded),
    prop_expanded = n_expanded / total)


kruskal_res <- kruskal.test(prop_expanded ~ stimulationFigures, data = expanded_summary)
p_value <- kruskal_res$p.value
```

```{r proportionOfClustersInStimulationsStudyGroupSplitCalculation}
# Subset to Treg cells
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg")

# 1. Compute counts per donor, stimulation, studyGroup, and Treg cluster
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, studyGroup, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Treg cells per stimulation within each studyGroup (ignoring donor)
stim_total <- metadata_treg %>%
  group_by(studyGroup, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the (studyGroup X stimulation) total
prop_df <- left_join(counts_df, stim_total, by = c("studyGroup", "stimulationFigures")) %>%
  mutate(percentage = (count / total) * 100)

# 4. Create the plot: In each stimulation facet, the boxplot and donor points (dodged by studyGroup)
#    now represent percentages as computed within each studyGroup.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Treg, y = percentage)) +
  geom_boxplot(aes(fill = studyGroup), position = position_dodge(width = 0.8), outlier.shape = NA, alpha = 0.5) +
  geom_jitter(aes(color = donorIdFigures), position = position_dodge(width = 0.8), size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Treg Cluster", y = "Percentage (within studyGroup)",
    title = "Per-donor Breakdown of Treg Clusters by Stimulation\n(percentages computed within studyGroup)") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_fill_manual(values = palStudyGroup) +
  scale_color_manual(values = palDonorId)

# Save the updated plot:
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_Percent_ByStudyGroup.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulationsControlOnly}
# plot, on a per-donor-basis, the percentage of each seurat_clusters_Treg per stimulationFigures
# Subset to Treg cells (adjust if needed)
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg") %>%
  filter(studyGroup == "Control")

# 1. Compute counts per donor, stimulation, and Treg cluster
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Treg cells per stimulation (ignoring donor)
stim_total <- metadata_treg %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Treg) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Plot the results: Facet by stimulation (3 subplots), x-axis is Treg cluster,
# and each donors percentage contribution (relative to the stimulation total) is shown.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Treg, y = percentage)) +
  geom_boxplot(outlier.shape = NA, fill = "grey90") +
  geom_jitter(aes(color = donorIdFigures), width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Treg Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Treg Clusters by Stimulation, Controls") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_color_manual(values = palDonorId)

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_Percent_controlOnly.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulationsT1DOnly}
# plot, on a per-donor-basis, the percentage of each seurat_clusters_Treg per stimulationFigures
# Subset to Treg cells (adjust if needed)
metadata_treg <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Treg") %>%
  filter(studyGroup == "T1D")

# 1. Compute counts per donor, stimulation, and Treg cluster
counts_df <- metadata_treg %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Treg) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Treg cells per stimulation (ignoring donor)
stim_total <- metadata_treg %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Treg) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Plot the results: Facet by stimulation (3 subplots), x-axis is Treg cluster,
# and each donors percentage contribution (relative to the stimulation total) is shown.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Treg, y = percentage)) +
  geom_boxplot(outlier.shape = NA, fill = "grey90") +
  geom_jitter(aes(color = donorIdFigures), width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Treg Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Treg Clusters by Stimulation, T1D") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_color_manual(values = palDonorId)

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TregClusterBreakdown_PerStim_Percent_T1DOnly.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulations}
# plot, on a per-donor-basis, the percentage of each seurat_clusters_Tconv per stimulationFigures
# Subset to Tconv cells (adjust if needed)
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv")

# 1. Compute counts per donor, stimulation, and Tconv cluster
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Tconv cells per stimulation (ignoring donor)
stim_total <- metadata_Tconv %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Plot the results: Facet by stimulation (3 subplots), x-axis is Tconv cluster,
# and each donors percentage contribution (relative to the stimulation total) is shown.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Tconv, y = percentage)) +
  geom_boxplot(outlier.shape = NA, fill = "grey90") +
  geom_jitter(aes(color = donorIdFigures), width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Tconv Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Tconv Clusters by Stimulation") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_color_manual(values = palDonorId)

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_Percent.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulationsStudyGroupSplit}
# Subset to Tconv cells
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv")

# 1. Compute counts per donor, stimulation, and Tconv cluster
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# If studyGroup is unique per donor, add studyGroup to counts_df
donor_study <- metadata_Tconv %>%
  distinct(donorIdFigures, studyGroup)
counts_df <- left_join(counts_df, donor_study, by = "donorIdFigures")

# 2. Compute total number of Tconv cells per stimulation (ignoring donor)
stim_total <- metadata_Tconv %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Create a plot that splits per-donor dots and boxplots by studyGroup within each Tconv cluster.
#    We use position_dodge() to separate the studyGroup groups.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Tconv, y = percentage, fill = studyGroup)) +
  geom_boxplot(position = position_dodge(width = 0.8), outlier.shape = NA, alpha = 0.5) +
  geom_jitter(aes(color = donorIdFigures),
    position = position_dodge(width = 0.8),
    size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Tconv Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Tconv Clusters by Stimulation\n(split by studyGroup)") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_fill_manual(values = palStudyGroup) +
  scale_color_manual(values = palDonorId)

# Save the updated plot:
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_Percent_byStudyGroupTogether.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulationsStudyGroupSplitCalculation}
# Subset to Tconv cells
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv")

# 1. Compute counts per donor, stimulation, studyGroup, and Tconv cluster
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, studyGroup, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Tconv cells per stimulation within each studyGroup (ignoring donor)
stim_total <- metadata_Tconv %>%
  group_by(studyGroup, stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the (studyGroup X stimulation) total
prop_df <- left_join(counts_df, stim_total, by = c("studyGroup", "stimulationFigures")) %>%
  mutate(percentage = (count / total) * 100)

# 4. Create the plot: In each stimulation facet, the boxplot and donor points (dodged by studyGroup)
#    now represent percentages as computed within each studyGroup.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Tconv, y = percentage)) +
  geom_boxplot(aes(fill = studyGroup), position = position_dodge(width = 0.8), outlier.shape = NA, alpha = 0.5) +
  geom_jitter(aes(color = donorIdFigures), position = position_dodge(width = 0.8), size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Tconv Cluster", y = "Percentage (within studyGroup)",
    title = "Per-donor Breakdown of Tconv Clusters by Stimulation\n(percentages computed within studyGroup)") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_fill_manual(values = palStudyGroup) +
  scale_color_manual(values = palDonorId)

# Save the updated plot:
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_Percent_ByStudyGroup.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulationsControlOnly}
# plot, on a per-donor-basis, the percentage of each seurat_clusters_Tconv per stimulationFigures
# Subset to Tconv cells (adjust if needed)
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv") %>%
  filter(studyGroup == "Control")

# 1. Compute counts per donor, stimulation, and Tconv cluster
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Tconv cells per stimulation (ignoring donor)
stim_total <- metadata_Tconv %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Plot the results: Facet by stimulation (3 subplots), x-axis is Tconv cluster,
# and each donors percentage contribution (relative to the stimulation total) is shown.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Tconv, y = percentage)) +
  geom_boxplot(outlier.shape = NA, fill = "grey90") +
  geom_jitter(aes(color = donorIdFigures), width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Tconv Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Tconv Clusters by Stimulation, Controls") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_color_manual(values = palDonorId)

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_Percent_controlOnly.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r proportionOfClustersInStimulationsT1DOnly}
# plot, on a per-donor-basis, the percentage of each seurat_clusters_Tconv per stimulationFigures
# Subset to Tconv cells (adjust if needed)
metadata_Tconv <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType == "Tconv") %>%
  filter(studyGroup == "T1D")

# 1. Compute counts per donor, stimulation, and Tconv cluster
counts_df <- metadata_Tconv %>%
  group_by(donorIdFigures, stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(count = n(), .groups = "drop")

# 2. Compute total number of Tconv cells per stimulation (ignoring donor)
stim_total <- metadata_Tconv %>%
  group_by(stimulationFigures) %>%
  summarise(total = n(), .groups = "drop")

# 3. Join and calculate percentage relative to the stimulation total
prop_df <- left_join(counts_df, stim_total, by = "stimulationFigures") %>%
  mutate(percentage = (count / total) * 100)

# (Optional) Verify that for each stimulation and cluster, donor contributions sum to the overall percentage:
prop_sum <- prop_df %>%
  group_by(stimulationFigures, seurat_clusters_Tconv) %>%
  summarise(sum_perc = sum(percentage))
print(prop_sum)

# 4. Plot the results: Facet by stimulation (3 subplots), x-axis is Tconv cluster,
# and each donors percentage contribution (relative to the stimulation total) is shown.
plot.tmp <- ggplot(prop_df, aes(x = seurat_clusters_Tconv, y = percentage)) +
  geom_boxplot(outlier.shape = NA, fill = "grey90") +
  geom_jitter(aes(color = donorIdFigures), width = 0.2, size = 2, alpha = 0.8) +
  facet_wrap(~stimulationFigures, nrow = 1) +
  labs(x = "Tconv Cluster", y = "Percentage of Stimulation",
    title = "Per-donor Breakdown of Tconv Clusters by Stimulation, T1D") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "white")) +
  scale_color_manual(values = palDonorId)

# Save the plot
png(file.path(plotDir, paste0(filenameSuffix, "TconvClusterBreakdown_PerStim_Percent_T1DOnly.png")),
  height = 5.5, width = 8, units = "in", res = 600)
print(plot.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r RNAClusterStimulationOccupancyStatisticsDownsampled}
# Subset to only Treg and Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))
# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Ensure these columns are factors
metadata.tmp$seurat_clusters_DS <- as.factor(metadata.tmp$seurat_clusters_DS)
metadata.tmp$stimulationFigures <- as.factor(metadata.tmp$stimulationFigures)
# donorIdFigures indicates donor identity

# ------------------------------
# A. Downsampling Microbial cells
# ------------------------------
# Separate IAR and Microbial cells
metadata_IAR <- metadata.tmp %>% filter(stimulationFigures == "IAR")
metadata_Micro <- metadata.tmp %>% filter(stimulationFigures == "Microbial")

# Get the number of IAR cells per donor (ignoring cluster)
iar_counts <- metadata_IAR %>%
  group_by(donorIdFigures) %>%
  summarize(n_IAR = n(), .groups = "drop")

# For each donor, downsample the Microbial cells 100 times to match its IAR count (if possible)
set.seed(6022)
micro_ds <- metadata_Micro %>%
  group_by(donorIdFigures) %>%
  nest() %>%
  left_join(iar_counts, by = "donorIdFigures") %>%
  mutate(
    downsampled = map2(data, n_IAR, ~ {
      df <- .x
      n_sample <- .y
      # In case there are fewer Microbial cells than IAR, use all available
      n_sample <- min(n_sample, nrow(df))
      replicate(100,
        {
          if (n_sample > 0) {
            sampled <- df %>% sample_n(n_sample)
            # Count cells per RNA cluster for this sampling
            sampled %>% group_by(seurat_clusters_DS) %>%
              summarize(cell_count = n(), .groups = "drop")
          } else {
            # Return zero count if no cells to sample
            data.frame(seurat_clusters_DS = NA, cell_count = 0)
          }
        },
        simplify = FALSE)
    })
  ) %>%
  mutate(
    avg_counts = map(downsampled, ~ bind_rows(.x) %>%
      group_by(seurat_clusters_DS) %>%
      summarize(cell_count = mean(cell_count), .groups = "drop"))
  ) %>%
  select(donorIdFigures, avg_counts)

# ------------------------------
# B. Compute Cluster Counts
# ------------------------------
# Actual IAR cluster counts per donor
iar_cluster_counts <- metadata_IAR %>%
  group_by(donorIdFigures, seurat_clusters_DS) %>%
  summarize(cell_count = n(), .groups = "drop") %>%
  mutate(stimulationFigures = "IAR")

# Downsampled (average) Microbial counts per donor
micro_cluster_counts_ds <- micro_ds %>%
  unnest(avg_counts) %>%
  filter(!is.na(seurat_clusters_DS)) %>%
  mutate(stimulationFigures = "Microbial")

# Combine IAR and downsampled Microbial counts
cluster_counts_new <- bind_rows(iar_cluster_counts, micro_cluster_counts_ds)

# ------------------------------
# C. Calculate Occupancy Proportions
# For each RNA cluster (across all donors), compute occupancy = count/sum(count)
# ------------------------------
prop_df <- cluster_counts_new %>%
  group_by(seurat_clusters_DS) %>%
  mutate(occupancy = cell_count / sum(cell_count)) %>%
  ungroup()

# ------------------------------
# D. Statistical Testing (t-test comparing IAR vs Microbial per cluster)
# Only perform test if both groups have 2 observations.
# ------------------------------
p_list <- lapply(unique(prop_df$seurat_clusters_DS), function(cl) {
  df_cl <- prop_df %>%
    filter(seurat_clusters_DS == cl, stimulationFigures %in% c("IAR", "Microbial"))
  if (length(unique(df_cl$stimulationFigures)) == 2) {
    group_counts <- df_cl %>% group_by(stimulationFigures) %>%
      summarize(n = n(), .groups = "drop")
    if (min(group_counts$n) >= 2) {
      test <- t.test(occupancy ~ stimulationFigures, data = df_cl)
      data.frame(seurat_clusters_DS = cl, raw_p = test$p.value)
    } else {
      data.frame(seurat_clusters_DS = cl, raw_p = NA)
    }
  } else {
    data.frame(seurat_clusters_DS = cl, raw_p = NA)
  }
})
p_df <- do.call(rbind, p_list)
p_df <- p_df %>%
  mutate(adj_p = p.adjust(raw_p, method = "bonferroni"),
    label = paste0("p_adj=", signif(adj_p, 3)))

# ------------------------------
# E. Plotting
# Restrict to IAR and Microbial for plot.
# ------------------------------
plot_df <- prop_df %>% filter(stimulationFigures %in% c("IAR", "Microbial"))
annotation_y <- max(plot_df$occupancy) * 1.05
occupancy_plot <- ggplot(plot_df, aes(x = stimulationFigures, y = occupancy, fill = stimulationFigures)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(alpha = 0.6) +
  scale_fill_manual(values = palStimulation) +
  labs(x = "Stimulation (IAR and Microbial)", y = "Occupancy Proportion (per cluster)",
    title = "Cluster Occupancy Proportions per Donor with Downsampling") +
  theme_minimal() +
  facet_wrap(~seurat_clusters_DS) +
  geom_text(
    data = p_df,
    mapping = aes(x = 1.5, y = annotation_y, label = label),
    inherit.aes = FALSE,
    size = 3
  )

png(file.path(plotDir,
  paste0(filenameSuffix, "clusterOccupancyBoxPlotPerClusterStimulationIARMicrobialDownsampled.png")),
height = 5.5,
width = 8,
units = "in",
res = 600)

print(occupancy_plot)
dev.off()
rm_tmp(ask = FALSE)
```

```{r clusterProportionPlotsWithCellTypeCalls}
nClust <- length(table(seuratQCMergedCleaned@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratQCMergedCleaned@meta.data$studyGroup <- as.factor(seuratQCMergedCleaned@meta.data$studyGroup)
seuratQCMergedCleaned@meta.data$stimulationFigures <- as.factor(seuratQCMergedCleaned@meta.data$stimulationFigures)
seuratQCMergedCleaned@meta.data$donorIdFigures <- as.factor(seuratQCMergedCleaned@meta.data$donorIdFigures)
seuratQCMergedCleaned@meta.data$seurat_clusters <- as.factor(seuratQCMergedCleaned@meta.data$seurat_clusters_DS)
seuratQCMergedCleaned@meta.data$cellType <- as.factor(seuratQCMergedCleaned$cellType)
seuratQCMergedCleaned@meta.data$cellTypistCalling <- as.factor(seuratQCMergedCleaned$cellTypistCalling)

# Extract metadata
metadata.tmp <- seuratQCMergedCleaned@meta.data

# all together now
# Create the three plots
plot1.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot2.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot3.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot4.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = cellType)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "TotalSeq cellType") +
  scale_fill_manual(values = palCellType) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot5.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1.tmp, plot2.tmp, plot3.tmp, plot4.tmp, plot5.tmp, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_cellTypeCalls.pdf")), height = 7, width = 7)
print(combined_plot)
dev.off()

# now just the CellTypist calling
nClust <- length(table(seuratQCMergedCleaned@meta.data$seurat_clusters_DS))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Extract metadata
metadata.tmp <- seuratQCMergedCleaned@meta.data

# make the plot
plot.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme(
    axis.title = element_text(size = 8),
    axis.text = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.text = element_text(size = 8),
    strip.text = element_text(size = 8)
  ) +

  pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_cellTypistProportionsInSeuratClusters.pdf")), height = 2.5, width = 7)
print(plot.tmp)
dev.off()

# now just the TotalSeq gating calling
nClust <- length(table(seuratQCMergedCleaned@meta.data$seurat_clusters_DS))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Extract metadata
metadata.tmp <- seuratQCMergedCleaned@meta.data

# Rename 'Other' to 'Not Ag-specific' in cellTypeTotalSeq
metadata.tmp$cellTypeTotalSeq <- as.character(metadata.tmp$cellTypeTotalSeq)
metadata.tmp$cellTypeTotalSeq[metadata.tmp$cellTypeTotalSeq == "Other"] <- "Not Ag-specific"
metadata.tmp$cellTypeTotalSeq <- factor(metadata.tmp$cellTypeTotalSeq, levels = c("Treg", "Tconv", "Not Ag-specific"))

palCellTypeTotalSeq <- c("Treg" = "blue", "Tconv" = "red", "Not Ag-specific" = "gray")

# make the plot
plot.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = cellTypeTotalSeq)) +
  # geom_bar(position = "fill") +
  geom_bar(position = position_fill(reverse = TRUE)) +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "TotalSeq Gating") +
  scale_fill_manual(values = palCellTypeTotalSeq) +
  theme(
    axis.title = element_text(size = 8),
    axis.text = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.text = element_text(size = 8),
    strip.text = element_text(size = 8)
  ) +

  pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_TotalSeqGatingProportionsInSeuratClusters.pdf")), height = 2.5, width = 7)
print(plot.tmp)
dev.off()


# all together now (POSTER
fontSize <- 10

# Create the three plots
plot1 <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  scale_fill_manual(values = palStudyGroup) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot2 <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot3 <- ggplot(metadata.tmp, aes(x = seurat_clusters_DS, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v", rel_heights = c(1, 1, 1.2))

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_poster.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()
rm_tmp(ask = FALSE)
```

```{r TregCallingMethodsVennDiagram}
# venn diagram with cells called Treg in:
# seuratQCMergedCleaned$cellType
# seuratQCMergedCleaned@meta.data$cellTypist
# and seuratQCMergedCleanedDS@meta.data$seurat_clusters 3 and 4


# Extract cell barcodes for Treg in seuratQCMergedCleaned$cellType
treg_TotalSeq <- names(seuratQCMergedCleaned$cellType[seuratQCMergedCleaned$cellType == "Treg"])

# Extract cell barcodes for Treg in seuratQCMergedCleaned@meta.data$cellTypist
treg_cellTypist <- rownames(seuratQCMergedCleaned@meta.data[seuratQCMergedCleaned@meta.data$cellTypistCalling == "Treg", ])

# Extract cell barcodes for clusters 3 and 4 in seuratQCMergedCleanedDS@meta.data$seurat_clusters
treg_clusters <- rownames(seuratQCMergedCleanedDS@meta.data[seuratQCMergedCleanedDS@meta.data$seurat_clusters %in% c(3, 4), ])

# Extract cell barcodes for cells that are Tregs according to the P390 module
treg_P390 <- names(seuratQCMergedCleaned$cellTypeP390[seuratQCMergedCleaned$cellTypeP390 == "Treg"])

# 4 methods
# Create a list of these sets
venn_list <- list(
  TotalSeq = treg_TotalSeq,
  CellTypist = treg_cellTypist,
  Clusters = treg_clusters,
  P390 = treg_P390
)

# start pdf printing
pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregCalling4MethodsVenn.pdf")),
height = 5,
width = 7)

# Generate the Venn diagram using ggvenn
venn.plot.tmp <- ggvenn(venn_list, fill_color = c("red", "green", "blue", "Orange"))

# Print the venn plot
print(venn.plot.tmp)
dev.off()

# 3 methods
# Create a list of these sets
venn_list <- list(
  TotalSeq = treg_TotalSeq,
  CellTypist = treg_cellTypist,
  Clusters = treg_clusters
)

# start pdf printing
pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregCalling3MethodsVenn.pdf")),
height = 5,
width = 7)

# Generate the Venn diagram using ggvenn
venn.plot.tmp <- ggvenn(venn_list, fill_color = c("red", "green", "blue"))

# Print the venn plot
print(venn.plot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r cellTypeAssignmentCITEseqAlluvialPlot}
library(ggalluvial)

# Extract cell type assignments
cellType.tmp <- seuratQCMergedCleaned$cellType
cellTypeDSB.tmp <- seuratQCMergedCleaned$cellTypeDSB

# Create a data frame with cell barcodes and their corresponding cell type assignments
cellAssignments.tmp <- data.frame(
  cellBarcode = names(cellType.tmp),
  cellTypeLogNorm = cellType.tmp,
  cellTypeDSB = cellTypeDSB.tmp[names(cellType.tmp)]
)

# Count the number of cells in each category
cellCounts.tmp <- cellAssignments.tmp %>%
  group_by(cellTypeLogNorm, cellTypeDSB) %>%
  summarise(count = n())

# Print the cell counts to verify
print(cellCounts.tmp)

png(file.path(plotDir,
  paste0(filenameSuffix, "logNormVsDSBNormAlluvialPlot.png")),
height = 5,
width = 7,
units = "in",
res = 600)

# Create an alluvial plot
alluvialPlot.tmp <- ggplot(cellCounts.tmp,
  aes(axis1 = cellTypeLogNorm, axis2 = cellTypeDSB, y = count)) +
  geom_flow(aes(fill = cellTypeLogNorm), stat = "alluvium") +
  geom_stratum(alpha = .5) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  scale_x_discrete(limits = c("cellTypeLogNorm", "cellTypeDSB"), expand = c(0.15, 0.05)) +
  labs(title = "Alluvial Plot of Cell Type Assignments",
    x = "Method",
    y = "Number of Cells") +
  theme_minimal()

# Print the alluvial plot
print(alluvialPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r cellTypeAssignmentLogNormVsCellTypistAlluvialPlot}
library(ggalluvial)

# Extract cell type assignments
cellType.tmp <- seuratQCMergedCleaned$cellType
# Extract cell type assignments from CellTypist
cellTypeCellTypist.tmp <- seuratQCMergedCleaned@meta.data$cellTypistCalling

# Ensure cell barcodes are assigned as names
names(cellTypeCellTypist.tmp) <- rownames(seuratQCMergedCleaned@meta.data)

# Verify the table
table(cellTypeCellTypist.tmp)

# Create a data frame with cell barcodes and their corresponding cell type assignments
cellAssignments.tmp <- data.frame(
  cellBarcode = names(cellType.tmp),
  cellTypeLogNorm = cellType.tmp,
  cellTypeCellTypist = cellTypeCellTypist.tmp[names(cellType.tmp)]
)

# Count the number of cells in each category
cellCounts.tmp <- cellAssignments.tmp %>%
  group_by(cellTypeLogNorm, cellTypeCellTypist) %>%
  summarise(count = n())

# Print the cell counts to verify
print(cellCounts.tmp)

# Ensure the factors are correctly ordered
cellCounts.tmp$cellTypeLogNorm <- factor(cellCounts.tmp$cellTypeLogNorm, levels = unique(cellCounts.tmp$cellTypeLogNorm))
cellCounts.tmp$cellTypeCellTypist <- factor(cellCounts.tmp$cellTypeCellTypist, levels = unique(cellCounts.tmp$cellTypeCellTypist))

png(file.path(plotDir,
  paste0(filenameSuffix, "logNormVsCellTypistAlluvialPlot.png")),
height = 5,
width = 7,
units = "in",
res = 600)

# Create an alluvial plot
alluvialPlot.tmp <- ggplot(cellCounts.tmp,
  aes(axis1 = cellTypeLogNorm, axis2 = cellTypeCellTypist, y = count)) +
  geom_flow(aes(fill = cellTypeLogNorm), stat = "alluvium") +
  geom_stratum(alpha = .5) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  scale_x_discrete(limits = c("cellTypeLogNorm", "cellTypeCellTypist"), expand = c(0.15, 0.05)) +
  labs(title = "TotalSeq (logNorm) vs CellTypist",
    x = "Method",
    y = "Number of Cells") +
  theme_minimal()

# Print the alluvial plot
print(alluvialPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r clusterTregCellsSeparately}
# make a subset seurat object that only contains the cells where $cellType == "Treg"
seuratTreg <- subset(seuratQCMergedCleanedDS, subset = cellType == "Treg")

# now subset down to the cells in RNAseq clusters 3 and 4
seuratTreg <- subset(seuratQCMergedCleanedDS, subset = seurat_clusters %in% c("3", "4"))

# save old clusters
seuratTreg@meta.data$seuratClustersAllCellsDS <- seuratTreg@meta.data$seurat_clusters

# set pool as a factor
seuratTreg@meta.data$pool <- as.factor(seuratTreg@meta.data$pool)

# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratTreg) <- "RNA"
seuratTreg <- SeuratObject::JoinLayers(seuratTreg, layers = c("RNA"))
seuratTreg <- NormalizeData(object = seuratTreg,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratTreg <- NormalizeData(object = seuratTreg,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratTreg <- NormalizeData(object = seuratTreg,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  assay = "RNA")

# seuratTreg <- NormalizeData(object = seuratTreg, verbose = FALSE)
seuratTreg <- FindVariableFeatures(object = seuratTreg,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratTreg <- ScaleData(object = seuratTreg, verbose = FALSE)
seuratTreg <- RunPCA(object = seuratTreg, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratTreg)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 7, 14, 16, 18, 20),
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5)
)

# the size of these vectors largely determines the cost of this function in walltime
min.dist.vector <-  c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
n_neighbors.vector <- c(5, 20, 30, 40, 50)

startTime <- Sys.time()

resultTreg <- optimizeRNAseqClustering(seuratTreg,
  hyperParamGridPCA.df,
  min.dist.vector,
  n_neighbors.vector,
  maxNClusters = 6)

endTime <- Sys.time()
timeElapsed <- endTime - startTime
print(timeElapsed)

# Extract the data frames from the result
hyperParamGridOptClusterAndUMAP.df <- resultTreg$hyperParamGridOptClusterAndUMAP.df
hyperParamGridClusterOnly.df <- resultTreg$hyperParamGridClusterOnly.df

write.xlsx(hyperParamGridOptClusterAndUMAP.df, file = file.path(dataOutputDir, "20241210_RNA_clustering_TregOnly_hyperParamGrid.xlsx"))

set.seed(6022)
seuratTreg <- FindNeighbors(seuratTreg, dims = 1:16)
seuratTreg <- FindClusters(seuratTreg, resolution = 0.6)


# Optimize UMAP hyperparameters with scDEED
K_ <- 16 # number of PCs

start_time.tmp <- Sys.time()

scDEEDResult <- scDEED(seuratTreg, # input Seurat object (must have UMAP or t-SNE already run)
  K = K_, # number of PCs
  reduction.method = "umap", # 'umap' or 'tsne'
  min.dist =  c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), # c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), # 0.4, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
  n_neighbors = c(5, 20, 30, 40, 50), # c(5, 20, 30, 40, 50), # 5, # c(5, 20, 30, 40, 50), #scDEED defaults. Seurat default is 30.
  similarity_percent = 0.5, # default
  dubious_cutoff = 0.05, # default
  trustworthy_cutoff = 0.95) # default

end_time.tmp <- Sys.time()

time_elapsed <- end_time.tmp - start_time.tmp
print(time_elapsed) # Time difference of 19.69495 mins

rm_tmp(ask = FALSE)

# add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1

# utilizing scDEED output
min(scDEEDResult$num_dubious$number_dubious_cells) # 437 # 26 with opt
opt <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells))
m <- scDEEDResult$num_dubious$min.dist[opt] # 0.1 # 0.3 #0.5
n <- scDEEDResult$num_dubious$n_neighbors[opt] # 30 (only value tested) # 5 #5

dubious_cells <- scDEEDResult$full_results$dubious_cells[opt]
dubious_cells <- as.numeric(strsplit(dubious_cells, ",")[[1]])
trustworthy_cells <- scDEEDResult$full_results$trustworthy_cells[opt]
trustworthy_cells <- as.numeric(strsplit(trustworthy_cells, ",")[[1]])
set.seed(6022)
SeuratUMAPscDEEDOpt <- RunUMAP(seuratTreg,
  dims = 1:K_,
  min.dist = m,
  n.neighbors = n)
# seed.use = 100)

# match up the dubious/trustworthy lists with the seurat data
rownames_seurat <- rownames(SeuratUMAPscDEEDOpt@meta.data)
rownames_dubious <- rownames_seurat[dubious_cells]
rownames_trustworthy <- rownames_seurat[trustworthy_cells]

designation <- rep("intermediate", length(rownames_seurat))

designation[rownames_seurat %in% rownames_dubious] <- "dubious"
designation[rownames_seurat %in% rownames_trustworthy] <- "trustworthy"

SeuratUMAPscDEEDOpt@meta.data$designation <- designation
# end of scDEED

set.seed(6022)
seuratTreg <- RunUMAP(object = seuratTreg,
  reduction = "pca",
  return.model = TRUE,
  dims = 1:16,
  n.neighbors = 5, # 30
  min.dist = 0.7) # 0.1

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName <- "seurat_clusters_Treg"

# Add metadata to the Seurat object
seuratTreg <- seuratTreg %>%
  Seurat::AddMetaData(Idents(seuratTreg), col.name = clusterName)

# Set the identifiers
Idents(seuratTreg) <- seuratTreg@meta.data[[clusterName]]

# Ensure data layers are joined
seuratTreg <- JoinLayers(seuratTreg)

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName)]] <-
  FindAllMarkers(seuratTreg, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName)]])

# palRNAClusters <-
#   big_colorblind_pal(
#     n_distinct(seuratTreg@meta.data[[clusterName]]),
#     shuffle_colors = TRUE,
#     drop_yellow = TRUE, drop_black = TRUE) %>%
#   setNames(sort(unique(seuratTreg@meta.data[[clusterName]])))

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratTreg@meta.data[[clusterName]])

# Set up color palette for Treg clusters
palRNAClustersTreg <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratTreg@meta.data[[clusterName]])))

# palRNAClustersTreg <- c(
#   "0" = "#87CEEB",
#   "1" = "#1E90FF",
#   "2" = "#4682B4",
#   "3" = "#0000CD"
# )
```

```{r clusterTconvSeparately}
# make a subset seurat object that only contains the cells where $cellType == "Treg"
seuratTconv <- subset(seuratQCMergedCleanedDS, subset = cellType == "Tconv")

# now subset down to the cells in RNAseq clusters 3 and 4
seuratTconv <- subset(seuratQCMergedCleanedDS, subset = seurat_clusters %in% c("0", "1", "2", "5", "6"))

# save old clusters
seuratTconv@meta.data$seuratClustersAllCellsDS <- seuratTconv@meta.data$seurat_clusters

# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratTconv) <- "RNA"
seuratTconv <- SeuratObject::JoinLayers(seuratTconv, layers = c("RNA"))
seuratTconv <- NormalizeData(object = seuratTconv,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratTconv <- NormalizeData(object = seuratTconv,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratTconv <- NormalizeData(object = seuratTconv,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  assay = "RNA")

# seuratTconv <- NormalizeData(object = seuratTconv, verbose = FALSE)
seuratTconv <- FindVariableFeatures(object = seuratTconv,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratTconv <- ScaleData(object = seuratTconv, verbose = FALSE)
seuratTconv <- RunPCA(object = seuratTconv, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratTconv)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 8, 12, 14, 20), # these values were chosen after examining the elbow plot.
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5) # these values were chosen somewhat arbitrarily
)

# the size of these vectors largely determines the cost of this function in walltime
min.dist.vector <-  c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
n_neighbors.vector <- c(5, 20, 30, 40, 50)

# testing
startTime <- Sys.time()

resultTconv <- optimizeRNAseqClustering(seuratTconv,
  hyperParamGridPCA.df,
  min.dist.vector,
  n_neighbors.vector,
  maxNClusters = 10,
  minNClusters = 5) # because we're starting with 5

endTime <- Sys.time()
timeElapsed <- endTime - startTime
print(timeElapsed)

# Extract the data frames from the result
hyperParamGridOptClusterAndUMAP.df <- resultTconv$hyperParamGridOptClusterAndUMAP.df
hyperParamGridClusterOnly.df <- resultTconv$hyperParamGridClusterOnly.df

write.xlsx(hyperParamGridOptClusterAndUMAP.df, file = file.path(dataOutputDir, "20241210_RNA_clustering_TconvOnly_hyperParamGrid.xlsx"))

# TODO automate
# process Tconv cells for each different nCluster of interest
set.seed(6022)
seuratTconv <- FindNeighbors(seuratTconv, dims = 1:14)
seuratTconv <- FindClusters(seuratTconv, resolution = 0.4)

set.seed(6022)
seuratTconv <- RunUMAP(object = seuratTconv, reduction = "pca",
  reduction.key = "umap_",
  return.model = TRUE,
  dims = 1:14,
  n.neighbors = 40,
  min.dist = 1)


# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName <- paste0("seurat_clusters_Tconv")

# Add metadata to the Seurat object
seuratTconv <- seuratTconv %>%
  Seurat::AddMetaData(Idents(seuratTconv), col.name = clusterName)

# Set the identifiers
Idents(seuratTconv) <- seuratTconv@meta.data[[clusterName]]

# Ensure data layers are joined
seuratTconv <- JoinLayers(seuratTconv)

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratTconv@meta.data[[clusterName]])

# Get the "ggsci::uniform_startrek" palette and adjust it
# palRNAClustersTconv <- paletteer_d("basetheme::royal", n = num_clusters) %>% # paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
#   sample() %>%  # Shuffle colors
#   .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
#   setNames(sort(unique(seuratTconv@meta.data[[clusterName]])))

palRNAClustersTconv <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratTconv@meta.data[[clusterName]])))

# palRNAClustersTconv <- c(
#   "0" = "#67001FFF",
#   "1" = "#B2182BFF",
#   "2" = "#D6604DFF",
#   "3" = "#F4A582FF",
#   "4" = "#F0E442FF",
#   "5" = "#f68e06"
# )
```

```{r referenceMappingInferNonDSCellsInTregAndTconvClusters}
# First Tregs
# note: these should only be used for cellType = Treg. The Tconv cells are probably somewhat erroneously projected.
# Ensure both datasets are normalized and have the same set of features
seuratQCMergedCleaned <- NormalizeData(seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "RNA")
seuratTreg <- NormalizeData(seuratTreg,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "RNA")

# Find variable features for both datasets
seuratQCMergedCleaned <- FindVariableFeatures(seuratQCMergedCleaned,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)
seuratTreg <- FindVariableFeatures(seuratTreg,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

# Find the intersection of variable features
featuresShared <- intersect(VariableFeatures(seuratQCMergedCleaned), VariableFeatures(seuratTreg))

# Find transfer anchors
anchors <- FindTransferAnchors(reference = seuratTreg, query = seuratQCMergedCleaned, features = featuresShared,
  reference.reduction = "pca")

# Transfer cluster labels
predictions <- TransferData(anchorset = anchors, refdata = seuratTreg$seurat_clusters, dims = 1:30)

# Rename the predicted cluster labels to seurat_clusters_Treg
colnames(predictions) <- gsub("predicted.id", "seurat_clusters_Treg", colnames(predictions))

# Add the predicted cluster labels to the metadata of seuratQCMergedCleaned
seuratQCMergedCleaned <- Seurat::AddMetaData(seuratQCMergedCleaned, metadata = predictions)

# Project UMAP embeddings from seuratQCMergedCleanedDS onto seuratTconv
# NOTE: the reference RunUMAP() call has to include "return.model = TRUE"
seuratQCMergedCleaned <- MapQuery(
  anchorset = anchors,
  reference = seuratTreg,
  query = seuratQCMergedCleaned,
  # refdata = list(UMAP = Embeddings(seuratTreg, "umap")), # this line breaks the call, unsure why. Works without it, though!
  reference.reduction = "pca",
  reduction.model = "umap"
)

# Rename the resulting reduction slot (e.g., "ref.umap_new")
seuratQCMergedCleaned[["ref.umap_Treg"]] <- seuratQCMergedCleaned[["ref.umap"]]

# Plot the UMAP embeddings
umap.trial.tmp <- DimPlot(seuratQCMergedCleaned,
  reduction = "ref.umap_Treg",
  group.by = "seurat_clusters_Treg",
  cols = palRNAClustersTreg)

# Save the scatterplot to a file
png(file.path(plotDir,
  paste0(filenameSuffix, "CEFX_projectedOnTregUMAP.png")),
height = 7,
width = 8,
units = "in",
res = 600)

print(umap.trial.tmp)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "CEFX_projectedOnTregUMAP.pdf")),
height = 7,
width = 8)

print(umap.trial.tmp)

dev.off()


# =================================now Tconvs=====================================
# note: these should only be used for cellType = Tconv. The Treg cells are probably somewhat erroneously projected.
seuratTconv <- NormalizeData(seuratTconv,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "RNA")

# Find variable features for both datasets
seuratQCMergedCleaned <- FindVariableFeatures(seuratQCMergedCleaned,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)
seuratTconv <- FindVariableFeatures(seuratTconv,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

# Find the intersection of variable features
featuresShared <- intersect(VariableFeatures(seuratQCMergedCleaned), VariableFeatures(seuratTconv))

# Find transfer anchors
anchors <- FindTransferAnchors(
  reference = seuratTconv,
  query = seuratQCMergedCleaned,
  features = featuresShared,
  reference.reduction = "pca"
)

# Transfer cluster labels
predictions <- TransferData(anchorset = anchors, refdata = seuratTconv$seurat_clusters, dims = 1:30)

# Rename the predicted cluster labels to seurat_clusters_Treg
colnames(predictions) <- gsub("predicted.id", "seurat_clusters_Tconv", colnames(predictions))

# Add the predicted cluster labels to the metadata of seuratQCMergedCleaned
seuratQCMergedCleaned <- Seurat::AddMetaData(seuratQCMergedCleaned, metadata = predictions)

# Project UMAP embeddings from seuratQCMergedCleanedDS onto seuratTconv
# NOTE: the reference RunUMAP() call has to include "return.model = TRUE"
seuratQCMergedCleaned <- MapQuery(
  anchorset = anchors,
  reference = seuratTconv,
  query = seuratQCMergedCleaned,
  # refdata = list(UMAP = Embeddings(seuratTconv, "umap")), # this line breaks the call, unsure why. Works without it, though!
  reference.reduction = "pca",
  reduction.model = "umap"
)

# Rename the resulting reduction slot (e.g., "ref.umap_new")
seuratQCMergedCleaned[["ref.umap_Tconv"]] <- seuratQCMergedCleaned[["ref.umap"]]

# Plot the UMAP embeddings
umap.trial.tmp <- DimPlot(seuratQCMergedCleaned,
  reduction = "ref.umap_Tconv",
  group.by = "seurat_clusters_Tconv",
  cols = palRNAClusters)

# Save the scatterplot to a file
png(file.path(plotDir,
  paste0(filenameSuffix, "CEFX_projectedOnTconvUMAP.png")),
height = 7,
width = 8,
units = "in",
res = 600)

print(umap.trial.tmp)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "CEFX_projectedOnTconvUMAP.pdf")),
height = 7,
width = 8)

print(umap.trial.tmp)

dev.off()
```

```{r saveProcessedData}
# save the workspace as an .RData file
save.image(file.path(dataOutputDir, "20250402_processedData.RData"))

# load the saved image
load(file.path(dataOutputDir, "20250213_processedData.RData")) # this is a 'stable' manuscript-making dataset
load(file.path(dataOutputDir, "20250402_processedData.RData")) # this is just like 20250213, but it has the reference-mapped embeddings all done.
```

```{r lookAtClustersTregs}

nClust <- length(table(seuratTreg@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_TregOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTreg,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTreg) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_clusterFacet_TregOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTreg,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTreg) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seuratTreg@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seuratTreg@meta.data$seurat_clusters
umap_data$stimulationFigures <- seuratTreg@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_stimulationFacet_TregOnly.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = seurat_clusters)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClustersTreg) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()


# non-Downsampled
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Treg))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_TregOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_Treg",
  group = "seurat_clusters_Treg",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTreg) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_clusterFacet_TregOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_Treg",
  group = "seurat_clusters_Treg",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTreg) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters_Treg)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seurat.tmp@reductions$ref.umap_Treg@cell.embeddings)
umap_data$seurat_clusters_Treg <- seurat.tmp@meta.data$seurat_clusters_Treg
umap_data$stimulationFigures <- seurat.tmp@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_stimulationFacet_TregOnly.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = refumaptreg_1, y = refumaptreg_2, color = seurat_clusters_Treg)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClustersTreg) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()

"#87CEEB"
"#1E90FF"
"#4682B4"
"#0000CD"
```

```{r clusterProportionPlotsWithCellTypeCalls}
nClust <- length(table(seuratTreg@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratTreg@meta.data$studyGroup <- as.factor(seuratTreg@meta.data$studyGroup)
seuratTreg@meta.data$stimulationFigures <- as.factor(seuratTreg@meta.data$stimulationFigures)
seuratTreg@meta.data$donorIdFigures <- as.factor(seuratTreg@meta.data$donorIdFigures)
seuratTreg@meta.data$seurat_clusters <- as.factor(seuratTreg@meta.data$seurat_clusters)
seuratTreg@meta.data$seuratClustersAllCellsDS <- as.factor(seuratTreg@meta.data$seuratClustersAllCellsDS)
seuratTreg@meta.data$cellType <- as.factor(seuratTreg$cellType)
seuratTreg@meta.data$cellTypistCalling <- as.factor(seuratTreg$cellTypistCalling)

# Extract metadata
metadata.tmp <- seuratTreg@meta.data

# all together now
# Create the three plots
plot1.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot2.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot3.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot4.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = seuratClustersAllCellsDS)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Original Clusters") +
  # scale_fill_manual(values = palCellType) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot5.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1.tmp, plot2.tmp, plot3.tmp, plot4.tmp, plot5.tmp, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_TregOnly.pdf")), height = 9, width = 8)
print(combined_plot)
dev.off()
```

```{r getTopClusterDefiningGenesTregOnly}
nGenes <- 30
DefaultAssay(seuratTreg) <- "RNA"
Idents(seuratTreg) <- "seurat_clusters"
# Join the data layers
seuratTreg <- JoinLayers(seuratTreg)

clusterMarkers <- FindAllMarkers(seuratTreg)

# implement a filter so that we only consider genes expressed in a certain percentage of cells
# Calculate the percentage of cells with non-zero expression for each gene in each cluster
expressionData <- FetchData(seuratTreg, vars = unique(clusterMarkers$gene))
metadata <- seuratTreg@meta.data %>%
  dplyr::select(seurat_clusters) %>%
  rownames_to_column("cell")

expressionData <- expressionData %>%
  rownames_to_column("cell") %>%
  left_join(metadata, by = "cell")

expressionDataLong <- expressionData %>%
  pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

expressionDataSummary <- expressionDataLong %>%
  group_by(seurat_clusters, gene) %>%
  summarise(percent_expressed = mean(expression > 0) * 100)

min_percent_expressed <- 30
clusterMarkers <- clusterMarkers %>%
  left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
  filter(percent_expressed >= min_percent_expressed)
# end of expressed in x% of cells filtering


topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = nGenes) %>%
  dplyr::slice_min(p_val_adj, n = nGenes) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters)) # , each = 4

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataOutputDir, paste0("top", as.character(nGenes), "_genes_per_cluster_Treg_old.csv")), quote = FALSE, row.names = TRUE)
```

```{r clusterDefiningGenesDotPlotTreg}
# first subset down to Treg cells only
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Treg))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 8

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
dotPlot.tmp <- DotPlot(seurat.tmp, dot.scale = 3.75, features = genes.tmp, group.by = "seurat_clusters_Treg") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
    text = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize)) +
  labs(y = "Treg Clusters", x = "Cluster-defining genes") +
  guides(color = guide_colorbar(title = "Average\nExpression"),
    size = guide_legend(title = "Percent\nExpressed")) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red")

# Print the DotPlot to png and pdf files
savePlot(
  plot = dotPlot.tmp,
  plotDir = plotDir,
  filename = paste0(filenameSuffix, nClustString, "_topClusterDefiningGenesDotPlotTregs"),
  height = 4,
  width = 7,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
)

rm_tmp(ask = FALSE)
```

```{r genesOfInterestDotPlotsTreg}
# Manuscript Figure 2A
# subset our seurat object down to just Treg cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

# dotplots of lists of genes of interest for Treg cell clusters
nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Treg))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 8

# Loop through each column in geneListsTreg.df
for (genesOfInterestCategory in colnames(geneListsTreg.df)) {
  # Extract the gene names for the current category
  genes.tmp <- geneListsTreg.df[[genesOfInterestCategory]]

  # Create a string for the gene list category
  genesString <- paste0("Treg_", genesOfInterestCategory)

  # Create a DotPlot of the expression of these genes in seuratTreg
  dotPlot.tmp <- DotPlot(seurat.tmp,
    features = genes.tmp,
    group.by = "seurat_clusters_Treg",
    dot.scale = 3.75) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Treg Clusters", x = genesString) +
    guides(color = guide_colorbar(title = "Average\nExpression"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Print the DotPlot to png and pdf files
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(filenameSuffix, nClustString, genesString, "_TregGenesDotPlotTregs"),
    height = 4,
    width = 4.5,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
  )
}

# trying to use chatgpt to reorder the genes
# subset our seurat object down to just Tconv cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

# dotplots of lists of genes of interest for Tconv cell clusters
nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Tconv))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 8

# Loop through each column in geneListsTconv.df
for (genesOfInterestCategory in colnames(geneListsTconv.df)) {
  # Extract the gene names for the current category
  genes.tmp <- geneListsTconv.df[[genesOfInterestCategory]]

  # Create a string for the gene list category
  genesString <- paste0("Tconv_", genesOfInterestCategory)

  # Create a DotPlot of the expression of these genes in seuratTconv
  dotPlot.tmp <- DotPlot(seurat.tmp,
    features = genes.tmp,
    dot.scale = 3.75,
    group.by = "seurat_clusters_Tconv") +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Tconv Clusters", x = genesString) +
    guides(color = guide_colorbar(title = "Average\nExpression"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Print the DotPlot to png and pdf files
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(filenameSuffix, nClustString, genesString, "_TconvGenesDotPlotTconvs"),
    height = 4,
    width = 4.5,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
  )
}




# Loop through each column in geneListsTconv.df
for (genesOfInterestCategory in colnames(geneListsTconv.df)) {
  # Extract the gene names for the current category
  genes.tmp <- geneListsTconv.df[[genesOfInterestCategory]]

  # Create a string for the gene list category
  genesString <- paste0("Tconv_", genesOfInterestCategory)

  # Create a DotPlot of the expression of these genes in seuratTreg
  dotPlot.tmp <- DotPlot(seurat.tmp, features = genes.tmp, group.by = "seurat_clusters_Treg") +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Treg Clusters", x = genesString)

  # Print the DotPlot to a PDF file
  pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, genesString, "_TconvGenesDotPlotTregs.pdf")), height = 5, width = 12)
  print(dotPlot.tmp)
  dev.off()
}

# Loop through each column in geneListsHCvsT1D.df
for (genesOfInterestCategory in colnames(geneListsHCvsT1D.df)) {
  # Extract the gene names for the current category
  genes.tmp <- geneListsHCvsT1D.df[[genesOfInterestCategory]]

  # Create a string for the gene list category
  genesString <- genesOfInterestCategory

  # Create a DotPlot of the expression of these genes in seuratTreg
  dotPlot.tmp <- DotPlot(seuratTreg, features = genes.tmp) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Treg Clusters", x = genesString)

  # Print the DotPlot to a PDF file
  pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, genesString, "_T1DvHCGenesDotPlotTregs.pdf")), height = 5, width = 12)
  print(dotPlot.tmp)
  dev.off()
}

rm_tmp(ask = FALSE)
```

```{r P390ClusterDefiningGenesFiguresTregs}
#
```

```{r P390ClusterDefiningGenesFiguresTconvs}
# Subset Tconv cells from your seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

# Set the active identity to seurat_clusters_Tconv
Idents(seurat.tmp) <- seurat.tmp@meta.data$seurat_clusters_Tconv

# External gene list (from P390) with two columns: gene and cluster
p390_genes <- geneListsP390TconvCDGenes.df %>% dplyr::select(gene, cluster)
genes_to_use <- unique(p390_genes$gene)

# Calculate average expression (using the data slot)
avgExp <- AverageExpression(seurat.tmp, features = genes_to_use, assay = "RNA", slot = "data")$RNA
# Convert to data frame and merge with external p390 gene list
avgExp_df <- as.data.frame(avgExp) %>%
  tibble::rownames_to_column(var = "gene") %>%
  left_join(p390_genes, by = "gene")

# Reshape so that for each current seurat cluster and each external p390 group we get the mean expression.
meanExp_long <- avgExp_df %>%
  pivot_longer(
    cols = colnames(avgExp),
    names_to = "seurat_clusters_Tconv",
    values_to = "expression"
  ) %>%
  # Remove any leading "g" that may have been added (I don't know why this is happening)
  mutate(seurat_clusters_Tconv = sub("^g", "", seurat_clusters_Tconv)) %>%
  mutate(seurat_clusters_Tconv = factor(seurat_clusters_Tconv, levels = c("0", "1", "2", "3", "4", "5"))) %>%
  group_by(seurat_clusters_Tconv, cluster) %>%
  summarize(mean_expr = mean(expression, na.rm = TRUE), .groups = "drop")

# Reshape into a matrix: rows = your current seurat_clusters_Tconv, columns = external p390 clusters.
heatmap_mat <- meanExp_long %>%
  pivot_wider(names_from = cluster, values_from = mean_expr) %>%
  column_to_rownames(var = "seurat_clusters_Tconv") %>%
  as.matrix()

# Z-score normalize the expression per gene (row scaling)
heatmap_mat <- t(scale(t(heatmap_mat)))

# Plot the heatmap: the row names now come solely from seurat_clusters_Tconv.
heatmap.tmp <- Heatmap(heatmap_mat, name = "Mean Expression",
  column_title = "P390 Tconv Clusters",
  row_title = "P589 Tconv Clusters")

pdf(file.path(plotDir, paste0(filenameSuffix, "_P390TconvClusterDefiningGenesMeanExpHeatmap.pdf")),
  height = 5, width = 6)
print(heatmap.tmp)
dev.off()

### PART 2. Compute percell module scores and plot boxplot+violin/dots

# Create a list of gene sets from the P390 gene list where names are the P390 cluster labels.
p390_gene_sets <- p390_genes %>%
  group_by(cluster) %>%
  summarize(genes = list(unique(gene)), .groups = "drop") %>%
  deframe()
# The list names (the names of each gene set) are the P390 cluster labels.

# Compute a module score per cell for each gene set.
# By default, AddModuleScore will create metadata columns named "P390Score1", "P390Score2", etc.
seurat.tmp <- AddModuleScore(seurat.tmp, features = p390_gene_sets, name = "P390Score")

# Create a mapping from the score columns to the P390 cluster labels.
score_names <- names(p390_gene_sets)
module_score_cols <- paste0("P390Score", seq_along(score_names))

# Build a long data frame: for each cell, include its cluster assignment and each module score.
cell_scores <- seurat.tmp@meta.data %>%
  dplyr::select(seurat_clusters_Tconv, all_of(module_score_cols)) %>%
  pivot_longer(cols = all_of(module_score_cols),
    names_to = "p390_score_idx", values_to = "module_score") %>%
  mutate(p390_cluster = factor(p390_score_idx, labels = score_names),
    P589_clustersTconv = seurat_clusters_Tconv)

# Make a boxplot with jitter (violinstyle dots) for each P390 gene set (faceted) with x-axis = your clusters.
plot.tmp <- ggplot(cell_scores, aes(x = P589_clustersTconv, y = module_score, fill = P589_clustersTconv)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.2) +
  facet_wrap(~p390_cluster, scales = "free_y") +
  labs(x = "P589 Clusters (Tconv)",
    y = "Module Score (Mean Expression)",
    title = "Expression of P390 Tconv C.D. Genes") +
  scale_fill_manual(values = palRNAClustersTconv) +
  theme_minimal()

pdf(file.path(plotDir, paste0(filenameSuffix, "_P390TconvClusterDefiningGenesMeanExpBoxplots.pdf")),
  height = 5, width = 6)
print(plot.tmp)
dev.off()
```

```{r P390ClusterDefiningGenesFiguresTregs}
# Subset Treg cells from your seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

# Set the active identity to seurat_clusters_Treg
Idents(seurat.tmp) <- seurat.tmp@meta.data$seurat_clusters_Treg

# External gene list (from P390) with two columns: gene and cluster
p390_genes <- geneListsP390TregCDGenes.df %>% dplyr::select(gene, cluster)
genes_to_use <- unique(p390_genes$gene)

# Calculate average expression (using the data slot)
avgExp <- AverageExpression(seurat.tmp, features = genes_to_use, assay = "RNA", slot = "data")$RNA
# Convert to data frame and merge with external p390 gene list
avgExp_df <- as.data.frame(avgExp) %>%
  tibble::rownames_to_column(var = "gene") %>%
  left_join(p390_genes, by = "gene")

# Reshape so that for each current seurat cluster and each external p390 group we get the mean expression.
meanExp_long <- avgExp_df %>%
  pivot_longer(
    cols = colnames(avgExp),
    names_to = "seurat_clusters_Treg",
    values_to = "expression"
  ) %>%
  # Remove any leading "g" that may have been added (e.g. "g0" becomes "0")
  mutate(seurat_clusters_Treg = sub("^g", "", seurat_clusters_Treg)) %>%
  # Optionally force the levels to be exactly your expected clusters (if known)
  mutate(seurat_clusters_Treg = factor(seurat_clusters_Treg, levels = c("0", "1", "2", "3"))) %>%
  group_by(seurat_clusters_Treg, cluster) %>%
  summarize(mean_expr = mean(expression, na.rm = TRUE), .groups = "drop")

# Reshape into a matrix: rows = your current seurat_clusters_Treg, columns = external p390 clusters.
heatmap_mat <- meanExp_long %>%
  pivot_wider(names_from = cluster, values_from = mean_expr) %>%
  column_to_rownames(var = "seurat_clusters_Treg") %>%
  as.matrix()

# Z-score normalize the expression per gene (row scaling)
heatmap_mat <- t(scale(t(heatmap_mat)))

# Plot the heatmap: the row names now come solely from seurat_clusters_Treg.
heatmap.tmp <- Heatmap(heatmap_mat, name = "Mean Expression",
  column_title = "P390 Treg Clusters",
  row_title = "P589 Treg Clusters")

pdf(file.path(plotDir, paste0(filenameSuffix, "_P390TregClusterDefiningGenesMeanExpHeatmap.pdf")),
  height = 5, width = 6)
print(heatmap.tmp)
dev.off()

### PART 2. Compute percell module scores and plot boxplot+violin/dots

# Create a list of gene sets from the P390 gene list where names are the P390 cluster labels.
p390_gene_sets <- p390_genes %>%
  group_by(cluster) %>%
  summarize(genes = list(unique(gene)), .groups = "drop") %>%
  deframe()
# The list names (the names of each gene set) are the P390 cluster labels.

# Compute a module score per cell for each gene set.
# By default, AddModuleScore will create metadata columns named "P390Score1", "P390Score2", etc.
seurat.tmp <- AddModuleScore(seurat.tmp, features = p390_gene_sets, name = "P390Score")

# Create a mapping from the score columns to the P390 cluster labels.
score_names <- names(p390_gene_sets)
module_score_cols <- paste0("P390Score", seq_along(score_names))

# Build a long data frame: for each cell, include its cluster assignment and each module score.
cell_scores <- seurat.tmp@meta.data %>%
  dplyr::select(seurat_clusters_Treg, all_of(module_score_cols)) %>%
  pivot_longer(cols = all_of(module_score_cols),
    names_to = "p390_score_idx", values_to = "module_score") %>%
  mutate(p390_cluster = factor(p390_score_idx, labels = score_names),
    P589_clustersTreg = seurat_clusters_Treg)

# Make a boxplot with jitter (violinstyle dots) for each P390 gene set (faceted) with x-axis = your clusters.
plot.tmp <- ggplot(cell_scores, aes(x = P589_clustersTreg, y = module_score, fill = P589_clustersTreg)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.2) +
  facet_wrap(~p390_cluster, scales = "free_y") +
  labs(x = "P589 Clusters (Treg)",
    y = "Module Score (Mean Expression)",
    title = "Expression of P390 Treg C.D. Genes") +
  scale_fill_manual(values = palRNAClustersTreg) +
  theme_minimal()

pdf(file.path(plotDir, paste0(filenameSuffix, "_P390TregClusterDefiningGenesMeanExpBoxplots.pdf")),
  height = 5, width = 6)
print(plot.tmp)
dev.off()
```

```{r showstemnessScoreOnUMAPTregOnly}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScore_TregOnly.pdf")),
height = 6,
width = 12)

FeaturePlot(object = seuratTreg,
  features = "stemnessScore",
  reduction = "umap",
  pt.size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1)
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_stimulationFacetTregOnly.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratTreg, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTreg@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = stemnessScore)) +
  geom_point(size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()
```

```{r makeAirlinePlotTregOnly}
# -------------------all three stimulations---------------------------------
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seuratTreg@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
# print(cdr3CloneID_filtered)
airlinePlot(seuratTreg,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTregOnly4Clust")

airlinePlotDonorId(seuratTreg,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTregOnly4ClustDonorId")

# --------------------------------------------------------------------------

# -----------------------------------IAR------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTreg, subset = stimulationFigures == "IAR")
seurat_subset.tmp@meta.data$seurat_clusters_DS <- seurat_subset.tmp@meta.data$seurat_clusters

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTregOnly4ClustIAR")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTregOnly4ClustIARDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Microbial------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTreg, subset = stimulationFigures == "Microbial")
seurat_subset.tmp@meta.data$seurat_clusters_DS <- seurat_subset.tmp@meta.data$seurat_clusters

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTregOnly4ClustMicrobial")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTregOnly4ClustMicrobialDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Polyclonal------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTreg, subset = stimulationFigures == "Polyclonal")
seurat_subset.tmp@meta.data$seurat_clusters_DS <- seurat_subset.tmp@meta.data$seurat_clusters

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTregOnly4ClustPolyclonal")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTregOnly4ClustPolyclonalDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------
```

```{r upsetPlotTreg}
# This shows unique, expanded clonotypes
# seuratObject is the Seurat object
# pairs is a data frame where each entry is a cell with columns for both the alpha and beta TCR sequences

# NEWEST VERSION 20250605
makeClusterExpansionUpsetPlots <- function(
    seuratObject,
    pairs,
    clusterColumn,
    title = "TCR sharing analysis",
    filename = "upset_plot.png",
    displayCounts = TRUE, # whether or not to display counts above the barplot
    colors = NULL
    ) {
  # library(dplyr)
  # library(tidyr)
  # library(ggplot2)
  # library(ComplexUpset)
  # library(patchwork)

  seurat_meta <- seuratObject@meta.data
  if (!"barcode" %in% colnames(seurat_meta)) seurat_meta$barcode <- rownames(seurat_meta)
  subpairs <- pairs %>% filter(barcode %in% rownames(seurat_meta))
  subpairs <- subpairs %>%
    mutate(
      fullLengthNTa = ifelse(is.na(fullLengthNTa) | fullLengthNTa == "", "NA", fullLengthNTa),
      fullLengthNTb = ifelse(is.na(fullLengthNTb) | fullLengthNTb == "", "NA", fullLengthNTb),
      pairnt = paste(fullLengthNTa, fullLengthNTb, sep = "_")
    ) %>%
    filter(!grepl("^NA_|_NA$|^NA_NA$", pairnt))

  subpairs <- left_join(subpairs, seurat_meta[, c("barcode", clusterColumn)], by = "barcode")
  colnames(subpairs)[ncol(subpairs)] <- "cluster"
  subpairs <- filter(subpairs, !is.na(cluster))

  expandedPairs <- subpairs %>%
    group_by(pairnt) %>%
    filter(n() > 1) %>%
    ungroup() %>%
    distinct(pairnt, cluster)

  clusters_sorted <- sort(unique(as.character(expandedPairs$cluster)))
  membership_df <- expandedPairs %>%
    mutate(present = TRUE) %>%
    pivot_wider(id_cols = pairnt, names_from = cluster, values_from = present, values_fill = FALSE)
  for (col in setdiff(clusters_sorted, colnames(membership_df))) membership_df[[col]] <- FALSE
  membership_df <- membership_df[, c("pairnt", clusters_sorted)]

  cluster_sets <- setdiff(colnames(membership_df), "pairnt")
  if (is.null(colors)) colors <- scales::hue_pal()(length(cluster_sets))

  upset_plot <- ComplexUpset::upset(
    membership_df,
    intersect = cluster_sets,
    name = "Expanded Clonotypes",
    base_annotations = list(
      "Intersection size" = ComplexUpset::intersection_size(
        counts = displayCounts,
        text = list(size = 3, angle = 0, hjust = 0.5, vjust = 0)
      )
    ),
    stripes = ComplexUpset::upset_stripes(colors = colors),
    set_sizes = ComplexUpset::upset_set_size(
      geom = ggplot2::geom_bar(stat = "count", position = "stack", fill = "grey50"),
      position = "left"
    ),
    sort_sets = FALSE,
    sort_intersections = "descending",
    guides = "over",
    width_ratio = 0.2,
    height_ratio = 0.7
  ) +
    ggtitle(title) +
    labs(caption = paste("Based on", nrow(membership_df), "unique expanded clonotypes")) +
    patchwork::plot_layout() &
    theme(
      plot.title = element_text(hjust = 0.5),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )



  savePlot(
    plot = upset_plot,
    plotDir = plotDir,
    filename = filename,
    height = 6,
    width = 8,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )
  invisible(membership_df)
}

seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures == "IAR")
seurat.tmp <- subset(seurat.tmp, cellType %in% c("Treg", "Tconv"))
colors <- c(
  scales::alpha("red", 0.5), scales::alpha("red", 0.5),
  scales::alpha("blue", 0.5), scales::alpha("blue", 0.5),
  scales::alpha("red", 0.5), scales::alpha("red", 0.5)
)

makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
  pairs = cleanTCRpairs.df,
  clusterColumn = "seurat_clusters_DS",
  title = "TCR sharing in RNAseq clusters\nIAR",
  colors = colors,
  filename = "IAR_TCR_Pair_Sharing_UpSet_Plot")

makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
  pairs = cleanTCRpairs.df,
  clusterColumn = "seurat_clusters_DS",
  title = "TCR sharing in RNAseq clusters\nIAR",
  colors = colors,
  displayCounts = FALSE,
  filename = "IAR_TCR_Pair_Sharing_UpSet_Plot_noCounts")

seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures == "Microbial")
seurat.tmp <- subset(seurat.tmp, cellType %in% c("Treg", "Tconv"))
colors <- c(
  scales::alpha("red", 0.5), scales::alpha("red", 0.5), scales::alpha("red", 0.5),
  scales::alpha("blue", 0.5), scales::alpha("blue", 0.5),
  scales::alpha("red", 0.5), scales::alpha("red", 0.5)
)
makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
  pairs = cleanTCRpairs.df,
  clusterColumn = "seurat_clusters_DS",
  title = "TCR sharing in RNAseq clusters\nMicrobial",
  colors = colors,
  filename = "microbial_TCR_Pair_Sharing_UpSet_Plot")

makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
  pairs = cleanTCRpairs.df,
  clusterColumn = "seurat_clusters_DS",
  title = "TCR sharing in RNAseq clusters\nMicrobial",
  colors = colors,
  displayCounts = FALSE,
  filename = "microbial_TCR_Pair_Sharing_UpSet_Plot_noCounts")

seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures == "Polyclonal")
seurat.tmp <- subset(seurat.tmp, cellType %in% c("Treg", "Tconv"))
colors <- c(
  scales::alpha("red", 0.5), scales::alpha("red", 0.5),
  scales::alpha("blue", 0.5), scales::alpha("blue", 0.5),
  scales::alpha("red", 0.5)
)
makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
  pairs = cleanTCRpairs.df,
  clusterColumn = "seurat_clusters_DS",
  title = "TCR sharing in RNAseq clusters\nPolyclonal",
  colors = colors,
  filename = "polyclonal_TCR_Pair_Sharing_UpSet_Plot")

makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
  pairs = cleanTCRpairs.df,
  clusterColumn = "seurat_clusters_DS",
  title = "TCR sharing in RNAseq clusters\nPolyclonal",
  colors = colors,
  displayCounts = FALSE,
  filename = "polyclonal_TCR_Pair_Sharing_UpSet_Plot_noCounts")
```

```{r showCITEseqOnUMAPTregOnly}
# Save the original default assay
original_default_assay <- DefaultAssay(seuratTreg)

# Set the default assay to 'FB'
DefaultAssay(seuratTreg) <- "FB"

# Define the markers you want to plot
markers <- rownames(seuratTreg@assays$FB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TregOnly_TotalSeq_", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratTreg,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# now a version that facet_wraps by stimulation
# Define the function to plot a single marker with facet wrap by stimulationFigures
plotMarkerWithFacets <- function(seuratObject, marker) {
  pdf(
    file = file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TregOnly_TotalSeq_stimulationFacet_", marker, ".pdf")),
    width = 10, height = 6
  )

  # Extract the data for the marker of interest
  data <- FetchData(seuratObject, vars = c("umap_1", "umap_2", "stimulationFigures", marker))

  # Create a custom ggplot
  p <- ggplot(data, aes(x = .data$umap_1, y = .data$umap_2, color = .data[[marker]])) +
    geom_point(size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker) +
    theme(aspect.ratio = 1) +
    facet_wrap(~stimulationFigures)

  print(p)
  dev.off()
}

for (marker in markers) {
  plotMarkerWithFacets(seuratTreg, marker)
}

# Reset the default assay to its original
DefaultAssay(seuratTreg) <- original_default_assay
```

```{r monocleTrajectoryOnSeuratTreg}
# convert seurat object to a cds object, cluster the cells, and learn the graph
seuratTreg.cds <- as.cell_data_set(seuratTreg)
# seuratTreg.cds <- cluster_cells(seuratTreg.cds)

# Add Seurat cluster information to the Monocle object
seuratTreg.cds@clusters$UMAP$clusters <- seuratTreg@meta.data$seurat_clusters

# Ensure partitions are set (required by Monocle)
partitions <- factor(rep(1, ncol(seuratTreg.cds)))
names(partitions) <- colnames(seuratTreg.cds)
seuratTreg.cds@clusters$UMAP$partitions <- partitions

seuratTreg.cds <- learn_graph(seuratTreg.cds)

# Plot the UMAP with Seurat clusters and Monocle trajectory
p1.tmp <- plot_cells(
  seuratTreg.cds,
  color_cells_by = "seurat_clusters",
  show_trajectory_graph = TRUE,
  label_groups_by_cluster = FALSE,
  label_roots = TRUE,
  label_leaves = TRUE,
  label_branch_points = TRUE
) + scale_color_manual(values = palRNAClustersTreg) +
  theme(legend.position = "right")

pdf(file.path(plotDir, paste0(filenameSuffix, "monocleTrajectorySeuratTreg.pdf")), height = 5, width = 7)
print(p1.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r monocleTrajectoryOnSeurat}
# convert seurat object to a cds object, cluster the cells, and learn the graph
seuratQCMergedCleanedDS.cds <- as.cell_data_set(seuratQCMergedCleanedDS)
seuratQCMergedCleanedDS.cds <- cluster_cells(seuratQCMergedCleanedDS.cds)
seuratQCMergedCleanedDS.cds <- learn_graph(seuratQCMergedCleanedDS.cds)

# Plot the UMAP with Seurat clusters and Monocle trajectory
p1.tmp <- plot_cells(
  seuratQCMergedCleanedDS.cds,
  color_cells_by = "seurat_clusters",
  show_trajectory_graph = TRUE,
  label_groups_by_cluster = FALSE,
  label_roots = TRUE,
  label_leaves = TRUE,
  label_branch_points = TRUE
) + scale_color_manual(values = palRNAClusters) +
  theme(legend.position = "right")

pdf(file.path(plotDir, paste0(filenameSuffix, "monocleTrajectorySeurat.pdf")), height = 5, width = 7)
print(p1.tmp)
dev.off()

rm_tmp(ask = FALSE)
```
```{r genesOfInterestHeatmaps}

# TODO this doesn't work yet
# Select top 50 genes based on adjusted p-value
genes.tmp <- head(rownames(results_IAR_vs_Microbial), 50)

# Extract expression data for these genes
logCpm.tmp <- cpm(dgeAggregated.tmp, log = TRUE)[genes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seuratTreg@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Treg", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Treg = first(seurat_clusters_Treg),
    stimulationFigures = first(stimulationFigures),
    studyGroup = first(studyGroup),
    pool = first(pool)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Treg = pseudobulkMetadata.tmp$seurat_clusters_Treg,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Treg = palRNAClustersTreg,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = geneList,
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Treg
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_", geneList, "_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = geneList,
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_", geneList, "_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()
```

```{r genesOfInterestOnTconvTregOnlyUMAPs}
# Extract gene names from all columns in each dataframe
genesTconv.tmp <- unlist(geneListsTconv.df)
genesTreg.tmp <- unlist(geneListsTreg.df)
genesHCvsT1D.tmp <- unlist(geneListsHCvsT1D.df)
genesTCR.tmp <- unlist(geneListsTCR.df)

# Combine all gene names into a single vector
allGeneListGenes.tmp <- unique(c(genesTconv.tmp, genesTreg.tmp, genesHCvsT1D.tmp, genesTCR.tmp))

# remove NA from allGeneListGenes.tmp
allGeneListGenes.tmp <- allGeneListGenes.tmp[!is.na(allGeneListGenes.tmp)]

# prints out a separate expression UMAP for each gene in genesOfInterest
for (gene in allGeneListGenes.tmp) {
  plotGenesOfInterest(
    seuratTreg,
    gene,
    paste0("seuratTreg_UMAP_", gene, "_"),
    nCols = 1
  )
}

# prints out a separate expression UMAP for each gene in genesOfInterest
for (gene in allGeneListGenes.tmp) {
  plotGenesOfInterest(
    seuratTconv,
    gene,
    paste0("seuratTconv_UMAP_", gene, "_"),
    nCols = 1
  )
}

# prints out a separate expression UMAP for each gene in genesOfInterest
for (gene in allGeneListGenes.tmp) {
  plotGenesOfInterestStimFacet(
    seuratTreg,
    gene,
    paste0("seuratTreg_UMAP_", gene, "_StimulationFacet"),
    nCols = 3
  )
}

# prints out a separate expression UMAP for each gene in genesOfInterest
for (gene in allGeneListGenes.tmp) {
  plotGenesOfInterestStimFacet(
    seuratTconv,
    gene,
    paste0("seuratTconv_UMAP_", gene, "_StimulationFacet"),
    nCols = 3
  )
}

rm_tmp(ask = FALSE)
```

### Tconv only analysis

```{r lookAtClustersTconvs}

nClust <- length(table(seuratTconv@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_TconvOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTconv,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTconv) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_clusterFacet_TconvOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTconv,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTconv) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seuratTconv@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seuratTconv@meta.data$seurat_clusters
umap_data$stimulationFigures <- seuratTconv@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_stimulationFacet_TconvOnly.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = seurat_clusters)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClustersTconv) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()


# non-Downsampled
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Tconv))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_TconvOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_Tconv",
  group = "seurat_clusters_Tconv",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTconv) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_clusterFacet_TconvOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seurat.tmp,
  reduction = "ref.umap_Tconv",
  group = "seurat_clusters_Tconv",
  pt.size = 1) +
  scale_color_manual(values = palRNAClustersTconv) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters_Tconv)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seurat.tmp@reductions$ref.umap_Tconv@cell.embeddings)
umap_data$seurat_clusters_Tconv <- seurat.tmp@meta.data$seurat_clusters_Tconv
umap_data$stimulationFigures <- seurat.tmp@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_DS_RNA_stimulationFacet_TconvOnly.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = refumaptconv_1, y = refumaptconv_2, color = seurat_clusters_Tconv)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClustersTconv) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r clusterProportionPlotsWithCellTypeCalls}
nClust <- length(table(seuratTconv@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratTconv@meta.data$studyGroup <- as.factor(seuratTconv@meta.data$studyGroup)
seuratTconv@meta.data$stimulationFigures <- as.factor(seuratTconv@meta.data$stimulationFigures)
seuratTconv@meta.data$donorIdFigures <- as.factor(seuratTconv@meta.data$donorIdFigures)
seuratTconv@meta.data$seurat_clusters <- as.factor(seuratTconv@meta.data$seurat_clusters)
seuratTconv@meta.data$seuratClustersAllCellsDS <- as.factor(seuratTconv@meta.data$seuratClustersAllCellsDS)
seuratTconv@meta.data$cellType <- as.factor(seuratTconv$cellType)
seuratTconv@meta.data$cellTypistCalling <- as.factor(seuratTconv$cellTypistCalling)

# Extract metadata
metadata.tmp <- seuratTconv@meta.data

# all together now
# Create the three plots
plot1.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot2.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot3.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot4.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = seuratClustersAllCellsDS)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Original Clusters") +
  # scale_fill_manual(values = palCellType) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot5.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1.tmp, plot2.tmp, plot3.tmp, plot4.tmp, plot5.tmp, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_TconvOnly.pdf")), height = 9, width = 8)
print(combined_plot)
dev.off()
```

```{r getTopClusterDefiningGenesTconvOnly}
nGenes <- 30
DefaultAssay(seuratTconv) <- "RNA"
Idents(seuratTconv) <- "seurat_clusters"
# Join the data layers
seuratTconv <- JoinLayers(seuratTconv)

clusterMarkers <- FindAllMarkers(seuratTconv)

# implement a filter so that we only consider genes expressed in a certain percentage of cells
# Calculate the percentage of cells with non-zero expression for each gene in each cluster
expressionData <- FetchData(seuratTconv, vars = unique(clusterMarkers$gene))
metadata <- seuratTconv@meta.data %>%
  dplyr::select(seurat_clusters) %>%
  rownames_to_column("cell")

expressionData <- expressionData %>%
  rownames_to_column("cell") %>%
  left_join(metadata, by = "cell")

expressionDataLong <- expressionData %>%
  pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

expressionDataSummary <- expressionDataLong %>%
  group_by(seurat_clusters, gene) %>%
  summarise(percent_expressed = mean(expression > 0) * 100)

min_percent_expressed <- 30
clusterMarkers <- clusterMarkers %>%
  left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
  filter(percent_expressed >= min_percent_expressed)
# end of expressed in x% of cells filtering


topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = nGenes) %>%
  dplyr::slice_min(p_val_adj, n = nGenes) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters)) # , each = 4

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataOutputDir, paste0("top", as.character(nGenes), "_genes_per_cluster_downsampled_Tconv_old.csv")), quote = FALSE, row.names = TRUE)
```

```{r clusterDefiningGenesDotPlotTconv}
# first subset down to Tconv cells only
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Tconv))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 8

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
dotPlot.tmp <- DotPlot(seurat.tmp, dot.scale = 3.75, features = genes.tmp, group.by = "seurat_clusters_Tconv") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
    text = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize)) +
  labs(y = "Tconv Clusters", x = "Cluster-defining genes") +
  guides(color = guide_colorbar(title = "Average\nExpression"),
    size = guide_legend(title = "Percent\nExpressed")) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red")

# Print the DotPlot to png and pdf files
savePlot(
  plot = dotPlot.tmp,
  plotDir = plotDir,
  filename = paste0(filenameSuffix, nClustString, "_top20ClusterDefiningGenesDotPlotTconvs"),
  height = 4,
  width = 7,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
)

rm_tmp(ask = FALSE)
```

```{r genesOfInterestDotPlotsTconv}
# subset our seurat object down to just Tconv cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")

# dotplots of lists of genes of interest for Tconv cell clusters
nClust <- length(table(seurat.tmp@meta.data$seurat_clusters_Tconv))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 8

# Loop through each column in geneListsTconv.df
for (genesOfInterestCategory in colnames(geneListsTconv.df)) {
  # Extract the gene names for the current category
  genes.tmp <- geneListsTconv.df[[genesOfInterestCategory]]

  # Create a string for the gene list category
  genesString <- paste0("Tconv_", genesOfInterestCategory)

  # Create a DotPlot of the expression of these genes in seuratTconv
  dotPlot.tmp <- DotPlot(seurat.tmp,
    features = genes.tmp,
    group.by = "seurat_clusters_Tconv",
    cluster.idents = TRUE) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Tconv Clusters", x = genesString) +
    guides(color = guide_colorbar(title = "Average\nExpression"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Print the DotPlot to png and pdf files
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(filenameSuffix, nClustString, genesString, "_TconvGenesDotPlotTconvs"),
    height = 4,
    width = 4.5,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png") # or "pdf", "png", or c("pdf", "png")
  )
}



# Loop through each column in geneListsHCvsT1D.df
for (genesOfInterestCategory in colnames(geneListsHCvsT1D.df)) {
  # Extract the gene names for the current category
  genes.tmp <- geneListsHCvsT1D.df[[genesOfInterestCategory]]

  # Create a string for the gene list category
  genesString <- genesOfInterestCategory

  # Create a DotPlot of the expression of these genes in seuratTreg
  dotPlot.tmp <- DotPlot(seuratTconv, features = genes.tmp) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Tconv Clusters", x = genesString)

  # Print the DotPlot to a PDF file
  pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, genesString, "_T1DvHCGenesDotPlotTconvs.pdf")), height = 5, width = 12)
  print(dotPlot.tmp)
  dev.off()
}

rm_tmp(ask = FALSE)
```

```{r showstemnessScoreOnUMAPTconvOnly}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScore_TconvOnly.pdf")),
height = 6,
width = 12)

FeaturePlot(object = seuratTconv,
  features = "stemnessScore",
  reduction = "umap",
  pt.size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1)
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_stimulationFacetTconvOnly.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratTconv, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTconv@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = stemnessScore)) +
  geom_point(size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()
```

```{r makeAirlinePlotTconvOnly}
# -------------------all three stimulations---------------------------------
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seuratTconv@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
# print(cdr3CloneID_filtered)
airlinePlot(seuratTconv,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTconvOnly6Clust")

airlinePlotDonorId(seuratTconv,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTconvOnly6ClustDonorId")

# --------------------------------------------------------------------------

# -----------------------------------IAR------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTconv, subset = stimulationFigures == "IAR")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTconvOnly6ClustIAR")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTconvOnly6ClustIARDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Microbial------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTconv, subset = stimulationFigures == "Microbial")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTconvOnly6ClustMicrobial")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTconvOnly6ClustMicrobialDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Polyclonal------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTconv, subset = stimulationFigures == "Polyclonal")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTconvOnly6ClustPolyclonal")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTconvOnly6ClustPolyclonalDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------
```

```{r showCITEseqOnUMAPTconvOnly}
# Save the original default assay
original_default_assay <- DefaultAssay(seuratTconv)

# Set the default assay to 'FB'
DefaultAssay(seuratTconv) <- "FB"

# Define the markers you want to plot
markers <- rownames(seuratTconv@assays$FB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TconvOnly_TotalSeq_", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratTconv,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# now a version that facet_wraps by stimulation
# Define the function to plot a single marker with facet wrap by stimulationFigures
plotMarkerWithFacets <- function(seuratObject, marker) {
  pdf(
    file = file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TconvOnly_TotalSeq_stimulationFacet_", marker, ".pdf")),
    width = 10, height = 6
  )

  # Extract the data for the marker of interest
  data <- FetchData(seuratObject, vars = c("umap_1", "umap_2", "stimulationFigures", marker))

  # Create a custom ggplot
  p <- ggplot(data, aes(x = .data$umap_1, y = .data$umap_2, color = .data[[marker]])) +
    geom_point(size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker) +
    theme(aspect.ratio = 1) +
    facet_wrap(~stimulationFigures)

  print(p)
  dev.off()
}

for (marker in markers) {
  plotMarkerWithFacets(seuratTconv, marker)
}

# Reset the default assay to its original
DefaultAssay(seuratTconv) <- original_default_assay
```

```{r monocleTrajectoryOnSeuratTconv}
# convert seurat object to a cds object, cluster the cells, and learn the graph
seuratTconv.cds <- as.cell_data_set(seuratTconv)
seuratTconv.cds <- cluster_cells(seuratTconv.cds)
seuratTconv.cds <- learn_graph(seuratTconv.cds)

# Plot the UMAP with Seurat clusters and Monocle trajectory
p1.tmp <- plot_cells(
  seuratTconv.cds,
  color_cells_by = "seurat_clusters",
  show_trajectory_graph = TRUE,
  label_groups_by_cluster = FALSE,
  label_roots = TRUE,
  label_leaves = TRUE,
  label_branch_points = TRUE
) + scale_color_manual(values = palRNAClustersTconv) +
  theme(legend.position = "right")

pdf(file.path(plotDir, paste0(filenameSuffix, "monocleTrajectorySeuratTconv.pdf")), height = 5, width = 7)
print(p1.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

### End of Tconv-only analysis

### Pseudobulk defineGeneOfInterestPlotFunction
```{r pseudobulkDGETregOnly}
# subset down our main seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat.tmp, assay = "RNA", layer = "counts")

# Filter genes: keep only those expressed (count > 0) in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# Fetch metadata required for grouping
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Transpose counts for easier manipulation
counts.df.tmp <- as.data.frame(t(counts.tmp))

# Add the grouping information to the counts data frame
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# Aggregate counts by groupDGE
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Verify the aggregated count matrix
dim(countMatrixAggregated.tmp)  # Should be genes x 18 (3 stimulations x 6 donors)
head(countMatrixAggregated.tmp)

# Create DGEList object from the aggregated count matrix
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Extract stimulation groups from groupDGE by splitting with "__"
stimulationGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
stimulation <- factor(stimulationGroups)  # Levels: IAR, Microbial, Polyclonal

# Create design matrix without intercept
design <- model.matrix(~ 0 + stimulation)
colnames(design) <- levels(stimulation)

# Verify the design matrix
print(design)

# Apply voom transformation with the design matrix
v <- voom(dgeAggregated.tmp, design, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design)

# Define contrasts for stimulation group comparisons
contrasts <- makeContrasts(
  IAR_vs_Microbial = IAR - Microbial,
  IAR_vs_Polyclonal = IAR - Polyclonal,
  Microbial_vs_Polyclonal = Microbial - Polyclonal,
  levels = design
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, contrasts)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_IAR_vs_MicrobialTreg <- topTable(
  fit2,
  coef = "IAR_vs_Microbial",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

results_IAR_vs_PolyclonalTreg <- topTable(
  fit2,
  coef = "IAR_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

results_Microbial_vs_PolyclonalTreg <- topTable(
  fit2,
  coef = "Microbial_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

# Add a significance column based on adjusted p-value
results_Microbial_vs_Polyclonal <- results_Microbial_vs_Polyclonal %>%
  mutate(Significant = adj.P.Val < 0.05)

# rm_tmp(ask = FALSE)
```

```{r pseudobulkDGETregOnly_DESeq2}
# 1. Subset Treg cells
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

# 2. Fetch raw counts (using the "counts" slot)
counts.tmp <- GetAssayData(seurat.tmp, assay = "RNA", slot = "counts")

# 3. Filter genes: keep only those expressed in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# 4. Get metadata for grouping (stimulationFigures and donorIdFigures)
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures")]
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))
head(metadata.tmp$groupDGE)

# 5. Transpose counts for aggregation and add group info
counts.df.tmp <- as.data.frame(t(counts.tmp))
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# 6. Aggregate counts by groupDGE (sum counts per gene by group)
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# 7. Convert aggregated counts to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))
dim(countMatrixAggregated.tmp)  # Should be genes x (number of groups)
head(countMatrixAggregated.tmp)

# 8. Define grouping for the DESeq2 design
# Extract stimulation groups from the column names (assumed format "stimulation__donor")
stimulationGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
stimulation <- factor(stimulationGroups, levels = c("IAR", "Microbial", "Polyclonal"))

design <- model.matrix(~ 0 + stimulation)
colnames(design) <- levels(stimulation)
print(design)

# 9. Create DESeqDataSet object (using countMatrixAggregated.tmp as countData)
# Note: DESeq2 expects integer count data.
dds <- DESeqDataSetFromMatrix(countData = countMatrixAggregated.tmp,
  colData = data.frame(stimulation = stimulation),
  design = ~stimulation)

# Pre-filter to remove genes with low overall counts
dds <- dds[rowSums(counts(dds)) > 1, ]

# 10. Run the DESeq2 analysis
dds <- DESeq(dds)

# 11. Define contrasts and extract results
res_IAR_vs_Microbial <- results(dds, contrast = c("stimulation", "IAR", "Microbial"))
res_IAR_vs_Polyclonal <- results(dds, contrast = c("stimulation", "IAR", "Polyclonal"))
res_Microbial_vs_Polyclonal <- results(dds, contrast = c("stimulation", "Microbial", "Polyclonal"))

# For example, check the top DE genes for IAR vs Microbial:
head(res_IAR_vs_Microbial[order(res_IAR_vs_Microbial$pvalue), ])

# Optionally, adjust significance thresholds or add a significance column:
res_IAR_vs_Microbial <- as.data.frame(res_IAR_vs_Microbial) %>%
  mutate(Significant = padj < 0.05 & abs(log2FoldChange) > 1)

# Save or further process your DE results as needed.
```

```{r pseudobulkDGEStimulationCellType_harmonizeWithAHu}
# Subset down our main Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat.tmp, assay = "RNA", layer = "counts")

# Filter genes: keep only those expressed (count > 0) in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# Fetch metadata required for grouping
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures", "cellType")]

# Create a new column for groupDGE with a consistent separator (e.g., "_")
# Use donorIdFigures (not donorId)
metadata.tmp$groupDGE <- paste(metadata.tmp$donorIdFigures, metadata.tmp$stimulationFigures, metadata.tmp$cellType, sep = "_")

# Calculate nCells per pseudobulk group
nCellsPerGroup <- as.data.frame(table(metadata.tmp$groupDGE))
colnames(nCellsPerGroup) <- c("groupDGE", "nCells")

# Merge nCells into metadata
metadata.tmp <- left_join(metadata.tmp, nCellsPerGroup, by = "groupDGE")

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Aggregate counts by groupDGE
counts.df.tmp <- as.data.frame(t(counts.tmp))
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum), .groups = "drop")

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Prepare designBulk dataframe for model.matrix
# Get unique group info for each pseudobulk sample (column)
designBulk <- metadata.tmp %>%
  distinct(groupDGE, .keep_all = TRUE) %>%
  select(groupDGE, stimulationFigures, cellType, nCells)
designBulk <- designBulk[match(colnames(countMatrixAggregated.tmp), designBulk$groupDGE), ]

# Create DGEList object
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Construct design matrix as in your colleague's code
design_mat <- model.matrix(~ 0 + stimulationFigures:cellType + nCells, data = designBulk)
colnames(design_mat) <- gsub("\\:", "_", colnames(design_mat)) # replace : with _
colnames(design_mat) <- gsub("stimulationFigures", "", colnames(design_mat)) # remove the 'stimulationFigures' pre-append
colnames(design_mat) <- gsub("cellType", "", colnames(design_mat)) # remove the 'cellType' pre-append

# Verify the design matrix
print(design_mat)

# Apply voom transformation
v <- voom(dgeAggregated.tmp, design_mat, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design_mat)

# Define contrasts as in your colleague's code
cont.matrix <- makeContrasts(
  Microbial_TregVTconv = Microbial_Treg - Microbial_Tconv,
  IAR_TregVTconv = IAR_Treg - IAR_Tconv,
  Polyclonal_TregVTconv = Polyclonal_Treg - Polyclonal_Tconv,
  Combined_TregVTconv = ((Microbial_Treg - Microbial_Tconv) + (IAR_Treg - IAR_Tconv) + (Polyclonal_Treg - Polyclonal_Tconv)) / 3,
  Treg_IARVMicrobial = IAR_Treg - Microbial_Treg,
  Tconv_IARVMicrobial = IAR_Tconv - Microbial_Tconv,
  levels = design_mat
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, cont.matrix)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_Microbial_TregVTconv <- topTable(fit2, coef = "Microbial_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_Microbial_TregVTconv$gene <- rownames(results_Microbial_TregVTconv)
results_IAR_TregVTconv <- topTable(fit2, coef = "IAR_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_IAR_TregVTconv$gene <- rownames(results_IAR_TregVTconv)
results_Polyclonal_TregVTconv <- topTable(fit2, coef = "Polyclonal_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_Polyclonal_TregVTconv$gene <- rownames(results_Polyclonal_TregVTconv)
results_Combined_TregVTconv <- topTable(fit2, coef = "Combined_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_Combined_TregVTconv$gene <- rownames(results_Combined_TregVTconv)
results_Treg_IARVMicrobial <- topTable(fit2, coef = "Treg_IARVMicrobial", adjust.method = "BH", sort.by = "P", number = Inf)
results_Treg_IARVMicrobial$gene <- rownames(results_Treg_IARVMicrobial)
results_Tconv_IARVMicrobial <- topTable(fit2, coef = "Tconv_IARVMicrobial", adjust.method = "BH", sort.by = "P", number = Inf)
results_Tconv_IARVMicrobial$gene <- rownames(results_Tconv_IARVMicrobial)

# write all results to .csv files
write.csv(results_Microbial_TregVTconv,
  file = file.path(dataOutputDir, "DGE_Microbial_TregVTconv.csv"),
  row.names = TRUE)

write.csv(results_IAR_TregVTconv,
  file = file.path(dataOutputDir, "DGE_IAR_TregVTconv.csv"),
  row.names = TRUE)

write.csv(results_Polyclonal_TregVTconv,
  file = file.path(dataOutputDir, "DGE_Polyclonal_TregVTconv.csv"),
  row.names = TRUE)

write.csv(results_Combined_TregVTconv,
  file = file.path(dataOutputDir, "DGE_Combined_TregVTconv.csv"),
  row.names = TRUE)

write.csv(results_Treg_IARVMicrobial,
  file = file.path(dataOutputDir, "DGE_Treg_IARVMicrobial.csv"),
  row.names = TRUE)

write.csv(results_Tconv_IARVMicrobial,
  file = file.path(dataOutputDir, "DGE_Tconv_IARVMicrobial.csv"),
  row.names = TRUE)

# rm_tmp(ask = FALSE)
```

```{r pseudobulkDGETregVsTconv}
# Subset down our main seurat object - this can stay the same
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat.tmp, assay = "RNA", layer = "counts")

# Filter genes: keep only those expressed (count > 0) in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# Fetch metadata required for grouping - now including cellType
metadata.tmp <- seurat.tmp@meta.data[, c("cellType", "donorIdFigures")]

# Create a new column for groupDGE that includes cellType and donor
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(cellType, donorIdFigures, sep = "__"))

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Transpose counts for easier manipulation
counts.df.tmp <- as.data.frame(t(counts.tmp))

# Add the grouping information to the counts data frame
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# Aggregate counts by groupDGE
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Verify the aggregated count matrix
dim(countMatrixAggregated.tmp)  # Should be genes x pseudobulked samples
head(countMatrixAggregated.tmp[, 1:5])  # Check first few columns

# Create DGEList object from the aggregated count matrix
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Extract cell type from groupDGE by splitting with "__"
cellTypeGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
cellType <- factor(cellTypeGroups)  # Should be Levels: Treg, Tconv

# Extract donor information for potential blocking factor
donorGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 2)
donor <- factor(donorGroups)

# Create design matrix that accounts for both cell type and stimulation
# Option 1: Simple design comparing cell types
design <- model.matrix(~ 0 + cellType)
colnames(design) <- levels(cellType)

# Verify the design matrix
print(design)

# Apply voom transformation with the design matrix
v <- voom(dgeAggregated.tmp, design, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design)

# Define contrasts for cell type comparison
contrasts <- makeContrasts(
  Treg_vs_Tconv = Treg - Tconv,
  levels = design
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, contrasts)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for the cell type contrast
results_Treg_vs_Tconv <- topTable(
  fit2,
  coef = "Treg_vs_Tconv",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

# add the gene names to a column
results_Treg_vs_Tconv$gene <- rownames(results_Treg_vs_Tconv)

# Add a significance column based on adjusted p-value
results_Treg_vs_Tconv <- results_Treg_vs_Tconv %>%
  mutate(significant = adj.P.Val < 0.05)

# Save results_Treg_vs_Tconv as CSV file
write.csv(results_Treg_vs_Tconv,
  file = file.path(dataOutputDir, "DGE_TregMinusTconv_allStims.csv"),
  row.names = FALSE)

# Clean up temporary variables
rm_tmp(ask = FALSE)
```

```{r pseudobulkDGETregVsTconvByStim}
# subset down our main seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType %in% c("Treg", "Tconv"))

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat.tmp, assay = "RNA", layer = "counts")

# Filter genes: keep only those expressed (count > 0) in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# Fetch metadata required for grouping
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Transpose counts for easier manipulation
counts.df.tmp <- as.data.frame(t(counts.tmp))

# Add the grouping information to the counts data frame
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# Aggregate counts by groupDGE
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Verify the aggregated count matrix
dim(countMatrixAggregated.tmp)  # Should be genes x 18 (3 stimulations x 6 donors)
head(countMatrixAggregated.tmp)

# Create DGEList object from the aggregated count matrix
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Extract stimulation groups from groupDGE by splitting with "__"
stimulationGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
stimulation <- factor(stimulationGroups)  # Levels: IAR, Microbial, Polyclonal

# Create design matrix without intercept
design <- model.matrix(~ 0 + stimulation)
colnames(design) <- levels(stimulation)

# Verify the design matrix
print(design)

# Apply voom transformation with the design matrix
v <- voom(dgeAggregated.tmp, design, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design)

# Define contrasts for stimulation group comparisons
contrasts <- makeContrasts(
  IAR_vs_Microbial = IAR - Microbial,
  IAR_vs_Polyclonal = IAR - Polyclonal,
  Microbial_vs_Polyclonal = Microbial - Polyclonal,
  levels = design
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, contrasts)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_IAR_vs_Microbial <- topTable(
  fit2,
  coef = "IAR_vs_Microbial",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_IAR_vs_Microbial$gene <- rownames(results_IAR_vs_Microbial)

results_IAR_vs_Polyclonal <- topTable(
  fit2,
  coef = "IAR_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_IAR_vs_Polyclonal$gene <- rownames(results_IAR_vs_Polyclonal)

results_Microbial_vs_Polyclonal <- topTable(
  fit2,
  coef = "Microbial_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_Microbial_vs_Polyclonal <- rownames(results_Microbial_vs_Polyclonal)

# Add a significance column based on adjusted p-value
results_Microbial_vs_Polyclonal <- results_Microbial_vs_Polyclonal %>%
  mutate(Significant = adj.P.Val < 0.05)

# rm_tmp(ask = FALSE)
```

```{r pseudobulkDGETconvOnly}
# first subset down our main seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Tconv")
seurat.tmp <- subset(seurat.tmp, stimulationFigures %in% c("IAR", "Microbial"))

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat.tmp, assay = "RNA", layer = "counts")

# Filter genes: keep only those expressed (count > 0) in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# Fetch metadata required for grouping
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Transpose counts for easier manipulation
counts.df.tmp <- as.data.frame(t(counts.tmp))

# Add the grouping information to the counts data frame
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# Aggregate counts by groupDGE
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Verify the aggregated count matrix
dim(countMatrixAggregated.tmp)  # Should be genes x 18 (3 stimulations x 6 donors)
head(countMatrixAggregated.tmp)

# Create DGEList object from the aggregated count matrix
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Extract stimulation groups from groupDGE by splitting with "__"
stimulationGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
stimulation <- factor(stimulationGroups)  # Levels: IAR, Microbial, Polyclonal

# Create design matrix without intercept
design <- model.matrix(~ 0 + stimulation)
colnames(design) <- levels(stimulation)

# Verify the design matrix
print(design)

# Apply voom transformation with the design matrix
v <- voom(dgeAggregated.tmp, design, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design)

# Define contrasts for stimulation group comparisons
contrasts <- makeContrasts(
  IAR_vs_Microbial = IAR - Microbial,
  # IAR_vs_Polyclonal = IAR - Polyclonal,
  # Microbial_vs_Polyclonal = Microbial - Polyclonal,
  levels = design
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, contrasts)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_IAR_vs_MicrobialTconv <- topTable(
  fit2,
  coef = "IAR_vs_Microbial",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

results_IAR_vs_PolyclonalTconv <- topTable(
  fit2,
  coef = "IAR_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

results_Microbial_vs_PolyclonalTconv <- topTable(
  fit2,
  coef = "Microbial_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)

# rm_tmp(ask = FALSE)
```

```{r pseudobulkDGETregVsTconvByStim}

# 3. Filter Seurat Object for Relevant Cell Types and Stimulants
#    - Retain only Treg and Tconv cells
#    - Ensure stimulationFigures includes IAR, Polyclonal, Microbial
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures %in% c("IAR", "Polyclonal", "Microbial"))

# Verify the number of cells after filtering
cat("Number of cells after filtering:", nrow(filtered_cells), "\n")

# 4. Create groupDGE Identifier
#    - Combine cellType, stimulationFigures, and donorId to create unique group identifiers
filtered_cells <- filtered_cells %>%
  mutate(groupDGE = paste(cellType, stimulationFigures, donorIdFigures, sep = "_"))

# Verify the creation of groupDGE
cat("Sample groupDGE identifiers:\n")
print(head(filtered_cells$groupDGE))

# 5. Extract Counts for Filtered Cells
#    - Extract counts corresponding to the filtered cells
counts_filtered <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", layer = "counts")[, rownames(filtered_cells)]

cellCount <- ncol(counts_filtered)
geneFilter <- rowSums(counts_filtered > 0) >= 0.3 * cellCount
counts_filtered <- counts_filtered[geneFilter, ]

# Verify dimensions
cat("Counts dimensions (genes x filtered cells):", dim(counts_filtered), "\n")  # Should be genes x cells

# 6. Transpose Counts Matrix to Cells x Genes
counts_transposed <- t(counts_filtered)  # Now: rows = cells, columns = genes

# Convert to data frame for dplyr operations
counts_df <- as.data.frame(counts_transposed)

# 7. Add groupDGE Information to Each Cell
counts_df$groupDGE <- filtered_cells$groupDGE  # Ensure lengths match: number of cells

# Verify that the number of cells matches
if (nrow(counts_df) != nrow(filtered_cells)) {
  stop("Mismatch between counts_df rows and filtered_cells rows.")
}

# 8. Aggregate Counts by groupDGE by Summing Counts for Each Gene Within Each Group
pseudobulk_counts <- counts_df %>%
  group_by(groupDGE) %>%
  summarise(across(.cols = where(is.numeric), .fns = sum))

# Convert aggregated counts to a matrix
pseudobulk_matrix <- as.data.frame(pseudobulk_counts)
rownames(pseudobulk_matrix) <- pseudobulk_matrix$groupDGE
pseudobulk_matrix <- pseudobulk_matrix[, -1]  # Remove groupDGE column
pseudobulk_matrix <- as.matrix(pseudobulk_matrix)

# 9. Verify Aggregated Counts
cat("Aggregated counts matrix dimensions (groups x genes):", dim(pseudobulk_matrix), "\n")  # e.g., 36 x 21586
cat("Sample names:", colnames(pseudobulk_matrix), "\n")

# 10. Transpose Pseudobulk Matrix to Genes x Samples for edgeR Compatibility
pseudobulk_matrix <- t(pseudobulk_matrix)  # Now: rows = genes, columns = samples

# Verify transposed counts
cat("Transposed counts matrix dimensions (genes x samples):", dim(pseudobulk_matrix), "\n")
cat("Sample names:", colnames(pseudobulk_matrix), "\n")

# 11. Remove Samples with Zero Library Size
zero_lib_samples <- colSums(pseudobulk_matrix) == 0
if (any(zero_lib_samples)) {
  pseudobulk_matrix <- pseudobulk_matrix[, !zero_lib_samples]
  cat("Removed", sum(zero_lib_samples), "samples with zero library size.\n")
} else {
  cat("No samples with zero library size detected.\n")
}

# 12. Create Metadata for Pseudobulk Samples
sample_info <- data.frame(
  sample = colnames(pseudobulk_matrix),
  stringsAsFactors = FALSE
) %>%
  mutate(
    # Split groupDGE into cellType, stimulation, donorId
    cellType = sub("_.*", "", sample),
    stimulation = sub("^[^_]+_([^_]+)_.*$", "\\1", sample),
    donorId = sub("^[^_]+_[^_]+_(.*)$", "\\1", sample)
  )

# Verify metadata
print(head(sample_info))

# 13. Initialize DGEList Object
dge <- DGEList(counts = pseudobulk_matrix)

# 14. Define Group Labels for filterByExpr
# Combine cellType and stimulation to define broad groups (e.g., Treg_IAR, Tconv_Microbial)
sample_info <- sample_info %>%
  mutate(group = paste(cellType, stimulation, sep = "_"))

# Verify group assignments
cat("Group assignments:\n")
print(table(sample_info$group))

# Apply filterByExpr with proper group definitions
keep_genes <- filterByExpr(dge, group = sample_info$group)
dge <- dge[keep_genes, , keep.lib.sizes = FALSE]
cat("Number of genes after filtering:", nrow(dge), "\n")  # Should retain most genes

# Check if any genes remain after filtering
if (nrow(dge) < 1) {
  stop("No genes passed the filtering criteria. Adjust the filtering parameters or check the count data.")
}

# 15. Normalize the Data Using TMM Normalization
dge <- calcNormFactors(dge, method = "TMM")

# 16. Perform DGE Analysis for Each Stimulation Condition
stimulants <- unique(sample_info$stimulation)

# Initialize a list to store results
dge_results <- list()

for (stim in stimulants) {

  cat("Processing stimulation:", stim, "\n")

  # Subset samples for the current stimulation
  stim_samples <- sample_info %>%
    filter(stimulation == stim)

  # Extract counts for these samples
  stim_counts <- dge$counts[, stim_samples$sample]

  # Define group (Treg vs Tconv)
  stim_groups <- stim_samples$cellType

  # Ensure that both groups have samples
  if (length(unique(stim_groups)) < 2) {
    warning(paste("Stimulation", stim, "does not have both Treg and Tconv groups. Skipping this stimulation."))
    next
  }

  # Create DGEList for the current stimulation
  dge_stim <- DGEList(counts = stim_counts, group = stim_groups)

  # Normalize if not already done
  dge_stim <- calcNormFactors(dge_stim, method = "TMM")

  # Create design matrix with group
  design <- model.matrix(~ 0 + stim_groups)
  colnames(design) <- levels(factor(stim_groups))

  # Apply voom transformation
  v <- voom(dge_stim, design, plot = TRUE)

  # Fit the linear model
  fit <- lmFit(v, design)

  # Define contrast: Treg vs Tconv
  contrast_matrix <- makeContrasts(Treg_vs_Tconv = Treg - Tconv, levels = design)

  # Apply contrasts to the fitted model
  fit2 <- contrasts.fit(fit, contrast_matrix)

  # Apply empirical Bayes moderation
  fit2 <- eBayes(fit2)

  # Extract results
  results <- topTable(fit2, coef = "Treg_vs_Tconv", adjust.method = "BH", sort.by = "P", number = Inf)

  # Annotate significant genes
  results <- results %>%
    mutate(Significant = adj.P.Val < 0.05 & abs(logFC) > 1)

  # add gene name column
  results$gene <- rownames(results)

  # Save results to list
  dge_results[[stim]] <- results

  # Save results to CSV
  write.csv(results, file.path(dataOutputDir, paste0("Treg_vs_Tconv_", stim, "_results.csv")), row.names = TRUE)

  cat("Completed DGE for stimulation:", stim, "\n")
}

cat("All DGE analyses completed and results saved.\n")
```

```{r pseudobulkDGEAllTconvTregCellsStimulation}
# subset the seurat object down to just called Treg/Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat_subset.tmp, assay = "RNA", layer = "counts")

# Fetch metadata required for grouping
metadata.tmp <- seurat_subset.tmp@meta.data[, c("stimulationFigures", "donorIdFigures")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Transpose counts for easier manipulation
counts.df.tmp <- as.data.frame(t(counts.tmp))

# Add the grouping information to the counts data frame
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# Aggregate counts by groupDGE
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Verify the aggregated count matrix
dim(countMatrixAggregated.tmp)  # Should be genes x 18 (3 stimulations x 6 donors)
head(countMatrixAggregated.tmp)

# Create DGEList object from the aggregated count matrix
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Extract stimulation groups from groupDGE by splitting with "__"
stimulationGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
stimulation <- factor(stimulationGroups)  # Levels: IAR, Microbial, Polyclonal

# Create design matrix without intercept
design <- model.matrix(~ 0 + stimulation)
colnames(design) <- levels(stimulation)

# Verify the design matrix
print(design)

# Apply voom transformation with the design matrix
v <- voom(dgeAggregated.tmp, design, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design)

# Define contrasts for stimulation group comparisons
contrasts <- makeContrasts(
  IAR_vs_Microbial = IAR - Microbial,
  IAR_vs_Polyclonal = IAR - Polyclonal,
  Microbial_vs_Polyclonal = Microbial - Polyclonal,
  levels = design
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, contrasts)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_IAR_vs_Microbial <- topTable(
  fit2,
  coef = "IAR_vs_Microbial",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_IAR_vs_Microbial$gene <- rownames(results_IAR_vs_Microbial)

results_IAR_vs_Polyclonal <- topTable(
  fit2,
  coef = "IAR_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_IAR_vs_Polyclonal$gene <- rownames(results_IAR_vs_Polyclonal)

results_Microbial_vs_Polyclonal <- topTable(
  fit2,
  coef = "Microbial_vs_Polyclonal",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_Microbial_vs_Polyclonal$gene <- rownames(results_Microbial_vs_Polyclonal)

# Add a significance column based on adjusted p-value and log fold change
results_Microbial_vs_Polyclonal <- results_Microbial_vs_Polyclonal %>%
  mutate(Significant = adj.P.Val < 0.05 & abs(logFC) > 1)

# rm_tmp(ask = FALSE)
```

```{r pseudobulkDGEAllTconvTregCellsStudyGroup}
# subset the seurat object down to just called Treg/Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))

# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seurat_subset.tmp, assay = "RNA", layer = "counts")

# Fetch metadata required for grouping
metadata.tmp <- seurat_subset.tmp@meta.data[, c("studyGroup", "donorIdFigures")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(studyGroup, donorIdFigures, sep = "__"))

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Transpose counts for easier manipulation
counts.df.tmp <- as.data.frame(t(counts.tmp))

# Add the grouping information to the counts data frame
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

# Aggregate counts by groupDGE
pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum))

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Verify the aggregated count matrix
dim(countMatrixAggregated.tmp)  # Should be genes x 18 (3 stimulations x 6 donors)
head(countMatrixAggregated.tmp)

# Create DGEList object from the aggregated count matrix
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Extract stimulation groups from groupDGE by splitting with "__"
stimulationGroups <- sapply(strsplit(colnames(countMatrixAggregated.tmp), "__"), `[`, 1)
stimulation <- factor(stimulationGroups)  # Levels: IAR, Microbial, Polyclonal

# Create design matrix without intercept
design <- model.matrix(~ 0 + stimulation)
colnames(design) <- levels(stimulation)

# Verify the design matrix
print(design)

# Apply voom transformation with the design matrix
v <- voom(dgeAggregated.tmp, design, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design)

# Define contrasts for stimulation group comparisons
contrasts <- makeContrasts(
  T1DVsControl = T1D - Control,
  levels = design
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, contrasts)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_T1DVsControl <- topTable(
  fit2,
  coef = "T1DVsControl",
  adjust.method = "BH",
  sort.by = "P",
  number = Inf
)
results_T1DVsControl$gene <- rownames(results_T1DVsControl)

# Add a significance column based on adjusted p-value and log fold change
# results_Microbial_vs_Polyclonal <- results_Microbial_vs_Polyclonal %>%
#   mutate(Significant = adj.P.Val < 0.05 & abs(logFC) > 1)

# rm_tmp(ask = FALSE)
```

```{r DGEVolcanoTregOnly}
## ex volcano plot
# Add a significance column based on adjusted p-value and log fold change
results_IAR_vs_Microbial <- results_IAR_vs_Microbial %>%
  mutate(Significant = adj.P.Val < 0.05 & abs(logFC) > 1)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_IARvsCEFX_Volcano", ".pdf")),
height = 5,
width = 6)

# Create the volcano plot
volc.plot <- ggplot(results_IAR_vs_Microbial, aes(x = logFC, y = -log10(adj.P.Val), color = Significant)) +
  geom_point(alpha = 0.6) +
  scale_color_manual(values = c("grey", "red")) +
  theme_minimal() +
  labs(
    title = "Volcano Plot: IAR vs Microbial",
    x = "Log2 Fold Change",
    y = "-Log10 Adjusted P-Value"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

print(volc.plot)

dev.off()
```

```{r DGEHeatmapsTregOnly}
seurat.tmp <- subset(seuratQCMergedCleaned, cellType == "Treg")

# 1. Select top 30 positive and top 30 negative DE genes (using results_IAR_vs_Microbial)
top_genes <- results_IAR_vs_Microbial %>%
  tibble::rownames_to_column(var = "gene") %>%
  dplyr::filter(adj.P.Val < 0.05) %>%
  dplyr::arrange(desc(logFC)) %>%
  dplyr::slice(1:30) %>%
  dplyr::bind_rows(
    results_IAR_vs_Microbial %>%
      tibble::rownames_to_column(var = "gene") %>%
      dplyr::filter(adj.P.Val < 0.05) %>%
      dplyr::arrange(logFC) %>%
      dplyr::slice(1:30)
  ) %>%
  dplyr::pull(gene)


# 2. Filter metadata: restrict to Treg cells with stimulation IAR or Microbial
filtered_cells <- seurat.tmp@meta.data %>%
  filter(stimulationFigures %in% c("IAR", "Microbial")) %>%
  # Create composite grouping: stimulation and donor ID:
  mutate(group = paste(stimulationFigures, donorIdFigures, sep = "_"))

# 3. Extract normalized expression data for selected top genes
expressionMatrix <- GetAssayData(seurat.tmp, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Pseudobulk by composite group: aggregate by taking the mean expression per (stimulation, donor)
expr_df <- as.data.frame(t(expressionMatrix))
expr_df$group <- filtered_cells$group
aggregated_counts <- expr_df %>%
  group_by(group) %>%
  summarise(across(everything(), mean))
aggregated_counts <- as.data.frame(aggregated_counts)
rownames(aggregated_counts) <- aggregated_counts$group
agg_matrix <- as.matrix(aggregated_counts[, -1])
agg_matrix <- t(agg_matrix)  # now rows = genes and columns = composite groups

# 5. Compute z-scores for each gene across composite groups
z_scores <- t(scale(t(agg_matrix)))
# Assuming you already have:
# donor_metadata with a column "group" like "IAR_1_Control"
donor_metadata <- donor_metadata %>%
  mutate(
    stimulation = sapply(strsplit(group, "_"), `[`, 1),
    donor = sapply(strsplit(group, "_"), `[`, 2),
    study = sapply(strsplit(group, "_"), `[`, 3),
    donorLabel = paste(donor, study, sep = "_")
  )

# Now create a top annotation with two rows: stimulation and donor.
ha <- HeatmapAnnotation(
  stimulation = donor_metadata$stimulation,
  donor = donor_metadata$donorLabel,
  col = list(
    stimulation = palStimulation,   # your stimulation palette
    donor = palDonorId              # your donor palette: keys like "1_Control", etc.
  ),
  annotation_height = unit(c(4, 4), "mm")
)

# Create the heatmap; remove x-axis labels so that only the annotation bar is visible.
hm_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))
heatmap_tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = ha,
  show_row_names = TRUE,
  show_column_names = FALSE,  # remove x-tick labels
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = donor_metadata$stimulation,
  col = hm_colors,
  border = TRUE,
  row_title = "Genes",
  column_title = "Islet - CEFX"
)

# Save the heatmap to a PDF file
pdf(file.path(plotDir, paste0(filenameSuffix, "Treg_IAR_vs_Microbial_heatmap_pseudobulk.pdf")),
  height = 9, width = 9)
print(heatmap_tmp)
dev.off()















## ------------------------------IAR minus Microbial------------------------------------------------------

# Select top 50 genes based on adjusted p-value
topGenes.tmp <- head(rownames(results_IAR_vs_Microbial), 50)

# Extract expression data for these genes
logCpm.tmp <- edgeR::cpm(dgeAggregated.tmp, log = TRUE)[topGenes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Treg", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
# pseudobulkMetadata.tmp <- metadata.tmp %>%
#   group_by(groupDGE) %>%
#   summarise(
#     seurat_clusters_Treg = first(seurat_clusters_Treg),
#     stimulationFigures = first(stimulationFigures),
#     studyGroup = first(studyGroup),
#     pool = first(pool)
#   )

pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Treg = head(seurat_clusters_Treg, 1),
    stimulationFigures = head(stimulationFigures, 1),
    studyGroup = head(studyGroup, 1),
    pool = head(pool, 1)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Treg = pseudobulkMetadata.tmp$seurat_clusters_Treg,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Treg = palRNAClusters,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Microbial)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Treg
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_IARvsCEFX_top50Heatmap_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Microbial)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_IARvsCEFX_top50Heatmap_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

## ------------------------------IAR minus Polyclonal------------------------------------------------------
# Select top 50 genes based on adjusted p-value
topGenes.tmp <- head(rownames(results_IAR_vs_Polyclonal), 50)

# Extract expression data for these genes
logCpm.tmp <- edgeR::cpm(dgeAggregated.tmp, log = TRUE)[topGenes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Treg", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Treg = first(seurat_clusters_Treg),
    stimulationFigures = first(stimulationFigures),
    studyGroup = first(studyGroup),
    pool = first(pool)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Treg = pseudobulkMetadata.tmp$seurat_clusters_Treg,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Treg = palRNAClusters,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Treg
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_IARvsPolyclonal_top50Heatmap_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_IARvsPolyclonal_top50Heatmap_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

## ------------------------------Microbial minus Polyclonal------------------------------------------------------

# Select top 50 genes based on adjusted p-value
topGenes.tmp <- head(rownames(results_Microbial_vs_Polyclonal), 50)

# Extract expression data for these genes
logCpm.tmp <- edgeR::cpm(dgeAggregated.tmp, log = TRUE)[topGenes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seurat.tmp@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Treg", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Treg = first(seurat_clusters_Treg),
    stimulationFigures = first(stimulationFigures),
    studyGroup = first(studyGroup),
    pool = first(pool)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Treg = pseudobulkMetadata.tmp$seurat_clusters_Treg,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Treg = palRNAClusters,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (CEFX minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Treg
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_MicrobialvsPolyclonal_top50Heatmap_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (CEFX minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregOnly_MicrobialvsPolyclonal_top50Heatmap_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# rm_tmp(ask = FALSE)
```

```{r DGEHeatmapsTconvOnly}

## ------------------------------IAR minus Microbial------------------------------------------------------

# Select top 50 genes based on adjusted p-value
topGenes.tmp <- head(rownames(results_IAR_vs_MicrobialTconv), 50)

# Extract expression data for these genes
logCpm.tmp <- cpm(dgeAggregated.tmp, log = TRUE)[topGenes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seuratTconv@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Tconv", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Tconv = first(seurat_clusters_Tconv),
    stimulationFigures = first(stimulationFigures),
    studyGroup = first(studyGroup),
    pool = first(pool)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Tconv = pseudobulkMetadata.tmp$seurat_clusters_Tconv,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Tconv = palRNAClusters,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Microbial)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Tconv
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TconvOnly_IARvsCEFX_top50Heatmap_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Microbial)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TconvOnly_IARvsCEFX_top50Heatmap_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

## ------------------------------IAR minus Polyclonal------------------------------------------------------
# Select top 50 genes based on adjusted p-value
topGenes.tmp <- head(rownames(results_IAR_vs_PolyclonalTconv), 50)

# Extract expression data for these genes
logCpm.tmp <- cpm(dgeAggregated.tmp, log = TRUE)[topGenes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seuratTconv@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Tconv", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Tconv = first(seurat_clusters_Tconv),
    stimulationFigures = first(stimulationFigures),
    studyGroup = first(studyGroup),
    pool = first(pool)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Tconv = pseudobulkMetadata.tmp$seurat_clusters_Tconv,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Tconv = palRNAClusters,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Tconv
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TconvOnly_IARvsPolyclonal_top50Heatmap_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (IAR minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TconvOnly_IARvsPolyclonal_top50Heatmap_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

## ------------------------------Microbial minus Polyclonal------------------------------------------------------

# Select top 50 genes based on adjusted p-value
topGenes.tmp <- head(rownames(results_Microbial_vs_Polyclonal), 50)

# Extract expression data for these genes
logCpm.tmp <- cpm(dgeAggregated.tmp, log = TRUE)[topGenes.tmp, ]

# Z-score normalize the expression data
logCpm.tmp <- t(scale(t(logCpm.tmp)))

# Extract relevant metadata columns
metadata.tmp <- seuratTconv@meta.data[, c("stimulationFigures", "donorIdFigures", "seurat_clusters_Tconv", "studyGroup", "pool")]

# Create a new column for groupDGE with a consistent separator (e.g., "__")
metadata.tmp <- metadata.tmp %>%
  mutate(groupDGE = paste(stimulationFigures, donorIdFigures, sep = "__"))

# Aggregate metadata by groupDGE
pseudobulkMetadata.tmp <- metadata.tmp %>%
  group_by(groupDGE) %>%
  summarise(
    seurat_clusters_Tconv = first(seurat_clusters_Tconv),
    stimulationFigures = first(stimulationFigures),
    studyGroup = first(studyGroup),
    pool = first(pool)
  )

# Ensure the rownames of pseudobulk_metadata match the colnames of logCpm.tmp
rownames(pseudobulkMetadata.tmp) <- pseudobulkMetadata.tmp$groupDGE
pseudobulkMetadata.tmp <- pseudobulkMetadata.tmp[, -1]  # Remove the groupDGE column

# Define column annotations using predefined color palettes
heatmapAnnotation.tmp <- HeatmapAnnotation(
  seurat_clusters_Tconv = pseudobulkMetadata.tmp$seurat_clusters_Tconv,
  stimulationFigures = pseudobulkMetadata.tmp$stimulationFigures,
  studyGroup = pseudobulkMetadata.tmp$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    seurat_clusters_Tconv = palRNAClusters,
    stimulationFigures = palStimulation,
    studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# Create the heatmap (clusterColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (CEFX minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$seurat_clusters_Tconv
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TconvOnly_MicrobialvsPolyclonal_top50Heatmap_columnsByCluster", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# Create the heatmap (stimulationColumns)
heatmap.tmp <- Heatmap(
  logCpm.tmp,
  name = "log2 CPM",
  top_annotation = heatmapAnnotation.tmp,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Top 50 DE Genes (CEFX minus Polyclonal)",
  heatmap_legend_param = list(title = "logCPM Expression\nz-score"),
  column_split = pseudobulkMetadata.tmp$stimulationFigures
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TconvOnly_MicrobialvsPolyclonal_top50Heatmap_columnsByStimulation", ".pdf")),
height = 8,
width = 9)

print(heatmap.tmp)

dev.off()

# rm_tmp(ask = FALSE)
```

```{r DGETregVsTconvHeatmapAllStims}
# heatmaps for Treg - Tconv within each stimulation
DGETable.tmp <- read.csv(paste0(dataOutputDir, "/DGE_Combined_TregVTconv.csv"))

# ==========================top 60 p val=====================================================
nGenes <- 60

# 1. Select top N = 60 genes by smallest adjusted p-value from DGEIAR
top_genes <- DGETable.tmp %>%
  dplyr::arrange(adj.P.Val) %>%   # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%          # Select the top 50 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"))

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

# 4. Aggregate expression data by donorId_cellType using the mean
aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  summarise(across(everything(), mean))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv")) %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 7. Reorder columns: Treg on the left, Tconv on the right
cell_type_order <- factor(filtered_metadata$cellType, levels = c("Treg", "Tconv"))
column_order <- order(cell_type_order)  # Treg first, Tconv second

# Reorder z_scores and filtered_metadata
z_scores <- z_scores[, column_order]
filtered_metadata <- filtered_metadata[column_order, ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))
set.seed(1)
# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  # column_split = factor(as.character(filtered_metadata$cellType), levels = c("Treg", "Tconv")),
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_allStims_heatmap_top60Pval", ".pdf")),
height = 10,
width = 9)

print(heatmap.tmp)

dev.off()
```

```{r DGEHeatmapsTregVsTconvIAR}
nGenes <- 60

# heatmaps for Treg - Tconv within each stimulation
DGEIAR <- read.csv(paste0(dataOutputDir, "/DGE_IAR_TregVTconv.csv"))

# ==========================top N p val=====================================================

# 1. Select top N genes by smallest adjusted p-value from DGEIAR
top_genes <- DGEIAR %>%
  dplyr::filter(!stringr::str_starts(gene, "RP")) %>%  # Optional: exclude ribosomal genes
  dplyr::arrange(adj.P.Val) %>%   # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%          # Select the top N genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "IAR")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

# 4. Aggregate expression data by donorId_cellType using the mean
aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  summarise(across(everything(), mean))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "IAR") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  # column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_IAR_heatmap_top60Pval_noRibosomalGenes", ".pdf")),
height = 10,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 60 by abs(logFC)=====================================================
# 1. Select top 60 genes by abs(logFC) from DGEIAR
top_genes <- DGEIAR %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(abs(logFC))) %>%  # Sort by absolute value of logFC in descending order
  dplyr::slice(1:60) %>%                # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "IAR")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "IAR") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_IAR_heatmap_top60_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 30 +logFC and top 30 -logFC=====================================================
top_genes <- DGEIAR %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(logFC)) %>%      # Sort by logFC in descending order
  dplyr::slice(1:30) %>%               # Select the top 30 positive logFC genes
  dplyr::bind_rows(
    DGEIAR %>%
      dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
      dplyr::arrange(logFC) %>%            # Sort by logFC in ascending order
      dplyr::slice(1:30)                   # Select the top 30 negative logFC genes
  ) %>%
  dplyr::pull(gene)                       # Extract the gene names

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "IAR")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "IAR") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]
# Make sure filtered_metadata$cellType is ordered with Treg first, then Tconv
filtered_metadata$cellType <- factor(filtered_metadata$cellType, levels = c("Treg", "Tconv"))

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)


# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = FALSE,  # disable column clustering to preserve order
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)
pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_IAR_heatmap_topBottom30_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r DGEHeatmapsTregVsTconvMicrobial}
nGenes <- 60

# heatmaps for Treg - Tconv within each stimulation
DGEMicrobial <- read.csv(paste0(dataOutputDir, "/DGE_Microbial_TregVTconv.csv"))

# ==========================top 50 p val=====================================================

# 1. Select top 50 genes by smallest adjusted p-value from DGEIAR
top_genes <- DGEMicrobial %>%
  dplyr::filter(!stringr::str_starts(gene, "RP")) %>%  # Optional: exclude ribosomal genes
  dplyr::arrange(adj.P.Val) %>%   # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%          # Select the top 50 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

# 4. Aggregate expression data by donorId_cellType using the mean
aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  summarise(across(everything(), mean))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  # column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Microbial_heatmap_top60Pval_noRibosomalGenes", ".pdf")),
height = 10,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 60 by abs(logFC)=====================================================
# 1. Select top 60 genes by abs(logFC) from DGEIAR
top_genes <- DGEMicrobial %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(abs(logFC))) %>%  # Sort by absolute value of logFC in descending order
  dplyr::slice(1:60) %>%                # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Microbial_heatmap_top60_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 30 +logFC and top 30 -logFC=====================================================
top_genes <- DGEMicrobial %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(logFC)) %>%      # Sort by logFC in descending order
  dplyr::slice(1:30) %>%               # Select the top 30 positive logFC genes
  dplyr::bind_rows(
    DGEIAR %>%
      dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
      dplyr::arrange(logFC) %>%            # Sort by logFC in ascending order
      dplyr::slice(1:30)                   # Select the top 30 negative logFC genes
  ) %>%
  dplyr::pull(gene)                       # Extract the gene names

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)


# Ensure the order of metadata matches the samples in z_scores
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# Set cell type order: Treg on left, Tconv on right
filtered_metadata$cellType <- factor(filtered_metadata$cellType, levels = c("Treg", "Tconv"))

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  col = list(
    donorId = palDonorId,
    cellType = palCellType
  )
)

# 8. Define color function for the heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 9. Create the heatmap, splitting columns by cellType
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Microbial_heatmap_topBottom30_abslogFC", ".pdf")),
height = 9, width = 9)
print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```
```{r DGEHeatmapsTregVsTconvPolyclonal}
# Number of genes to select
nGenes <- 60

# Read in the differential gene expression results
DGEPolyclonal <- read.csv(paste0(dataOutputDir, "/DGE_Polyclonal_TregVTconv.csv"))

# ========================== Top 60 genes by adjusted p-value ===============================

# 1. Select top 60 genes by smallest adjusted p-value
top_genes <- DGEPolyclonal %>%
  dplyr::filter(!stringr::str_starts(gene, "RP")) %>%  # Optional: exclude ribosomal genes
  dplyr::arrange(adj.P.Val) %>%   # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%     # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

# Aggregate expression data by donorId_cellType using the mean
aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  summarise(across(everything(), mean))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 7. Reorder columns to have Treg on the left and Tconv on the right
column_order <- order(filtered_metadata$cellType, decreasing = TRUE)  # Treg first, Tconv second
z_scores <- z_scores[, column_order]
filtered_metadata <- filtered_metadata[column_order, ]

# 8. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  col = list(
    donorId = palDonorId,
    cellType = palCellType
  )
)

# 9. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 10. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  # column_split = filtered_metadata$cellType,  # Split columns by cell type
  col = heatmap_colors,
  border = TRUE
)

# Save the heatmap to a PDF
pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Polyclonal_heatmap_top60Pval_noRibosomalGenes", ".pdf")),
height = 10,
width = 9)

print(heatmap.tmp)

dev.off()





nGenes <- 60

# heatmaps for Treg - Tconv within each stimulation
DGEPolyclonal <- read.csv(paste0(dataOutputDir, "/Treg_vs_Tconv_Polyclonal_results.csv"))

# ==========================top 50 p val=====================================================

# 1. Select top genes by smallest adjusted p-value
top_genes <- DGEPolyclonal %>%
  dplyr::arrange(adj.P.Val) %>%
  dplyr::slice(1:nGenes) %>%
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  summarise(across(everything(), mean))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create metadata first
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Extract cellType from donorId_cellType for columns
column_cellTypes <- sapply(strsplit(colnames(z_scores), "_"), function(x) x[length(x)])

# 7. Create factor for cellType with explicit order - Treg first (left), Tconv second (right)
cell_type_factor <- factor(column_cellTypes, levels = c("Treg", "Tconv"))

# Reorder the z_scores matrix based on the cell type factor
z_scores <- z_scores[, order(cell_type_factor)]

# Reorder metadata to match z_scores column order
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 8. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  col = list(
    donorId = palDonorId,
    cellType = palCellType
  )
)

# 9. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 10. Create the heatmap with Tregs on left, Tconv on right
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = factor(filtered_metadata$cellType, levels = c("Treg", "Tconv")),
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Polyclonal_heatmap_top60Pval", ".pdf")),
height = 10,
width = 9)

print(heatmap.tmp)

dev.off()







# ==========================top 60 by abs(logFC)=====================================================
# 1. Select top 60 genes by abs(logFC) from DGEIAR
top_genes <- DGEPolyclonal %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(abs(logFC))) %>%  # Sort by absolute value of logFC in descending order
  dplyr::slice(1:60) %>%                # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Polyclonal_heatmap_top60_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 30 +logFC and top 30 -logFC=====================================================
top_genes <- DGEPolyclonal %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(logFC)) %>%      # Sort by logFC in descending order
  dplyr::slice(1:30) %>%               # Select the top 30 positive logFC genes
  dplyr::bind_rows(
    DGEIAR %>%
      dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
      dplyr::arrange(logFC) %>%            # Sort by logFC in ascending order
      dplyr::slice(1:30)                   # Select the top 30 negative logFC genes
  ) %>%
  dplyr::pull(gene)                       # Extract the gene names

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Polyclonal") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Polyclonal_heatmap_topBottom30_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```
```{r DGEHeatmapsTregVsTconvMicrobial}
# heatmaps for Treg - Tconv within each stimulation
DGEMicrobial <- read.csv(paste0(dataOutputDir, "/Treg_vs_Tconv_Microbial_results.csv"))

# ==========================top 50 p val=====================================================

# 1. Select top 50 genes by smallest adjusted p-value from DGEIAR
top_genes <- DGEIAR %>%
  dplyr::arrange(adj.P.Val) %>%   # Sort by adjusted p-value in ascending order
  dplyr::slice(1:60) %>%          # Select the top 50 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Microbial_heatmap_top60Pval", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 60 by abs(logFC)=====================================================
# 1. Select top 60 genes by abs(logFC) from DGEIAR
top_genes <- DGEMicrobial %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(abs(logFC))) %>%  # Sort by absolute value of logFC in descending order
  dplyr::slice(1:60) %>%                # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Microbial_heatmap_top60_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 30 +logFC and top 30 -logFC=====================================================
top_genes <- DGEMicrobial %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(logFC)) %>%      # Sort by logFC in descending order
  dplyr::slice(1:30) %>%               # Select the top 30 positive logFC genes
  dplyr::bind_rows(
    DGEIAR %>%
      dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
      dplyr::arrange(logFC) %>%            # Sort by logFC in ascending order
      dplyr::slice(1:30)                   # Select the top 30 negative logFC genes
  ) %>%
  dplyr::pull(gene)                       # Extract the gene names

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial")

# Create donorId_cellType variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleanedDS, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_cellType
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_cellType <- filtered_cells$donorId_cellType

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_cellType) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_cellType

# Transpose to have genes as rows and donorId_cellType as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe
metadata <- seuratQCMergedCleanedDS@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures == "Microbial") %>%
  dplyr::mutate(donorId_cellType = paste(donorIdFigures, cellType, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters, donorId_cellType, cellType)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_cellType), ]

# 5. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  # seurat_clusters = filtered_metadata$seurat_clusters,
  donorId = filtered_metadata$donorIdFigures,
  cellType = filtered_metadata$cellType,
  # studyGroup = filtered_metadata$studyGroup,
  # pool = pseudobulkMetadata.tmp$pool,
  col = list(
    # seurat_clusters = palRNAClusters,
    donorId = palDonorId,
    cellType = palCellType
    # studyGroup = palStudyGroup # ,
    # pool = c("1" = "blue", "2" = "red")
  )
)

# 6. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 7. Create the heatmap
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$cellType,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregMinTconv_Microbial_heatmap_topBottom30_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r DGEHeatmapsIARVsCEFXTreg}
# heatmaps for Treg - Tconv within each stimulation
nGenes <- 60

# heatmaps for Treg - Tconv within each stimulation
results_IAR_vs_Microbial <- read.csv(paste0(dataOutputDir, "/DGE_Treg_IARVMicrobial.csv"))

# ==========================top N p val=====================================================

# 1. Select top 50 genes by smallest adjusted p-value from DGEIAR
top_genes <- results_IAR_vs_Microbial %>%
  # dplyr::filter(!stringr::str_starts(gene, "RP")) %>%  # Optional: exclude ribosomal genes
  dplyr::arrange(adj.P.Val) %>%   # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%          # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType == "Treg",
    stimulationFigures %in% c("IAR", "Microbial"))

# Create donorId_stim variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_stim
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_stim <- filtered_cells$donorId_stim

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_stim) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_stim

# Transpose to have genes as rows and donorId_stim as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe using stimulationFigures instead of cellType
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg"),
    stimulationFigures %in% c("IAR", "Microbial")) %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, stimulationFigures, donorId_stim)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_stim), ]

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  stimulation = filtered_metadata$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 9. Create the heatmap, splitting columns by stimulationFigures
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$stimulationFigures,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "IARMinCEFX_heatmap_top60Pval", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 60 by abs(logFC)=====================================================
# 1. Select top 60 genes by abs(logFC) from DGEIAR
top_genes <- results_IAR_vs_Microbial %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(abs(logFC))) %>%  # Sort by absolute value of logFC in descending order
  dplyr::slice(1:60) %>%                # Select the top 60 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures %in% c("IAR", "Microbial"))

# Create donorId_stim variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_stim
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_stim <- filtered_cells$donorId_stim

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_stim) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_stim

# Transpose to have genes as rows and donorId_stim as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe using stimulationFigures instead of cellType
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures %in% c("IAR", "Microbial")) %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, stimulationFigures, donorId_stim)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_stim), ]

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  stimulation = filtered_metadata$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 9. Create the heatmap, splitting columns by stimulationFigures
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$stimulationFigures,
  col = heatmap_colors,
  border = TRUE
)


pdf(file.path(plotDir,
  paste0(filenameSuffix, "IARMinCEFX_heatmap_top60_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

# ==========================top 30 +logFC and top 30 -logFC=====================================================
top_genes <- results_IAR_vs_Microbial %>%
  dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
  dplyr::arrange(desc(logFC)) %>%      # Sort by logFC in descending order
  dplyr::slice(1:30) %>%               # Select the top 30 positive logFC genes
  dplyr::bind_rows(
    results_IAR_vs_Microbial %>%
      dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
      dplyr::arrange(logFC) %>%            # Sort by logFC in ascending order
      dplyr::slice(1:30)                   # Select the top 30 negative logFC genes
  ) %>%
  dplyr::pull(gene)                       # Extract the gene names

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures %in% c("IAR", "Microbial"))

# Create donorId_stim variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_"))

# 3. Extract normalized expression data for top genes
# Assuming 'data' slot contains log-normalized data
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_stim
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_stim <- filtered_cells$donorId_stim

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_stim) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_stim

# Transpose to have genes as rows and donorId_stim as columns
aggregated_matrix <- t(aggregated_matrix)

# 5. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe using stimulationFigures instead of cellType
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures %in% c("IAR", "Microbial")) %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, stimulationFigures, donorId_stim)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_stim), ]

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  stimulation = filtered_metadata$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 9. Create the heatmap, splitting columns by stimulationFigures
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_split = filtered_metadata$stimulationFigures,
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "IARMinCEFX_heatmap_topBottom30_abslogFCTreg", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r DGEHeatmapTregVsTconv}

# Extract results for each contrast
results_IAR_vs_Microbial

results_IAR_vs_Polyclonal

results_Microbial_vs_Polyclonal

# ==========================top 50 genes by adj.p.val=====================================================
nGenes <- 60
results_Microbial_vs_Polyclonal$gene <- rownames(results_Microbial_vs_Polyclonal)
# top_genes <- results_IAR_vs_MicrobialTreg %>%
#   dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
#   dplyr::arrange(desc(logFC)) %>%      # Sort by logFC in descending order
#   dplyr::slice(1:30) %>%               # Select the top 30 positive logFC genes
#   dplyr::bind_rows(
#     results_IAR_vs_MicrobialTreg %>%
#       dplyr::filter(adj.P.Val < 0.05) %>%  # Filter to adj.P.Val smaller than 0.05
#       dplyr::arrange(logFC) %>%            # Sort by logFC in ascending order
#       dplyr::slice(1:30)                   # Select the top 30 negative logFC genes
#   ) %>%
#   dplyr::pull(gene)                       # Extract the gene names

top_genes <- results_Microbial_vs_Polyclonal %>%
  dplyr::filter(adj.P.Val < 0.05) %>%   # Filter to adj.P.Val < 0.05
  dplyr::arrange(adj.P.Val) %>%         # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%                # Select the top 50 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv"),
    stimulationFigures %in% c("Polyclonal", "Microbial"))

# Create donorId_stim variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_"))

# 3. Extract raw counts for top genes (instead of log-normalized values)
rawExpressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "counts")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_stim
rawExpressionMatrix_df <- as.data.frame(t(rawExpressionMatrix))
rawExpressionMatrix_df$donorId_stim <- filtered_cells$donorId_stim

aggregated_counts <- rawExpressionMatrix_df %>%
  group_by(donorId_stim) %>%
  summarise(across(everything(), sum))

# Convert aggregated counts to a matrix (genes x donors)
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_stim
aggregated_matrix <- t(aggregated_matrix)  # now rows = genes, columns = donors

# Ensure aggregated_matrix is numeric
aggregated_matrix <- matrix(as.numeric(aggregated_matrix),
  nrow = nrow(aggregated_matrix),
  dimnames = dimnames(aggregated_matrix))
dge <- DGEList(counts = aggregated_matrix)
normCPM <- edgeR::cpm(dge, log = TRUE)

# 6. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(normCPM)))

# 6. Create annotation dataframe using stimulationFigures instead of cellType
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg"),
    stimulationFigures %in% c("IAR", "Microbial")) %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, stimulationFigures, donorId_stim)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_stim), ]


# Ensure the order: Microbial (left) then IAR (right)
filtered_metadata$stimulationFigures <- factor(filtered_metadata$stimulationFigures,
  levels = c("Microbial", "IAR"))
print(levels(filtered_metadata$stimulationFigures))
# Order the columns based on the stimulationFigures factor levels
column_order <- order(filtered_metadata$stimulationFigures)

# Reorder z_scores based on column_order
z_scores_ordered <- z_scores[, column_order]

# Reorder metadata based on column_order
filtered_metadata_ordered <- filtered_metadata[column_order, ]

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata_ordered$donorIdFigures,
  stimulation = filtered_metadata_ordered$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# Create the heatmap object with reordered z_scores
heatmap.tmp <- Heatmap(
  z_scores_ordered,
  name = "Z-score",
  top_annotation = heatmapAnnotation,  # your annotation bar at the top
  show_row_names = TRUE,
  show_column_names = FALSE,           # drop the bottom column labels
  cluster_rows = TRUE,
  cluster_columns = TRUE,              # cluster columns within each group
  column_split = filtered_metadata_ordered$stimulationFigures,  # uses factor order: Microbial then IAR
  col = heatmap_colors,
  border = TRUE
)


# Draw the reordered heatmap
draw(heatmap.tmp)
pdf(file.path(plotDir,
  paste0(filenameSuffix, "IARMinCEFXTreg_heatmap_top50GenesAdjPVal_", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```


```{r DGEHeatmapTregIARMinusCEFX, message=FALSE, warning=FALSE}

nGenes <- 60

results_IAR_vs_MicrobialTreg <- read.csv(paste0(dataOutputDir, "/DGE_Treg_IARVMicrobial.csv"))
# ==========================top N genes by adj.p.val=====================================================
top_genes <- results_IAR_vs_MicrobialTreg %>%
  dplyr::filter(adj.P.Val < 0.05) %>%   # Filter to adj.P.Val < 0.05
  dplyr::arrange(adj.P.Val) %>%         # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%                # Select the top 50 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg"),
    stimulationFigures %in% c("IAR", "Microbial"))

# Create donorId_stim variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_"))

# 3. Extract raw counts for top genes (instead of log-normalized values)
rawExpressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "counts")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_stim
rawExpressionMatrix_df <- as.data.frame(t(rawExpressionMatrix))
rawExpressionMatrix_df$donorId_stim <- filtered_cells$donorId_stim

aggregated_counts <- rawExpressionMatrix_df %>%
  group_by(donorId_stim) %>%
  summarise(across(everything(), sum))

# Convert aggregated counts to a matrix (genes x donors)
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_stim
aggregated_matrix <- t(aggregated_matrix)  # now rows = genes, columns = donors

# Ensure aggregated_matrix is numeric
aggregated_matrix <- matrix(as.numeric(aggregated_matrix),
  nrow = nrow(aggregated_matrix),
  dimnames = dimnames(aggregated_matrix))
dge <- DGEList(counts = aggregated_matrix)
normCPM <- edgeR::cpm(dge, log = TRUE)

# 6. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(normCPM)))

# 6. Create annotation dataframe using stimulationFigures instead of cellType
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Treg"),
    stimulationFigures %in% c("IAR", "Microbial")) %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, stimulationFigures, donorId_stim)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_stim), ]

# Ensure the order: IAR (left) then Microbial (right)
filtered_metadata$stimulationFigures <- factor(filtered_metadata$stimulationFigures,
  levels = c("IAR", "Microbial"))

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  stimulation = filtered_metadata$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# Create the heatmap object
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,  # your annotation bar at the top
  show_row_names = TRUE,
  show_column_names = FALSE,           # drop the bottom column labels
  cluster_rows = TRUE,
  cluster_columns = TRUE,              # cluster columns within each group
  # show_column_dend = TRUE,
  column_split = filtered_metadata$stimulationFigures,  # uses factor order: Microbial then IAR
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "IARMinCEFXTreg_heatmap_top60GenesAdjPVal", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r DGEHeatmapTconvIARMinusCEFX}
nGenes <- 60

results_IAR_vs_MicrobialTconv <- read.csv(paste0(dataOutputDir, "/DGE_Tconv_IARVMicrobial.csv"))
# ==========================top N genes by adj.p.val=====================================================
top_genes <- results_IAR_vs_MicrobialTconv %>%
  dplyr::filter(adj.P.Val < 0.05) %>%   # Filter to adj.P.Val < 0.05
  dplyr::arrange(adj.P.Val) %>%         # Sort by adjusted p-value in ascending order
  dplyr::slice(1:nGenes) %>%                # Select the top 50 genes
  dplyr::pull(gene)

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Tconv"),
    stimulationFigures %in% c("IAR", "Microbial"))

# Create donorId_stim variable
filtered_cells <- filtered_cells %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_"))

# 3. Extract raw counts for top genes (instead of log-normalized values)
rawExpressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "counts")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_stim
rawExpressionMatrix_df <- as.data.frame(t(rawExpressionMatrix))
rawExpressionMatrix_df$donorId_stim <- filtered_cells$donorId_stim

aggregated_counts <- rawExpressionMatrix_df %>%
  group_by(donorId_stim) %>%
  summarise(across(everything(), sum))

# Convert aggregated counts to a matrix (genes x donors)
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_stim
aggregated_matrix <- t(aggregated_matrix)  # now rows = genes, columns = donors

# Ensure aggregated_matrix is numeric
aggregated_matrix <- matrix(as.numeric(aggregated_matrix),
  nrow = nrow(aggregated_matrix),
  dimnames = dimnames(aggregated_matrix))
dge <- DGEList(counts = aggregated_matrix)
normCPM <- edgeR::cpm(dge, log = TRUE)

# 6. Calculate z-scores for each gene across samples
z_scores <- t(scale(t(normCPM)))

# 6. Create annotation dataframe using stimulationFigures instead of cellType
metadata <- seuratQCMergedCleaned@meta.data
filtered_metadata <- metadata %>%
  dplyr::filter(cellType %in% c("Tconv"),
    stimulationFigures %in% c("IAR", "Microbial")) %>%
  dplyr::mutate(donorId_stim = paste(donorIdFigures, stimulationFigures, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, seurat_clusters_DS, stimulationFigures, donorId_stim)

# Ensure the order of metadata matches the samples
filtered_metadata <- filtered_metadata[match(colnames(z_scores), filtered_metadata$donorId_stim), ]

# Ensure the order: IAR (left) then Microbial (right)
filtered_metadata$stimulationFigures <- factor(filtered_metadata$stimulationFigures,
  levels = c("IAR", "Microbial"))

# 7. Define annotations for the heatmap
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  stimulation = filtered_metadata$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# Create the heatmap object
heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,  # your annotation bar at the top
  show_row_names = TRUE,
  show_column_names = FALSE,           # drop the bottom column labels
  cluster_rows = TRUE,
  cluster_columns = TRUE,              # cluster columns within each group
  column_split = filtered_metadata$stimulationFigures,  # uses factor order: Microbial then IAR
  col = heatmap_colors,
  border = TRUE
)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "IARMinCEFXTconv_heatmap_top60GenesAdjPVal_", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r GSEAIARVsCEFX}
# Get hallmark, C2, and C5 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)

c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)

c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)

c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_IAR_vs_MicrobialTconv"]] <- results_IAR_vs_MicrobialTconv
comparisons[["results_IAR_vs_MicrobialTreg"]] <- results_IAR_vs_MicrobialTreg

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Produce a dotplot for the top enriched pathways (up to 15 categories)
      dp <- dotplot(gsea_obj, showCategory = 15) +
        ggtitle(paste(comp, "(", direction, " - ", cat, ")"))

      # Save the dotplot as a PDF
      pdf_filename <- file.path(plotDir, paste0(comp, "_GSEA_dotplot_", direction, "_", cat, ".pdf"))
      pdf(file = pdf_filename, width = 9, height = 9)
      print(dp)
      dev.off()
    }
  }
}
```

```{r DGEStudyGroupAllCellsHeatmap}
# ==========================top 30 +logFC and top 30 -logFC=====================================================
# 1. Select top 50 genes by smallest adjusted p-value from DGEIAR
top_genes <- results_T1DVsControl %>%
  dplyr::filter(adj.P.Val < 0.05) %>%                    # Filter to adj.P.Val < 0.05
  dplyr::arrange(desc(logFC)) %>%                        # Sort by logFC descending
  dplyr::slice(1:30) %>%                                 # Select top 30 positive
  dplyr::bind_rows(
    results_T1DVsControl %>%
      dplyr::filter(adj.P.Val < 0.05) %>%                # Filter to adj.P.Val < 0.05
      dplyr::arrange(logFC) %>%                          # Sort by logFC ascending
      dplyr::slice(1:30)                                 # Select top 30 negative
  ) %>%
  dplyr::pull(gene)                                     # Extract gene names

# 2. Filter Seurat object for relevant cells
filtered_cells <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv")) %>%
  dplyr::mutate(donorId_studyGroup = paste(donorIdFigures, studyGroup, sep = "_"))

# 3. Extract normalized expression data for top genes
expressionMatrix <- GetAssayData(seuratQCMergedCleaned, assay = "RNA", slot = "data")[top_genes, rownames(filtered_cells)]

# 4. Aggregate counts by donorId_studyGroup
expressionMatrix <- as.data.frame(t(expressionMatrix))
expressionMatrix$donorId_studyGroup <- filtered_cells$donorId_studyGroup

aggregated_counts <- expressionMatrix %>%
  dplyr::group_by(donorId_studyGroup) %>%
  dplyr::summarise(across(everything(), sum))

# Convert aggregated counts back to a matrix
aggregated_matrix <- as.matrix(aggregated_counts[, -1])
rownames(aggregated_matrix) <- aggregated_counts$donorId_studyGroup

# Transpose once to have genes as rows and donorId_studyGroup as columns
aggregated_matrix <- t(aggregated_matrix)

# Now, calculate z-scores for each gene across samples
z_scores <- t(scale(t(aggregated_matrix)))

# 6. Create annotation dataframe from metadata.
# Use distinct() on donorId_studyGroup to ensure one row per aggregated column.
filtered_metadata <- seuratQCMergedCleaned@meta.data %>%
  dplyr::filter(cellType %in% c("Treg", "Tconv")) %>%
  dplyr::mutate(donorId_studyGroup = paste(donorIdFigures, studyGroup, sep = "_")) %>%
  dplyr::select(donorIdFigures, studyGroup, stimulationFigures, donorId_studyGroup) %>%
  dplyr::distinct(donorId_studyGroup, .keep_all = TRUE)

# Subset metadata to only those donorId_studyGroup present in z_scores
columns_order <- colnames(z_scores)
filtered_metadata <- filtered_metadata %>%
  dplyr::filter(donorId_studyGroup %in% columns_order)

# Order metadata to match the columns of z_scores
filtered_metadata <- filtered_metadata[match(columns_order, filtered_metadata$donorId_studyGroup), ]

# Check matching lengths (will stop if not equal)
if (ncol(z_scores) != nrow(filtered_metadata)) {
  stop("Mismatch between z_scores columns and filtered_metadata rows")
}

# 7. Define top annotations for the heatmap: donorId and stimulationFigures
heatmapAnnotation <- HeatmapAnnotation(
  donorId = filtered_metadata$donorIdFigures,
  stimulation = filtered_metadata$stimulationFigures,
  col = list(
    donorId = palDonorId,
    stimulation = palStimulation
  )
)

# 8. Define color function for heatmap
heatmap_colors <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))

# 9. Create the heatmap, splitting columns by studyGroup
# Ensure studyGroup is a factor and has no NAs:
column_split_vector <- factor(filtered_metadata$studyGroup)
if (any(is.na(column_split_vector))) {
  stop("Some studyGroup values are missing in filtered_metadata")
}

heatmap.tmp <- Heatmap(
  z_scores,
  name = "Z-score",
  top_annotation = heatmapAnnotation,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_order = seq_len(ncol(z_scores)),  # explicitly set column order
  column_split = column_split_vector,
  col = heatmap_colors,
  border = TRUE
)
pdf(file.path(plotDir,
  paste0(filenameSuffix, "T1DVsControl_heatmap_topBottom30_abslogFC", ".pdf")),
height = 9,
width = 9)

print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r plotTconvsTregsOnUMAP}
# Print unique values of stimulationFigures to verify
print(unique(seuratQCMergedCleanedDS$stimulationFigures))

# Print the distribution of stimulationFigures values
print(table(seuratQCMergedCleanedDS$stimulationFigures))

# Define the stimulation values manually
stimulation_values <- c("IAR", "Polyclonal", "Microbial")

for (stimulation in stimulation_values) {

  seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == stimulation)
}
# Loop over each stimulation value
for (stimulation in stimulation_values) {
  # Print the current stimulation value for debugging
  print(paste("Processing stimulation:", stimulation))

  # Check if the stimulation value exists in the data
  if (!(stimulation %in% seuratQCMergedCleanedDS$stimulationFigures)) {
    print(paste("Stimulation value not found in data:", stimulation))
    next
  }

  # Print the first few rows of the data before subsetting
  print(head(seuratQCMergedCleanedDS@meta.data))

  # Subset the Seurat object to only include cells with the current stimulation value
  seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == stimulation)

  # Print the subset condition and the first few rows of the subset data
  print(paste("Subset condition: stimulationFigures == ", stimulation))
  print(head(seurat_subset.tmp@meta.data))

  # Print the number of cells found for debugging
  print(paste("Number of cells found:", nrow(seurat_subset.tmp@meta.data)))

  # Check if any cells were found
  if (nrow(seurat_subset.tmp@meta.data) == 0) {
    print(paste("No cells found for stimulation:", stimulation))
    next
  }

  # Define colors for the cell types
  cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

  # Create the UMAP plot
  pdf(file.path(plotDir,
    paste0(filenameSuffix, "_UMAP_RNA_", stimulation, "_TregTconvByTotalSeq", ".pdf")),
  height = 6,
  width = 12)

  DimPlot(object = seurat_subset.tmp,
    reduction = "umap",
    group.by = "cellType",
    cols = cellTypeColors) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = stimulation) +
    theme(aspect.ratio = 1)

  dev.off()
}
```

```{r debugCopilotsAwfulSuggestions}

# Subset the Seurat object to only include cells with the current stimulation value
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "IAR")

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_", "IAR", "_TregTconvByTotalSeq", ".pdf")),
height = 5.5,
width = 5)

DimPlot(object = seurat_subset.tmp,
  reduction = "umap",
  group.by = "cellType",
  cols = cellTypeColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = "IAR") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)

# Subset the Seurat object to only include cells with the current stimulation value
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Polyclonal")

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_", "Polyclonal", "_TregTconvByTotalSeq", ".pdf")),
height = 5.5,
width = 5)

DimPlot(object = seurat_subset.tmp,
  reduction = "umap",
  group.by = "cellType",
  cols = cellTypeColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = "Polyclonal") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)

# Subset the Seurat object to only include cells with the current stimulation value
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Microbial")

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_", "Microbial", "_TregTconvByTotalSeq", ".pdf")),
height = 5.5,
width = 5)

DimPlot(object = seurat_subset.tmp,
  reduction = "umap",
  group.by = "cellType",
  cols = cellTypeColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = "Microbial") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)
```

```{r TconvTregByTotalSeqOnUMAPFacetByStim}
# Extract UMAP coordinates
umap_coords <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Create a data frame for plotting
plot_data <- data.frame(
  UMAP_1 = umap_coords[, 1],
  UMAP_2 = umap_coords[, 2],
  cellType = seuratQCMergedCleanedDS$cellType,
  stimulationFigures = seuratQCMergedCleanedDS@meta.data$stimulationFigures
)

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot with ggplot2 and facet_wrap
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TregTconvByTotalSeq.pdf")), height = 5.5, width = 12)

ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellType)) +
  geom_point(size = 0.5) +
  scale_color_manual(values = cellTypeColors) +
  facet_wrap(~stimulationFigures) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)
```

```{r getClusterDefiningGenes}
DefaultAssay(seuratQCMergedCleaned) <- "RNA"
Idents(seuratQCMergedCleaned) <- "seurat_clusters"
# Join the data layers
seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned)

clusterMarkers <- FindAllMarkers(seuratQCMergedCleaned)

topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = 10) %>%
  dplyr::slice_min(p_val_adj, n = 10) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters, each = 4))

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleaned$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataInputDir, "top10_genes_per_cluster_default.csv"), quote = FALSE, row.names = TRUE)
```

```{r P390GenesHeatmap}
genesOfInterest <- c("LDHB", "FABP5", "MYO1B", "ACSL6", "FZD3", "FASLG",
  "SPRY1", "UBE2E2", "RGCC", "TNFSF11", "ZNF704", "RAI2",
  "TTC8", "IL2", "DHRS3", "NELL2", "MAMLD1", "MAP7",
  "C1orf228", "IL3", "CSF2", "XCL1", "LRRN3", "FHL1",
  "RRAGD", "ADORA2B", "CNN3", "JAK1", "FTL", "CTLA4",
  "SYTL3", "ZNF292", "CHST11", "IL2RA", "PICALM", "IL2RB",
  "GNG2", "IL32", "CD74", "CD74", "ARL6IP5", "TIGIT",
  "IKZF2", "CTTNBP2NL", "FUT7", "MAN1A2", "ENTPD1", "LRRC32",
  "CCR8", "HLA-DQA1", "HLA-DRB1", "HLA-DRB5", "HLA-DQA2", "IL1R2",
  "FOXP3", "IL1R1", "CISH", "TXN", "TNFRSF18", "TPMT",
  "SFT2D1")

seuratQCMergedCleaned@meta.data
# heatmap of these genes with columns by seurat_cluster
```

```{r integrationByDonor}
### for CD4s
## version with split by project
# Split seurat object by the donor ID
seuratQCMergedCleanedSplitDonor <- SplitObject(seuratQCMergedCleaned, split.by = "donorId")

# find integration anchors
maxDims.tmp <- 6 # usually teens, selected from elbow plot of PCs
# ran into issues with anchor/filter/score larger than maxDims
# filter and score may not be necessary
integAnchorsseuratQCMergedCleanedSplitDonor <- FindIntegrationAnchors(
  object.list = seuratQCMergedCleanedSplitDonor,
  dims = 1:min(30, maxDims.tmp),
  k.anchor = min(5, maxDims.tmp),
  k.filter = min(200, maxDims.tmp),
  k.score = min(30, maxDims.tmp)
)

# run the integration
seuratQCMergedCleanedSplitDonorInteg <- IntegrateData(
  integAnchorsseuratQCMergedCleanedSplitDonor,
  dims = 1:min(30, maxDims.tmp),
  k.weight = min(100, maxDims.tmp)
)
```


```{r proportionOfExpansion}
# subset seuratQCMergedCleaned to cellType == "Tconv", "Treg"
seuratSubset <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Tconv", "Treg"))

# Extract the cdr3CloneID column from the metadata
CloneIDs <- seuratSubset@meta.data$fullLengthNTCloneID

# Count the occurrences of each cdr3CloneID
CloneID_counts <- table(CloneIDs)

# Filter the IDs that have 2 or more occurrences
CloneID_filtered <- names(CloneID_counts[CloneID_counts >= 2])


# Prepare metadata
md <- seuratSubset@meta.data

# Mark each cell as Expanded if its fullLengthNTCloneID is in CloneID_filtered
md <- md %>%
  mutate(expanded = ifelse(fullLengthNTCloneID %in% CloneID_filtered, "Expanded", "Not Expanded"))

# Calculate, for each donor within each combination of stimulationFigures and seurat_clusters_Treg,
# the proportion of cells that are expanded.
plot_data_box <- md %>%
  group_by(stimulationFigures, seurat_clusters_Treg, donorIdFigures) %>%
  summarise(total_cells = n(),
    expanded_cells = sum(expanded == "Expanded"),
    .groups = "drop") %>%
  mutate(proportion = expanded_cells / total_cells)

# Create the boxplot with donor points
p_box <- ggplot(plot_data_box,
  aes(x = factor(seurat_clusters_Treg), y = proportion)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(aes(color = donorIdFigures),
    position = position_jitter(width = 0.2), size = 2) +
  scale_color_manual(values = palDonorId) +
  facet_wrap(~stimulationFigures, nrow = 3) +
  labs(x = "Seurat Cluster (Treg)",
    y = "Proportion Expanded (per donor)",
    color = "Donor ID") +
  theme_bw() +
  theme(strip.text = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12))

print(p_box)

# Save both PDF and PNG
pdf(file = file.path(plotDir, paste0(filenameSuffix, "_boxplot_expandedCells.pdf")), height = 5.5, width = 6)
print(p_box)
dev.off()







# Prepare metadata
md <- seuratSubset@meta.data

# Mark each cell as Expanded if its fullLengthNTCloneID is in CloneID_filtered
md <- md %>%
  mutate(expanded = ifelse(fullLengthNTCloneID %in% CloneID_filtered, "Expanded", "Not Expanded"))

# Calculate, for each donor within each combination of stimulationFigures and seurat_clusters_Treg,
# the proportion of cells that are expanded.
plot_data_box <- md %>%
  group_by(stimulationFigures, seurat_clusters_Tconv, donorIdFigures) %>%
  summarise(total_cells = n(),
    expanded_cells = sum(expanded == "Expanded"),
    .groups = "drop") %>%
  mutate(proportion = expanded_cells / total_cells)

# Create the boxplot with donor points
p_box <- ggplot(plot_data_box,
  aes(x = factor(seurat_clusters_Tconv), y = proportion)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(aes(color = donorIdFigures),
    position = position_jitter(width = 0.2), size = 2) +
  scale_color_manual(values = palDonorId) +
  facet_wrap(~stimulationFigures, nrow = 3) +
  labs(x = "Seurat Cluster (Tconv)",
    y = "Proportion Expanded (per donor)",
    color = "Donor ID") +
  theme_bw() +
  theme(strip.text = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12))

print(p_box)

# Save both PDF and PNG
pdf(file = file.path(plotDir, paste0(filenameSuffix, "_boxplot_expandedCells_TconvClusters.pdf")), height = 5.5, width = 6)
print(p_box)
dev.off()
```

```{r makeAirlinePlot}
# -------------------all three stimulations---------------------------------
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seuratQCMergedCleaned@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
# print(cdr3CloneID_filtered)
airlinePlot(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStim")

airlinePlotFB(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimFB")

airlinePlotFBDSB(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimFBDSB")

airlinePlotFBPoster(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "All stimulations",
  plotName = "AirlinePlotAllStimFBPoster")

airlinePlotCT(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimCT")

# --------------------------------------------------------------------------

# -----------------------------------IAR------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)


# Example usage

airlinePlot(seuratObj = seuratQCMergedCleaned,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "umap",
  arcLinewidth = 0.1,
  arcAlpha = 0.5,
  savePlot = TRUE,
  plotTitle = "TCR sharing in RNAseq clusters",
  plotName = "AirlinePlot")


airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  arcLinewidth = 0.3,
  reductionName = "ref.umap_DS",
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIAR")

airlinePlotFB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARFB")

airlinePlotFBDSB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARFBDSB")

airlinePlotFBPoster(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "IAR",
  plotName = "AirlinePlotIARFBPoster")

airlinePlotCT(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARCT")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------CEFX-----------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Microbial")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  arcLinewidth = 0.3,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobial")

airlinePlotFB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobialFB")

airlinePlotFBDSB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobialFBDSB")

airlinePlotFBPoster(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Microbial",
  plotName = "AirlinePlotMicrobialFBPoster")

airlinePlotCT(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobialCT")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Polyclonal-----------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Polyclonal")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  arcLinewidth = 0.3,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonal")

airlinePlotFB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonalFB")

airlinePlotFBDSB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonalFBDSB")

airlinePlotFBPoster(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Polyclonal",
  plotName = "AirlinePlotPolyclonalFBPoster")

airlinePlotCT(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonalCT")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------
```

```{r airlinePlotsNoDownsampleCDR3}
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDSIARCellType")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotNoDSCEFXCellType")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDSPolyclonalCellType")

rm_tmp(ask = FALSE)
```

```{r airlinePlotsNoDownsampleCDR3NT}
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID_nt

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID_nt",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDSIARCellType_NT")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID_nt

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID_nt",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotNoDSCEFXCellType_NT")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID_nt

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID_nt",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDSPolyclonalCellType_NT")

rm_tmp(ask = FALSE)
```

```{r airlinePlotsNoDownsampleThreePointNTCloneID}
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 3 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = fullLengthNTCloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  arcLinewidth = 0.25,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDS_IAR_CellType_threePointNT")

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = fullLengthNTCloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap_DS",
  arcLinewidth = 0.25,
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDS_IAR_seuratClusters_threePointNT")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 3 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = fullLengthNTCloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  arcLinewidth = 0.1,
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotDS_CEFX_CellType_threePointNT")

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = fullLengthNTCloneID_filtered, # c("Clone_378"),
  reductionName = "umap",
  arcLinewidth = 0.1,
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotDS_CEFX_SeuratClusters_threePointNT")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 3 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = fullLengthNTCloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  arcLinewidth = 0.25,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDS_Polyclonal_CellType_threePointNT")

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = fullLengthNTCloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  arcLinewidth = 0.25,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDS_Polyclonal_SeuratClusters_threePointNT")

rm_tmp(ask = FALSE)


# 20250417 remaking airline plots
# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_DS",
  displayVariable = "cellType", # variable to color the UMAP by
  arcLinewidth = 0.1,
  arcAlpha = 0.2,
  colorPalette = palCellType,
  plotTitle = "Clone IDs with 2+ occurrences", # string
  colorString = "Cell Type", # string for the name of the legend
  savePlot = TRUE,
  plotName = "allCellsAirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "IAR")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_DS",
  displayVariable = "cellType", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palCellType,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR", # string
  colorString = "Cell Type", # string for the name of the legend
  savePlot = TRUE,
  plotName = "IAR_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Polyclonal")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_DS",
  displayVariable = "cellType", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palCellType,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal", # string
  colorString = "Cell Type", # string for the name of the legend
  savePlot = TRUE,
  plotName = "Polyclonal_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Microbial")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_DS",
  displayVariable = "cellType", # variable to color the UMAP by
  arcLinewidth = 0.1,
  arcAlpha = 0.3,
  colorPalette = palCellType,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial", # string
  colorString = "Cell Type", # string for the name of the legend
  savePlot = TRUE,
  plotName = "Microbial_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleanedDS, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Microbial")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "umap",
  displayVariable = "cellType", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palCellType,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial (downsampled)", # string
  colorString = "Cell Type", # string for the name of the legend
  savePlot = TRUE,
  plotName = "DS_Microbial_AirlinePlot_CellType",
  minClones = 2)

# ---------------------Treg-only-----------------------------------------------------------
# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "IAR")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_Treg",
  displayVariable = "seurat_clusters_Treg", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palRNAClustersTreg,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR", # string
  colorString = "Cluster", # string for the name of the legend
  savePlot = TRUE,
  plotName = "IAR_Treg_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Polyclonal")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_Treg",
  displayVariable = "seurat_clusters_Treg", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palRNAClustersTreg,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal", # string
  colorString = "Cluster", # string for the name of the legend
  savePlot = TRUE,
  plotName = "Polyclonal_Treg_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Microbial")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_Treg",
  displayVariable = "seurat_clusters_Treg", # variable to color the UMAP by
  arcLinewidth = 0.1,
  arcAlpha = 0.5,
  colorPalette = palRNAClustersTreg,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial", # string
  colorString = "Cluster", # string for the name of the legend
  savePlot = TRUE,
  plotName = "Microbial_Treg_AirlinePlot_CellType",
  minClones = 2)


# ---------------------Tconv-only-----------------------------------------------------------
# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "IAR")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_Tconv",
  displayVariable = "seurat_clusters_Tconv", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palRNAClustersTconv,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR", # string
  colorString = "Cluster", # string for the name of the legend
  savePlot = TRUE,
  plotName = "IAR_Tconv_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Tconv")) # limit to just the Tconv/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Polyclonal")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_Tconv",
  displayVariable = "seurat_clusters_Tconv", # variable to color the UMAP by
  arcLinewidth = 0.3,
  arcAlpha = 0.8,
  colorPalette = palRNAClustersTconv,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal", # string
  colorString = "Cluster", # string for the name of the legend
  savePlot = TRUE,
  plotName = "Polyclonal_Tconv_AirlinePlot_CellType",
  minClones = 2)

# make subset Seurat object
seurat.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Tconv")) # limit to just the Tconv/Tconv cells. Exclude 'Other'
seurat.tmp <- subset(seurat.tmp, subset = stimulationFigures == "Microbial")

# plot airline
airlinePlot(seuratObj = seurat.tmp,
  tcrPairs = cleanTCRpairs.df,
  reductionName = "ref.umap_Tconv",
  displayVariable = "seurat_clusters_Tconv", # variable to color the UMAP by
  arcLinewidth = 0.1,
  arcAlpha = 0.5,
  colorPalette = palRNAClustersTconv,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial", # string
  colorString = "Cluster", # string for the name of the legend
  savePlot = TRUE,
  plotName = "Microbial_Tconv_AirlinePlot_CellType",
  minClones = 2)


rm_tmp(ask = FALSE)
gc()
```

```{r airlinePlotsNoDownsampleCDR3NT_narrowID}
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$narrowCloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "narrowCloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDSIARCellType_NTnarrowCloneID")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$narrowCloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "narrowCloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotNoDSCEFXCellType_NTnarrowCloneID")

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$narrowCloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "narrowCloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDSPolyclonalCellType_NTnarrowCloneID")

rm_tmp(ask = FALSE)
```

```{r airlinePlotsNoDownsamplefullLengthNT}
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID_alpha

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID_alpha",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length alpha NT with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDSIARCellType_fullLengthNTCloneID_alpha")

dev.off()
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID_beta

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID_beta",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length beta NT with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDSIARCellType_fullLengthNTCloneID_beta")

dev.off()

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length NT with 2+ occurrences\nIAR",
  plotName = "AirlinePlotNoDSIARCellType_fullLengthNTCloneID")

dev.off()

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID_alpha

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID_alpha",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length alpha NT with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotNoDSCEFXCellType_fullLengthNTCloneID_alpha")

dev.off()
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID_beta

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID_beta",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length beta NT with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotNoDSCEFXCellType_fullLengthNTCloneID_beta")

dev.off()

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length NT with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotNoDSCEFXCellType_fullLengthNTCloneID")

dev.off()

# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID_alpha

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID_alpha",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length alpha NT with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDSPolyclonalCellType_fullLengthNTCloneID_alpha")

dev.off()
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID_beta

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID_beta",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length beta NT with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDSPolyclonalCellType_fullLengthNTCloneID_beta")

dev.off()

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

airlinePlotCellType(seurat_subset.tmp,
  cloneIDColumn = "fullLengthNTCloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  reductionName = "ref.umap",
  savePlot = TRUE,
  plotTitle = "Full length NT with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotNoDSPolyclonalCellType_fullLengthNTCloneID")

dev.off()



rm_tmp(ask = FALSE)
```

```{r TCRBarPlotsSeuratClusterOccupancy}
## --------------------------------------IAR--------------------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Add a new column to indicate whether the clone ID is shared
metadata.tmp <- metadata.tmp %>%
  mutate(cloneShared = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Shared", "Unique"))

# Calculate the percentage of shared clones per Seurat cluster
sharedCloneSummary <- metadata.tmp %>%
  group_by(seurat_clusters_DS) %>%              # Replace with your actual cluster column name if different
  summarise(
    totalCells = n(),
    sharedCells = sum(cloneShared == "Shared")
  ) %>%
  mutate(percentageShared = (sharedCells / totalCells) * 100)

# View the summary data
print(sharedCloneSummary)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "percentExpandedCellsInSeuratClustersIAR.pdf")),
height = 5.5,
width = 7)

# Create the bar plot
TCRPlot.tmp <- ggplot(sharedCloneSummary, aes(x = factor(seurat_clusters_DS), y = percentageShared)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme_minimal() +
  labs(
    title = "Percentage of Cells Sharing a Clone per Seurat Cluster\nIAR",
    x = "Seurat Cluster",
    y = "Percentage of Shared Clones (%)"
  ) +
  ylim(0, 100) +
  geom_text(aes(label = sprintf("%.1f%%", percentageShared)), vjust = -0.5, size = 3.5) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

print(TCRPlot.tmp)

dev.off()

rm_tmp(ask = FALSE)



## --------------------------------------CEFX--------------------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Add a new column to indicate whether the clone ID is shared
metadata.tmp <- metadata.tmp %>%
  mutate(cloneShared = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Shared", "Unique"))

# Calculate the percentage of shared clones per Seurat cluster
sharedCloneSummary <- metadata.tmp %>%
  group_by(seurat_clusters_DS) %>%              # Replace with your actual cluster column name if different
  summarise(
    totalCells = n(),
    sharedCells = sum(cloneShared == "Shared")
  ) %>%
  mutate(percentageShared = (sharedCells / totalCells) * 100)

# View the summary data
print(sharedCloneSummary)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "percentExpandedCellsInSeuratClustersCEFX.pdf")),
height = 5.5,
width = 7)

# Create the bar plot
TCRPlot.tmp <- ggplot(sharedCloneSummary, aes(x = factor(seurat_clusters_DS), y = percentageShared)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme_minimal() +
  labs(
    title = "Percentage of Cells Sharing a Clone per Seurat Cluster\nCEFX",
    x = "Seurat Cluster",
    y = "Percentage of Shared Clones (%)"
  ) +
  ylim(0, 100) +
  geom_text(aes(label = sprintf("%.1f%%", percentageShared)), vjust = -0.5, size = 3.5) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

print(TCRPlot.tmp)

dev.off()

rm_tmp(ask = FALSE)




## --------------------------------------Polyclonal--------------------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Extract metadata from the Seurat object
metadata.tmp <- seurat_subset.tmp@meta.data

# Add a new column to indicate whether the clone ID is shared
metadata.tmp <- metadata.tmp %>%
  mutate(cloneShared = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Shared", "Unique"))

# Calculate the percentage of shared clones per Seurat cluster
sharedCloneSummary <- metadata.tmp %>%
  group_by(seurat_clusters_DS) %>%              # Replace with your actual cluster column name if different
  summarise(
    totalCells = n(),
    sharedCells = sum(cloneShared == "Shared")
  ) %>%
  mutate(percentageShared = (sharedCells / totalCells) * 100)

# View the summary data
print(sharedCloneSummary)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "percentExpandedCellsInSeuratClustersPolyclonal.pdf")),
height = 5.5,
width = 7)

# Create the bar plot
TCRPlot.tmp <- ggplot(sharedCloneSummary, aes(x = factor(seurat_clusters_DS), y = percentageShared)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme_minimal() +
  labs(
    title = "Percentage of Cells Sharing a Clone per Seurat Cluster\nPolyclonal",
    x = "Seurat Cluster",
    y = "Percentage of Shared Clones (%)"
  ) +
  ylim(0, 100) +
  geom_text(aes(label = sprintf("%.1f%%", percentageShared)), vjust = -0.5, size = 3.5) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

print(TCRPlot.tmp)

dev.off()

rm_tmp(ask = FALSE)
```

```{r TCRBarPlotsT1DvHCCellTypeAndStim}
# TODO unbreak this figure because it's awful.
# Filter down to only Treg and Tconv cells
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Ensure that the required columns exist in the metadata
required_cols <- c("studyGroup", "stimulationFigures", "cellType", "donorIdFigures", "fullLengthNTCloneID")
missing_cols <- setdiff(required_cols, colnames(seurat_subset.tmp@meta.data))
if (length(missing_cols) > 0) {
  stop(paste("The following required columns are missing in the metadata:", paste(missing_cols, collapse = ", ")))
}

# Extract metadata from the Seurat object
metadata <- seurat_subset.tmp@meta.data

# Add a new column to indicate whether the clone ID is shared
metadata <- metadata %>%
  mutate(cloneShared = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Shared", "Unique"))

# Calculate total cell counts per studyGroup and stimulationFigures
total_cells_summary <- metadata %>%
  group_by(studyGroup, stimulationFigures) %>%
  summarise(Total_Cells = n(), .groups = "drop")

# Calculate shared cell counts per studyGroup, stimulationFigures, and cellType
shared_cells_summary <- metadata %>%
  filter(cloneShared == "Shared") %>%
  group_by(studyGroup, stimulationFigures, cellType) %>%
  summarise(Shared_Cells = n(), .groups = "drop")

# Merge total cells with shared cells and calculate Percentage
clone_percentage <- shared_cells_summary %>%
  left_join(total_cells_summary, by = c("studyGroup", "stimulationFigures")) %>%
  mutate(Percentage = (Shared_Cells / Total_Cells) * 100)

# Ensure that combinations with zero shared cells are included
clone_percentage <- clone_percentage %>%
  complete(studyGroup, stimulationFigures, cellType, fill = list(Shared_Cells = 0, Percentage = 0))

max_y <- max(clone_percentage$Percentage, na.rm = TRUE) + 5

# Verify that 'Percentage' column exists
if (!"Percentage" %in% colnames(clone_percentage)) {
  stop("The 'Percentage' column was not created successfully. Please check the data processing steps.")
}

# Check for NA values in Percentage and handle them
if (any(is.na(clone_percentage$Percentage))) {
  warning("There are NA values in the 'Percentage' column. These will be treated as zero.")
  clone_percentage$Percentage[is.na(clone_percentage$Percentage)] <- 0
}

# Define the order of stimulations for consistent plotting
clone_percentage$stimulationFigures <- factor(clone_percentage$stimulationFigures,
  levels = c("IAR", "Microbial", "Polyclonal"))

# Create a separate dataframe for stimulationFigures labels
label_data <- clone_percentage %>%
  group_by(studyGroup, stimulationFigures) %>%
  summarise(max_percentage = max(Percentage), .groups = "drop") %>%
  mutate(y_position = max_percentage + 5)  # Adjust the offset as needed

# Create the stacked and grouped bar plot
barPlot.tmp <- ggplot(clone_percentage, aes(x = studyGroup, y = Percentage, fill = cellType)) +
  # Group by stimulationFigures to maintain studyGroup splits
  geom_bar(aes(group = stimulationFigures),
    stat = "identity",
    position = position_dodge(width = 0.8),
    width = 0.7) +

  # Percentage labels within the dodged bars
  geom_text(aes(label = sprintf("%.1f%%", Percentage)),
    position = position_dodge(width = 0.8),
    vjust = -0.5,
    size = 3, color = "black") +

  # StimulationFigures labels above each set of dodged bars
  geom_text(data = label_data,
    aes(x = studyGroup, y = y_position, label = stimulationFigures),
    position = position_dodge(width = 0.8),
    size = 3.5, color = "black", inherit.aes = FALSE) +

  scale_fill_manual(values = c("Treg" = "blue", "Tconv" = "red")) +

  labs(
    title = "Clone Composition per Study Group and Stimulation",
    x = "Study Group",
    y = "Percentage of Shared Clones (%)",
    fill = "Cell Type"
  ) +

  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.text = element_text(size = 12)
  ) +

  # Adjust y-axis to provide space for stimulation labels
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)), limits = c(0, max_y))  # Adjust the upper limit as needed

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "CloneCompositionPerStudyGroupStimulation.pdf")),
  height = 6,
  width = 14)

# Print the plot
print(barPlot.tmp)

dev.off()
```

```{r TCRBoxPlotsT1DvHCCellTypeAndStim}
# -------------------------------------IAR------------------------------------------------------

# Filter down to only Treg and Tconv cells for the given stimulation
stimulation <- "IAR"
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR" & cellType %in% c("Treg", "Tconv"))

# Check if any cells are found
if (nrow(seurat_subset.tmp@meta.data) == 0) {
  message(paste("No cells found for stimulation:", "IAR"))
  return(NULL)
}

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Add a new column to indicate whether the clone ID is expanded
metadata <- seurat_subset.tmp@meta.data
metadata <- metadata %>%
  mutate(expanded = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Expanded", "Not Expanded"))

# Calculate the proportion of expanded cells per donorIdFigures, studyGroup, and cellType
expanded_proportion <- metadata %>%
  group_by(donorIdFigures, studyGroup, cellType) %>%
  summarise(Proportion_Expanded = mean(expanded == "Expanded"), .groups = "drop") %>%
  mutate(group = interaction(studyGroup, cellType))

# Print debug information
print(head(expanded_proportion))

# Perform pairwise statistical tests
stat_test <- expanded_proportion %>%
  pairwise_t_test(Proportion_Expanded ~ group, p.adjust.method = "bonferroni") %>%
  add_xy_position(x = "group")

# Add cellType column to stat_test for plotting
stat_test <- stat_test %>%
  mutate(cellType = ifelse(grepl("Treg", group1), "Treg", "Tconv"))

# Print debug information
print(head(stat_test))

# Create the box plot
box_plot <- ggplot(expanded_proportion, aes(x = group, y = Proportion_Expanded, fill = cellType)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, size = 1, alpha = 0.6) +
  scale_fill_manual(values = c("Treg" = "blue", "Tconv" = "red")) +
  labs(
    title = paste("Proportion of Expanded Clones per Donor \n(", stimulation, ")", sep = ""),
    x = "Study Group and Cell Type",
    y = "Proportion of Expanded Clones",
    fill = "Cell Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.text = element_text(size = 12)
  ) +
  ylim(-0.1, 0.8) +
  stat_pvalue_manual(stat_test, label = "p.adj.signif", tip.length = 0.01, remove.bracket = TRUE)

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "TCRExpansionProportionsBoxPlot_", "IAR", ".pdf")),
  height = 5.5,
  width = 6)

# Print the plot
print(box_plot)

dev.off()
#---------------------------------------------------Microbial-------------------------------------------
# Filter down to only Treg and Tconv cells for the given stimulation
stimulation <- "Microbial"
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial" & cellType %in% c("Treg", "Tconv"))

# Check if any cells are found
if (nrow(seurat_subset.tmp@meta.data) == 0) {
  message(paste("No cells found for stimulation:", "Microbial"))
  return(NULL)
}

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Add a new column to indicate whether the clone ID is expanded
metadata <- seurat_subset.tmp@meta.data
metadata <- metadata %>%
  mutate(expanded = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Expanded", "Not Expanded"))

# Calculate the proportion of expanded cells per donorIdFigures, studyGroup, and cellType
expanded_proportion <- metadata %>%
  group_by(donorIdFigures, studyGroup, cellType) %>%
  summarise(Proportion_Expanded = mean(expanded == "Expanded"), .groups = "drop") %>%
  mutate(group = interaction(studyGroup, cellType))

# Print debug information
print(head(expanded_proportion))

# Perform pairwise statistical tests
stat_test <- expanded_proportion %>%
  pairwise_t_test(Proportion_Expanded ~ group, p.adjust.method = "bonferroni") %>%
  add_xy_position(x = "group")

# Add cellType column to stat_test for plotting
stat_test <- stat_test %>%
  mutate(cellType = ifelse(grepl("Treg", group1), "Treg", "Tconv"))

# Print debug information
print(head(stat_test))

# Create the box plot
box_plot <- ggplot(expanded_proportion, aes(x = group, y = Proportion_Expanded, fill = cellType)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, size = 1, alpha = 0.6) +
  scale_fill_manual(values = c("Treg" = "blue", "Tconv" = "red")) +
  labs(
    title = paste("Proportion of Expanded Clones per Donor \n(", stimulation, ")", sep = ""),
    x = "Study Group and Cell Type",
    y = "Proportion of Expanded Clones",
    fill = "Cell Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.text = element_text(size = 12)
  ) +
  ylim(-0.1, 0.8) +
  stat_pvalue_manual(stat_test, label = "p.adj.signif", tip.length = 0.01, remove.bracket = TRUE)

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "TCRExpansionProportionsBoxPlot_", "Microbial", ".pdf")),
  height = 5.5,
  width = 6)

# Print the plot
print(box_plot)

dev.off()

#---------------------------------------Microbial Downsampled to IAR------------------------------
# Get the number of cells each donor has in stimulationFigures = "IAR"
stimulation <- "Microbial"
iar_cells_per_donor <- seuratQCMergedCleaned@meta.data %>%
  filter(stimulationFigures == "IAR") %>%
  group_by(donorIdFigures) %>%
  summarise(n_cells = n(), .groups = "drop")

# Filter down to only Treg and Tconv cells for the given stimulation
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial" & cellType %in% c("Treg", "Tconv"))

# Check if any cells are found
if (nrow(seurat_subset.tmp@meta.data) == 0) {
  message(paste("No cells found for stimulation:", stimulation))
  return(NULL)
}

# Initialize a list to store the downsampled proportions
downsampled_proportions <- list()

# Repeat the downsampling 100 times
set.seed(6022)
for (i in 1:100) {
  downsampled_metadata <- seurat_subset.tmp@meta.data %>%
    group_by(donorIdFigures) %>%
    group_modify(~ {
      n_cells <- iar_cells_per_donor$n_cells[iar_cells_per_donor$donorIdFigures == .y$donorIdFigures]
      if (length(n_cells) == 0) return(.x)  # If no IAR cells for this donor, return original data
      sample_n(.x, size = min(n_cells, nrow(.x)), replace = FALSE)
    }) %>%
    ungroup()

  # Extract the fullLengthNTCloneID column from the metadata
  fullLengthNTCloneIDs <- downsampled_metadata$fullLengthNTCloneID

  # Count the occurrences of each fullLengthNTCloneID
  fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

  # Filter the IDs that have 2 or more occurrences
  fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

  # Add a new column to indicate whether the clone ID is expanded
  downsampled_metadata <- downsampled_metadata %>%
    mutate(expanded = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Expanded", "Not Expanded"))

  # Calculate the proportion of expanded cells per donorIdFigures, studyGroup, and cellType
  expanded_proportion <- downsampled_metadata %>%
    group_by(donorIdFigures, studyGroup, cellType) %>%
    summarise(Proportion_Expanded = mean(expanded == "Expanded"), .groups = "drop")

  # Store the downsampled proportions
  downsampled_proportions[[i]] <- expanded_proportion
}

# Combine the downsampled proportions and calculate the median for each donor
combined_proportions <- bind_rows(downsampled_proportions) %>%
  group_by(donorIdFigures, studyGroup, cellType) %>%
  summarise(Median_Proportion_Expanded = median(Proportion_Expanded), .groups = "drop") %>%
  mutate(group = interaction(studyGroup, cellType))

# Print debug information
print(head(combined_proportions))

# Perform pairwise statistical tests
stat_test <- combined_proportions %>%
  pairwise_t_test(Median_Proportion_Expanded ~ group, p.adjust.method = "bonferroni") %>%
  add_xy_position(x = "group")

# Add cellType column to stat_test for plotting
stat_test <- stat_test %>%
  mutate(cellType = ifelse(grepl("Treg", group1), "Treg", "Tconv"))

# Print debug information
print(head(stat_test))

# Create the box plot
box_plot <- ggplot(combined_proportions, aes(x = group, y = Median_Proportion_Expanded, fill = cellType)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, size = 1, alpha = 0.6) +
  scale_fill_manual(values = c("Treg" = "blue", "Tconv" = "red")) +
  labs(
    title = paste("Proportion of Expanded Clones per Donor (CEFX)\ndownsampled to IAR cell counts", sep = ""),
    x = "Study Group and Cell Type",
    y = "Proportion of Expanded Clones",
    fill = "Cell Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.text = element_text(size = 12)
  ) +
  ylim(-0.1, 0.8) +
  stat_pvalue_manual(stat_test, label = "p.adj.signif", tip.length = 0.01, remove.bracket = TRUE)

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "TCRExpansionProportionsBoxPlot_", "CEFX", "_Downsampled.pdf")),
  height = 5.5,
  width = 6)

# Print the plot
print(box_plot)

dev.off()
#-------------------------------------------------Polyclonal------------------------------------
stimulation <- "Polyclonal"
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal" & cellType %in% c("Treg", "Tconv"))

# Check if any cells are found
if (nrow(seurat_subset.tmp@meta.data) == 0) {
  message(paste("No cells found for stimulation:", "Polyclonal"))
  return(NULL)
}

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

# Add a new column to indicate whether the clone ID is expanded
metadata <- seurat_subset.tmp@meta.data
metadata <- metadata %>%
  mutate(expanded = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Expanded", "Not Expanded"))

# Calculate the proportion of expanded cells per donorIdFigures, studyGroup, and cellType
expanded_proportion <- metadata %>%
  group_by(donorIdFigures, studyGroup, cellType) %>%
  summarise(Proportion_Expanded = mean(expanded == "Expanded"), .groups = "drop") %>%
  mutate(group = interaction(studyGroup, cellType))

# Print debug information
print(head(expanded_proportion))

# Perform pairwise statistical tests
stat_test <- expanded_proportion %>%
  pairwise_t_test(Proportion_Expanded ~ group, p.adjust.method = "bonferroni") %>%
  add_xy_position(x = "group")

# Add cellType column to stat_test for plotting
stat_test <- stat_test %>%
  mutate(cellType = ifelse(grepl("Treg", group1), "Treg", "Tconv"))

# Print debug information
print(head(stat_test))

# Create the box plot
box_plot <- ggplot(expanded_proportion, aes(x = group, y = Proportion_Expanded, fill = cellType)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, size = 1, alpha = 0.6) +
  scale_fill_manual(values = c("Treg" = "blue", "Tconv" = "red")) +
  labs(
    title = paste("Proportion of Expanded Clones per Donor \n(", stimulation, ")", sep = ""),
    x = "Study Group and Cell Type",
    y = "Proportion of Expanded Clones",
    fill = "Cell Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.text = element_text(size = 12)
  ) +
  ylim(-0.1, 0.8) +
  stat_pvalue_manual(stat_test, label = "p.adj.signif", tip.length = 0.01, remove.bracket = TRUE)

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "TCRExpansionProportionsBoxPlot_", "Polyclonal", ".pdf")),
  height = 5.5,
  width = 6)

# Print the plot
print(box_plot)

dev.off()

#--------------------------------------------------IARvsCEFX_downsampledCEFX---------------------------------------------------------------------

# Get the number of cells each donor has in stimulationFigures = "IAR"
iar_cells_per_donor <- seuratQCMergedCleaned@meta.data %>%
  filter(stimulationFigures == "IAR") %>%
  group_by(donorIdFigures) %>%
  summarise(n_cells = n(), .groups = "drop")

# Filter down to only Treg and Tconv cells for the given stimulations (IAR and Microbial)
seurat_subset_iar <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR" & cellType %in% c("Treg", "Tconv"))
seurat_subset_microbial <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial" & cellType %in% c("Treg", "Tconv"))

# Check if any cells are found
if (nrow(seurat_subset_iar@meta.data) == 0) {
  message("No cells found for stimulation: IAR")
  return(NULL)
}
if (nrow(seurat_subset_microbial@meta.data) == 0) {
  message("No cells found for stimulation: Microbial")
  return(NULL)
}

# Initialize a list to store the downsampled proportions for Microbial
downsampled_proportions <- list()

# Repeat the downsampling 100 times for Microbial
set.seed(6022)
for (i in 1:100) {
  downsampled_metadata <- seurat_subset_microbial@meta.data %>%
    group_by(donorIdFigures) %>%
    group_modify(~ {
      n_cells <- iar_cells_per_donor$n_cells[iar_cells_per_donor$donorIdFigures == .y$donorIdFigures]
      if (length(n_cells) == 0) return(.x)  # If no IAR cells for this donor, return original data
      sample_n(.x, size = min(n_cells, nrow(.x)), replace = FALSE)
    }) %>%
    ungroup()

  # Extract the fullLengthNTCloneID column from the metadata
  fullLengthNTCloneIDs <- downsampled_metadata$fullLengthNTCloneID

  # Count the occurrences of each fullLengthNTCloneID
  fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

  # Filter the IDs that have 2 or more occurrences
  fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])

  # Add a new column to indicate whether the clone ID is expanded
  downsampled_metadata <- downsampled_metadata %>%
    mutate(expanded = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered, "Expanded", "Not Expanded"))

  # Calculate the proportion of expanded cells per donorIdFigures, stimulationFigures, and cellType
  expanded_proportion <- downsampled_metadata %>%
    group_by(donorIdFigures, stimulationFigures, cellType) %>%
    summarise(Proportion_Expanded = mean(expanded == "Expanded"), .groups = "drop")

  # Store the downsampled proportions
  downsampled_proportions[[i]] <- expanded_proportion
}

# Combine the downsampled proportions and calculate the median for each donor
combined_proportions_microbial <- bind_rows(downsampled_proportions) %>%
  group_by(donorIdFigures, stimulationFigures, cellType) %>%
  summarise(Proportion_Expanded = median(Proportion_Expanded), .groups = "drop")

# Process the IAR data without downsampling
# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs_iar <- seurat_subset_iar@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts_iar <- table(fullLengthNTCloneIDs_iar)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered_iar <- names(fullLengthNTCloneID_counts_iar[fullLengthNTCloneID_counts_iar >= 2])

# Add a new column to indicate whether the clone ID is expanded
metadata_iar <- seurat_subset_iar@meta.data %>%
  mutate(expanded = ifelse(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered_iar, "Expanded", "Not Expanded"))

# Calculate the proportion of expanded cells per donorIdFigures, stimulationFigures, and cellType
expanded_proportion_iar <- metadata_iar %>%
  group_by(donorIdFigures, stimulationFigures, cellType) %>%
  summarise(Proportion_Expanded = mean(expanded == "Expanded"), .groups = "drop")

# Combine the IAR and Microbial data
combined_proportions <- bind_rows(
  combined_proportions_microbial,
  expanded_proportion_iar
) %>%
  mutate(group = interaction(stimulationFigures, cellType))

# Print debug information
print(head(combined_proportions))

# Create the box plot
box_plot <- ggplot(combined_proportions, aes(x = group, y = Proportion_Expanded, fill = cellType)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.6) +
  scale_fill_manual(values = c("Treg" = "blue", "Tconv" = "red")) +
  labs(
    title = "Proportion of Expanded Clones per Donor \n(Microbial downsampled to IAR cell counts)",
    x = "Stimulation and Cell Type",
    y = "Proportion of Expanded Clones",
    fill = "Cell Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.text = element_text(size = 12)
  )


# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "TCRExpansionProportionsBoxPlot_", "Microbial_IAR_Downsampled.pdf")),
  height = 5.5,
  width = 6)

# Print the plot
print(box_plot)

dev.off()
```

```{r TCRSharingBetweenDonorsJaccardHeatmaps}
# Function to calculate Jaccard index
calculate_jaccard <- function(set1, set2) {
  intersection <- length(intersect(set1, set2))
  union <- length(union(set1, set2))
  return(intersection / union)
}

#--------------------------------All cells-------------------------------------------------
# Extract the threePointCloneID column from the metadata
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = cellType %in% c("Treg", "Tconv"))
clone_data <- seurat_subset.tmp@meta.data %>%
  select(donorIdFigures, threePointCloneID) %>%
  distinct()

# Filter to include only clone IDs that appear more than once
clone_counts <- clone_data %>%
  group_by(threePointCloneID) %>%
  summarise(count = n(), .groups = "drop") %>%
  filter(count > 1)

filtered_clone_data <- clone_data %>%
  filter(threePointCloneID %in% clone_counts$threePointCloneID)

# Create a list of clone sets for each donor
clone_sets <- filtered_clone_data %>%
  group_by(donorIdFigures) %>%
  summarise(clones = list(threePointCloneID), .groups = "drop")

# Calculate the Jaccard index matrix
donors <- unique(filtered_clone_data$donorIdFigures)
jaccard_matrix <- matrix(0, nrow = length(donors), ncol = length(donors), dimnames = list(donors, donors))

for (i in 1:length(donors)) {
  for (j in 1:length(donors)) {
    set1 <- clone_sets$clones[[i]]
    set2 <- clone_sets$clones[[j]]
    jaccard_matrix[i, j] <- calculate_jaccard(set1, set2)
  }
}


# Generate the heatmap
heatmap.tmp <- Heatmap(jaccard_matrix,
  name = "Jaccard Index",
  col = viridis(100),
  show_row_names = TRUE,
  show_column_names = TRUE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Jaccard index for all Treg/Tconv cells",
  heatmap_legend_param = list(title = "Jaccard Index"))

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "betweenDonorTCRSharing_JaccardIdxHeatmap_threePointCloneID", ".pdf")),
  height = 5.5,
  width = 8)

# Draw the heatmap
print(heatmap.tmp)
dev.off()

#-----------------------------------------IAR-------------------------------------------------------------------------
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR" & cellType %in% c("Treg", "Tconv"))
clone_data <- seurat_subset.tmp@meta.data %>%
  select(donorIdFigures, threePointCloneID) %>%
  distinct()

# Filter to include only clone IDs that appear more than once
clone_counts <- clone_data %>%
  group_by(threePointCloneID) %>%
  summarise(count = n(), .groups = "drop") %>%
  filter(count > 1)

filtered_clone_data <- clone_data %>%
  filter(threePointCloneID %in% clone_counts$threePointCloneID)

# Create a list of clone sets for each donor
clone_sets <- filtered_clone_data %>%
  group_by(donorIdFigures) %>%
  summarise(clones = list(threePointCloneID), .groups = "drop")

# Calculate the Jaccard index matrix
donors <- unique(filtered_clone_data$donorIdFigures)
jaccard_matrix <- matrix(0, nrow = length(donors), ncol = length(donors), dimnames = list(donors, donors))

for (i in 1:length(donors)) {
  for (j in 1:length(donors)) {
    set1 <- clone_sets$clones[[i]]
    set2 <- clone_sets$clones[[j]]
    jaccard_matrix[i, j] <- calculate_jaccard(set1, set2)
  }
}


# Generate the heatmap
heatmap.tmp <- Heatmap(jaccard_matrix,
  name = "Jaccard Index",
  col = viridis(100),
  show_row_names = TRUE,
  show_column_names = TRUE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Jaccard index for IAR Treg/Tconv cells",
  heatmap_legend_param = list(title = "Jaccard Index"))

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "betweenDonorTCRSharing_JaccardIdxHeatmap_threePointCloneID_IAR", ".pdf")),
  height = 5.5,
  width = 8)

# Draw the heatmap
print(heatmap.tmp)
dev.off()
#-----------------------------------------CEFX------------------------------------------------------------------------
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial" & cellType %in% c("Treg", "Tconv"))
clone_data <- seurat_subset.tmp@meta.data %>%
  select(donorIdFigures, threePointCloneID) %>%
  distinct()

# Filter to include only clone IDs that appear more than once
clone_counts <- clone_data %>%
  group_by(threePointCloneID) %>%
  summarise(count = n(), .groups = "drop") %>%
  filter(count > 1)

filtered_clone_data <- clone_data %>%
  filter(threePointCloneID %in% clone_counts$threePointCloneID)

# Create a list of clone sets for each donor
clone_sets <- filtered_clone_data %>%
  group_by(donorIdFigures) %>%
  summarise(clones = list(threePointCloneID), .groups = "drop")

# Calculate the Jaccard index matrix
donors <- unique(filtered_clone_data$donorIdFigures)
jaccard_matrix <- matrix(0, nrow = length(donors), ncol = length(donors), dimnames = list(donors, donors))

for (i in 1:length(donors)) {
  for (j in 1:length(donors)) {
    set1 <- clone_sets$clones[[i]]
    set2 <- clone_sets$clones[[j]]
    jaccard_matrix[i, j] <- calculate_jaccard(set1, set2)
  }
}


# Generate the heatmap
heatmap.tmp <- Heatmap(jaccard_matrix,
  name = "Jaccard Index",
  col = viridis(100),
  show_row_names = TRUE,
  show_column_names = TRUE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Jaccard index for CEFX Treg/Tconv cells",
  heatmap_legend_param = list(title = "Jaccard Index"))

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "betweenDonorTCRSharing_JaccardIdxHeatmap_threePointCloneID_CEFX", ".pdf")),
  height = 5.5,
  width = 8)

# Draw the heatmap
print(heatmap.tmp)
dev.off()
#-----------------------------------------Polyclonal------------------------------------------------------------------
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal" & cellType %in% c("Treg", "Tconv"))
clone_data <- seurat_subset.tmp@meta.data %>%
  select(donorIdFigures, threePointCloneID) %>%
  distinct()

# Filter to include only clone IDs that appear more than once
clone_counts <- clone_data %>%
  group_by(threePointCloneID) %>%
  summarise(count = n(), .groups = "drop") %>%
  filter(count > 1)

filtered_clone_data <- clone_data %>%
  filter(threePointCloneID %in% clone_counts$threePointCloneID)

# Create a list of clone sets for each donor
clone_sets <- filtered_clone_data %>%
  group_by(donorIdFigures) %>%
  summarise(clones = list(threePointCloneID), .groups = "drop")

# Calculate the Jaccard index matrix
donors <- unique(filtered_clone_data$donorIdFigures)
jaccard_matrix <- matrix(0, nrow = length(donors), ncol = length(donors), dimnames = list(donors, donors))

for (i in 1:length(donors)) {
  for (j in 1:length(donors)) {
    set1 <- clone_sets$clones[[i]]
    set2 <- clone_sets$clones[[j]]
    jaccard_matrix[i, j] <- calculate_jaccard(set1, set2)
  }
}


# Generate the heatmap
heatmap.tmp <- Heatmap(jaccard_matrix,
  name = "Jaccard Index",
  col = viridis(100),
  show_row_names = TRUE,
  show_column_names = TRUE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  column_title = "Jaccard index for Polyclonal Treg/Tconv cells",
  heatmap_legend_param = list(title = "Jaccard Index"))

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "betweenDonorTCRSharing_JaccardIdxHeatmap_threePointCloneID_Polyclonal", ".pdf")),
  height = 5.5,
  width = 8)

# Draw the heatmap
print(heatmap.tmp)
dev.off()



rm_tmp(ask = FALSE)
```

```{r TCRBarPlotsWithinDonorSharing}
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "IAR") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])


# Extract metadata from the Seurat object
metadata <- seurat_subset.tmp@meta.data

# Remove cells with NA or empty clone IDs
metadata_clean <- metadata %>%
  filter(!is.na(fullLengthNTCloneID) & fullLengthNTCloneID != "")

# Filter to clones with two or more occurrences
metadata_filtered <- metadata_clean %>%
  filter(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered)

# Summarize cell counts per donor per clone
clone_summary <- metadata_filtered %>%
  group_by(donorIdFigures, fullLengthNTCloneID) %>%
  summarise(Cell_Count = n(), .groups = "drop")

# Calculate percentages per clone per donor
clone_percentage <- clone_summary %>%
  group_by(donorIdFigures) %>%
  mutate(Percentage = (Cell_Count / sum(Cell_Count)) * 100) %>%
  ungroup()

# Create the stacked bar plot
barPlot.tmp <- ggplot(clone_percentage, aes(x = factor(donorIdFigures), y = Percentage, fill = fullLengthNTCloneID)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Clone Composition per Donor\nIAR",
    x = "Donor ID",
    y = "Percentage of Cells (%)",
    fill = "Clone ID"
  ) +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)),
    position = position_stack(vjust = 0.5),
    size = 2, color = "white") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",
    legend.text = element_text(size = 6)
  )

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "WithinDonorTCRCloneCompositionIAR.pdf")),
  height = 5.5,
  width = 12)

# Print the plot
print(barPlot.tmp)

dev.off()







# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Microbial") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])


# Extract metadata from the Seurat object
metadata <- seurat_subset.tmp@meta.data

# Remove cells with NA or empty clone IDs
metadata_clean <- metadata %>%
  filter(!is.na(fullLengthNTCloneID) & fullLengthNTCloneID != "")

# Filter to clones with two or more occurrences
metadata_filtered <- metadata_clean %>%
  filter(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered)

# Summarize cell counts per donor per clone
clone_summary <- metadata_filtered %>%
  group_by(donorIdFigures, fullLengthNTCloneID) %>%
  summarise(Cell_Count = n(), .groups = "drop")

# Calculate percentages per clone per donor
clone_percentage <- clone_summary %>%
  group_by(donorIdFigures) %>%
  mutate(Percentage = (Cell_Count / sum(Cell_Count)) * 100) %>%
  ungroup()

# Create the stacked bar plot
barPlot.tmp <- ggplot(clone_percentage, aes(x = factor(donorIdFigures), y = Percentage, fill = fullLengthNTCloneID)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Clone Composition per Donor\nCEFX",
    x = "Donor ID",
    y = "Percentage of Cells (%)",
    fill = "Clone ID"
  ) +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)),
    position = position_stack(vjust = 0.5),
    size = 2, color = "white") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",
    legend.text = element_text(size = 6)
  )

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "WithinDonorTCRCloneCompositionCEFX.pdf")),
  height = 5.5,
  width = 12)

# Print the plot
print(barPlot.tmp)

dev.off()






# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleaned, subset = stimulationFigures == "Polyclonal") # select the stimulation
seurat_subset.tmp <- subset(seurat_subset.tmp, subset = cellType %in% c("Treg", "Tconv")) # limit to just the Treg/Tconv cells. Exclude 'Other'

# Extract the fullLengthNTCloneID column from the metadata
fullLengthNTCloneIDs <- seurat_subset.tmp@meta.data$fullLengthNTCloneID

# Count the occurrences of each fullLengthNTCloneID
fullLengthNTCloneID_counts <- table(fullLengthNTCloneIDs)

# Filter the IDs that have 2 or more occurrences
fullLengthNTCloneID_filtered <- names(fullLengthNTCloneID_counts[fullLengthNTCloneID_counts >= 2])


# Extract metadata from the Seurat object
metadata <- seurat_subset.tmp@meta.data

# Remove cells with NA or empty clone IDs
metadata_clean <- metadata %>%
  filter(!is.na(fullLengthNTCloneID) & fullLengthNTCloneID != "")

# Filter to clones with two or more occurrences
metadata_filtered <- metadata_clean %>%
  filter(fullLengthNTCloneID %in% fullLengthNTCloneID_filtered)

# Summarize cell counts per donor per clone
clone_summary <- metadata_filtered %>%
  group_by(donorIdFigures, fullLengthNTCloneID) %>%
  summarise(Cell_Count = n(), .groups = "drop")

# Calculate percentages per clone per donor
clone_percentage <- clone_summary %>%
  group_by(donorIdFigures) %>%
  mutate(Percentage = (Cell_Count / sum(Cell_Count)) * 100) %>%
  ungroup()

# Create the stacked bar plot
barPlot.tmp <- ggplot(clone_percentage, aes(x = factor(donorIdFigures), y = Percentage, fill = fullLengthNTCloneID)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Clone Composition per Donor\nPolyclonal",
    x = "Donor ID",
    y = "Percentage of Cells (%)",
    fill = "Clone ID"
  ) +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)),
    position = position_stack(vjust = 0.5),
    size = 2, color = "white") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",
    legend.text = element_text(size = 6)
  )

# Save the plot to PDF
pdf(file.path(plotDir, paste0(filenameSuffix, "WithinDonorTCRCloneCompositionPolyclonal.pdf")),
  height = 5.5,
  width = 12)

# Print the plot
print(barPlot.tmp)

dev.off()
```


```{r TCRSharingBetweenStimulations}
# Extract metadata from seuratQCMergedCleaned
metadata <- seuratQCMergedCleaned@meta.data

# Filter for cells with stimulationFigures equal to "IAR" and "Microbial"
iar_clones <- metadata %>%
  filter(stimulationFigures == "IAR") %>%
  filter(cellType == "Other") %>%
  pull(fullLengthNTCloneID) %>%
  unique()

microbial_clones <- metadata %>%
  filter(stimulationFigures == "Microbial") %>%
  filter(cellType == "Other") %>%
  pull(fullLengthNTCloneID) %>%
  unique()

# Find the intersection of fullLengthNTCloneIDs between the two groups
shared_clones <- intersect(iar_clones, microbial_clones)

# Count the number of shared fullLengthNTCloneIDs
num_shared_clones <- length(shared_clones)

# Print the result
print(num_shared_clones)
```
### Matt D - style Circos plot chunks

```{r defineBandedCircosFunction}
library(circlize)

plot_TCR_circos_bands <- function(agg_cells, agg_links, filename = NULL, plottype = "pdf", plotdims = c(12, 12)) {
  if (!requireNamespace("circlize", quietly = TRUE))
    stop("Package 'circlize' is needed. Please install it.")

  if (!is.null(filename)) {
    if (plottype == "pdf") {
      pdf(file = filename, width = plotdims[1], height = plotdims[2])
    } else if (plottype == "png") {
      png(filename = filename, width = plotdims[1], height = plotdims[2], units = "in", res = 600)
    }
  }

  circos.clear()
  # Set parameters; adjust gap.degree if you want the sectors more separated.
  circos.par(cell.padding = c(0, 0, 0, 0),
    track.margin = c(0, 0.1),
    start.degree = 90,
    gap.degree = 2)

  # Sectors are defined by the combo labels.
  sectors <- agg_cells$combo
  xlim_mat <- cbind(rep(0, length(sectors)), agg_cells$count)
  circos.initialize(factors = sectors, xlim = xlim_mat)

  # Inner ring: studyGroup colors.
  circos.trackPlotRegion(
    ylim = c(0, 1),
    factors = sectors,
    track.height = 0.1,
    panel.fun = function(x, y) {
      i <- get.cell.meta.data("sector.numeric.index")
      xlim <- get.cell.meta.data("xlim")
      sector <- get.cell.meta.data("sector.index")
      # Extract studyGroup part from "studyGroup_cellType"
      study_grp <- sub("_.*", "", sector)
      study_col <- agg_cells$study_color[agg_cells$combo == sector]
      circos.rect(xleft = xlim[1], ybottom = 0,
        xright = xlim[2], ytop = 1,
        col = study_col, border = NA)
      circos.text(x = mean(xlim), y = 0.5, labels = study_grp,
        facing = "inside", niceFacing = TRUE, cex = 0.8)
    },
    bg.border = NA
  )

  # Outer ring: cellType colors.
  circos.trackPlotRegion(
    ylim = c(0, 1),
    factors = sectors,
    track.height = 0.1,
    panel.fun = function(x, y) {
      i <- get.cell.meta.data("sector.numeric.index")
      xlim <- get.cell.meta.data("xlim")
      sector <- get.cell.meta.data("sector.index")
      # Extract cellType part from "studyGroup_cellType"
      cell_type <- sub(".*_", "", sector)
      cell_col <- agg_cells$cell_color[agg_cells$combo == sector]
      circos.rect(xleft = xlim[1], ybottom = 0,
        xright = xlim[2], ytop = 1,
        col = cell_col, border = NA)
      circos.text(x = mean(xlim), y = 0.5, labels = cell_type,
        facing = "outside", niceFacing = TRUE, cex = 0.8)
    },
    bg.border = NA,
    track.index = 2
  )

  # Draw connecting links (bands)
  if (!is.null(agg_links) && nrow(agg_links) > 0) {
    for (k in 1:nrow(agg_links)) {
      circos.link(
        sector.index1 = agg_links$combo1[k],
        point1 = agg_links$pos1[k],
        sector.index2 = agg_links$combo2[k],
        point2 = agg_links$pos2[k],
        col = agg_links$link_color[k],
        lwd = agg_links$link_bandwidth[k],
        rou1 = 0.75, rou2 = 0.75
      )
    }
  }

  if (!is.null(filename))
    dev.off()

  circos.clear()
}
```

```{r createObjectsPlotCircosQc}
# add seuratQCMergedCleanedDS@meta.data$cellType to TCRs.DS.df, matching on $barcode
metaData.df.tmp <- seuratQCMergedCleaned@meta.data %>%
  dplyr::select(barcode, cellType, stimulationFigures, donorIdFigures, studyGroup)

# Perform the left join to add cellType to TCRs.DS.df
TCRs.df.tmp <- cleanTCRs.df %>%
  left_join(metaData.df.tmp, by = "barcode")

# rm_tmp(ask = FALSE)

## define columns for sample and group variables
sampleColumnCircosQc <- "cellType"
groupColumnCircosQc <- "studyGroup"

# Filter TCRs to those of interest
tcrsCircos <- TCRs.df.tmp

# Add sample info (sample and group) to the tcr df
# tcrsCircosQcCd8 <-
#   left_join(
#     tcrsCircosQcCd8,
#     annotatedMetricsQC %>% dplyr::select(libid, all_of(c(sampleColumnCircosQcCd8, groupColumnCircosQcCd8))))
# check for columns duplicated in tcr and annotation.merged
# grep("\\.[xy]", colnames(tcrsCircosQcCd8), value=TRUE)
# none; good!

# sort tcrsCircosQcCd8 by the variables of interest (which might be unnecessary?)
# tcrsCircosQcCd8 <-
#   tcrsCircosQcCd8[
#     order(tcrsCircosQcCd8[, groupColumnCircosQcCd8, drop = TRUE],
#       tcrsCircosQcCd8[, sampleColumnCircosQcCd8, drop = TRUE]), ]

# # Make a new numeric libid number for each lib, in the order libs have been arranged, to facilitate plotting order
# tcrsCircosQcCd8 <-
#   tcrsCircosQcCd8 %>%
#   dplyr::rename(old.libid = libid)
# tcrsCircosQcCd8$libid <-
#   tcrsCircosQcCd8$old.libid %>%
#   match(unique(.))

### determine expanded TCRs
tcrChainMatchesCircosQc <- match_TCR_chains(tcrsCircos,
  id_col = "barcode",
  junction_col = "cdr3")

### tabulate number of chains matching between cells
tcrLinksCircosQc <-
  tabulate_shared_TCR_chains(tcrChainMatchesCircosQc) %>%
  dplyr::arrange(tcr1)

### create new data frame to store cell information (colors on various rings)
tcrCellsCircosQc <- tcrsCircos

# Then map the cellType column in tcrCellsCircosQc to valid color codes:
tcrCellsCircosQc$cellType_color <- palCellType[as.character(tcrCellsCircosQc$cellType)]
tcrCellsCircosQc$studyGroup_color <- palStudyGroup[tcrCellsCircosQc$studyGroup]
# # Set up project colors for incorporation into tcr_cells
# samplePalCircosQc <-
#   big_colorblind_pal(length(unique(tcrsCircos[, sampleColumnCircosQc, drop = TRUE]))) %>%
#   setNames(length(unique(tcrsCircos[, sampleColumnCircosQc, drop = TRUE])))

# ## set up color palette for sub-projects, using variations on a color scheme
# # can use sample() around the colorRampPalette() calls to randomize the order of colors
# samplePalCircosQc <-
#   palDonorId[names(palDonorId) %in% tcrCellsCircosQc$donorId]
# tcrCellsCircosQc$sampleCol <-
#   samplePalCircosQc[
#     as.character(
#       tcrCellsCircosQc[
#         , sampleColumnCircosQc, drop = TRUE])]

# groupPalCircosQc <-
#   palCellTypeGroup[names(palCellTypeGroup) %in% tcrCellsCircosQc$Cell.Type_CD8]
# tcrCellsCircosQc$groupCol <-
#   groupPalCircosQc[
#     as.character(
#       tcrCellsCircosQc[
#         , groupColumnCircosQc, drop = TRUE])]

tcrCellsCircosQc <- unique(tcrCellsCircosQc[, c("barcode", "cellType", "studyGroup", "cellType_color")]) %>%
  dplyr::rename(tcr1 = barcode)

tcrCellsCircosQc$tcr1 <-
  factor(tcrCellsCircosQc$tcr1,
    levels = gtools::mixedsort(tcrCellsCircosQc$tcr1))
tcrCellsCircosQcC <-
  tcrCellsCircosQc %>%
  dplyr::arrange(tcr1)

## set colors of links (average sample colors of the two TCRs)
tcrLinksCircosQc$sampleCol <-
  cbind(
    tcrCellsCircosQc$sampleCol[
      match(tcrLinksCircosQc$tcr1, tcrCellsCircosQc$tcr1)],
    tcrCellsCircosQc$sampleCol[
      match(tcrLinksCircosQc$tcr2, tcrCellsCircosQc$tcr1)]) # %>%
# apply(MARGIN = 1, FUN = miscHelpers::average_colors)
```

```{r plotCircosQc, dependson="createObjectsPlotCircosQc"}
## generate a circos plot with individuals and patient groups labeled
# filenamePlotCircosQc <-
#   paste0("circosQc_noMAIT_by_", groupColumnCircosQc, "_and_", sampleColumnCircosQc,
#     ".", filenameSuffix, ".pdf")
# plot_TCR_circos(
#   tcrCellsCircosQc, tcrLinksCircosQc,
#   ring_colors = c("cellType_color", "studyGroup_color"),  # ensure studyGroup is also valid or mapped similarly
#   link_colors = "cellType_color",
#   link_width = "num_shared_chains",
#   filename = file.path(plotDir, filenamePlotCircosQc))
# Ensure tcrCellsCircosQc includes studyGroup and cellType
```

```{r plotCircosLegendsQc, dependson="createObjectsPlotCircosQc"}
## output color legends for incorporation downstream
# easier to output them separately and merge them in Illustrator
filenameCircosLegend1Qc <-
  paste0("circosQc_noMAIT_legend_", sampleColumnCircosQc,
    ".", filenameSuffix, ".pdf")
pdf(
  file.path(plotDir, filenameCircosLegend1Qc),
  w = 5, h = 8)
plot.new()

legend(
  x = "topleft",
  title = "Donor ID",
  legend = names(samplePalCircosQc), fill = samplePalCircosQc,
  bty = "n", xpd = TRUE)

# # version for splitting legend into two columns
# legend(
#   x = "topleft",
#   legend=
#     names(samplePalCircosQcCd8)[
#       1:floor(length(samplePalCircosQcCd8)/2)],
#   fill=
#     samplePalCircosQcCd8[
#       1:floor(length(samplePalCircosQcCd8)/2)],
#   bty = "n", xpd=TRUE)
# legend(
#   x = "topright",
#   legend
#   =names(samplePalCircosQcCd8)[
#     ceiling((length(samplePalCircosQcCd8)+1)/2):length(samplePalCircosQcCd8)],
#   fill=
#     samplePalCircosQcCd8[
#       ceiling((length(samplePalCircosQcCd8)+1)/2):length(samplePalCircosQcCd8)],
#   bty = "n", xpd=TRUE)
invisible(dev.off())

# legend for groups
filenameCircosLegend2Qc <-
  paste0("circosQc_legend_", groupColumnCircosQc,
    ".", filenameSuffix, ".pdf")
pdf(
  file.path(plotDir, filenameCircosLegend2Qc),
  w = 3, h = 3)
plot.new()
legend(
  x = "topleft",
  title = "Study group",
  legend = names(palCellTypeGroup), fill = palCellTypeGroup,
  bty = "n", xpd = TRUE)
invisible(dev.off())
```

```{r circosWithBandWidth}
# Install and load the circlize package
# library(circlize)

# Example data preparation
# Assume you have a data frame `tcr_data` with columns: `cell1`, `cell2`, and `shared_tcr_count`
# `cell1` and `cell2` are the cell identifiers, and `shared_tcr_count` is the number of shared TCRs

# Example data
tcr_data <- data.frame(
  cell1 = c("A", "A", "B", "C"),
  cell2 = c("B", "C", "C", "D"),
  shared_tcr_count = c(5, 3, 2, 4)
)

# Define the plot directory and filename
filename <- file.path(plotDir, "circos_plot.png")

# Save the plot to a PNG file
png(filename = filename, width = 6, height = 5, units = "in", res = 600)

# Initialize the circos plot
circos.initialize(factors = unique(c(tcr_data$cell1, tcr_data$cell2)), xlim = c(0, 1))

# Add the circos track
circos.trackPlotRegion(factors = unique(c(tcr_data$cell1, tcr_data$cell2)), ylim = c(0, 1), panel.fun = function(x, y) {
  circos.axis()
})

# Add links with varying widths based on shared TCR count
for (i in 1:nrow(tcr_data)) {
  circos.link(
    sector.index1 = tcr_data$cell1[i],
    point1 = 0.5,
    sector.index2 = tcr_data$cell2[i],
    point2 = 0.5,
    col = "blue",
    lwd = tcr_data$shared_tcr_count[i]
  )
}

# Clear the circos plot
circos.clear()

# Close the PNG device
dev.off()
```

### MSigDB dotplots

```{r MSigDB_output_workaround}
# nothing in R seems to reproduce MSigDB GSEA results, so we'll load in the output.tsv and try from there....

# load MSigDB GSEA output.tsv
MSigDBResult <- read_csv(paste0(dataDirSaved, "/MSigDB-GSEA_output_counterRegGenes_subset.csv"))

# for dotplot, we will need genRatio, p.adjust, counts?, module name
# Convert the columns to the correct data types
MSigDBResult$k_div_K <- as.numeric(MSigDBResult$k_div_K)
MSigDBResult$p_value <- as.numeric(MSigDBResult$p_value)
MSigDBResult$NumGenesinOverlap_k <- as.numeric(MSigDBResult$NumGenesinOverlap_k)

# Sort the data frame by k_div_K
MSigDBResult <- MSigDBResult[order(MSigDBResult$k_div_K), ]

outfile_png <- paste0(dirPlots, "/", dataDate, "_", "MSigDB_dotplot_counterregGenes", ".png")
outfile_pdf <- paste0(dirPlots, "/", dataDate, "_", "MSigDB_dotplot_counterregGenes", ".pdf")

# Create a new column for the transformed p-values
MSigDBResult$log_p_value <- -log10(MSigDBResult$p_value)

dotPlot.tmp <- ggplot(MSigDBResult, aes(x = k_div_K, y = reorder(GeneSetName, k_div_K), size = NumGenesinOverlap_k, color = log_p_value)) +
  geom_point() +
  scale_size_area(max_size = 7) +  # Use scale_size_area
  scale_color_gradient(low = "blue", high = "red", breaks = c(8, 6, 4, 2)) +  # Set the breaks to 8, 6, 4, 2
  theme_minimal() +
  labs(title = "MSigDB GSEA",
    x = "Gene Ratio",
    y = "Gene Set Name",
    color = expression(-log[10]("p-value")),  # Use expression() to create the subscript
    size = "Overlap Count") +
  guides(color = guide_colorbar(nbin = 4))  # Set the number of bins to 4

# Save the plot as a PNG
png(outfile_png, width = 7, height = 5.5, units = "in", res = 600)
print(dotPlot.tmp)
dev.off()

# Save the plot as a PDF
pdf(outfile_pdf, width = 7, height = 5.5)
print(dotPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r MSigDB_output_workaround_bySign}
# nothing in R seems to reproduce MSigDB GSEA results, so we'll load in the output.tsv and try from there....

# load MSigDB GSEA output.tsv
MSigDBResult <- read_csv(paste0(dataDirSaved, "/MSigDB-GSEA_output_counterRegGenes_logFCsign.csv"))

# for dotplot, we will need genRatio, p.adjust, counts?, module name
# Convert the columns to the correct data types
MSigDBResult$k_div_K <- as.numeric(MSigDBResult$k_div_K)
MSigDBResult$p_value <- as.numeric(MSigDBResult$p_value)
MSigDBResult$NumGenesInOverlap_k <- as.numeric(MSigDBResult$NumGenesInOverlap_k)

# Sort the data frame by k_div_K
MSigDBResult <- MSigDBResult[order(MSigDBResult$k_div_K), ]

outfile_png <- paste0(dirPlots, "/", dataDate, "_", "MSigDB_dotplot_counterregGenes_bySign", ".png")
outfile_pdf <- paste0(dirPlots, "/", dataDate, "_", "MSigDB_dotplot_counterregGenes_bySign", ".pdf")

# Create a new column for the transformed p-values
MSigDBResult$log_p_value <- -log10(MSigDBResult$p_value)

dotPlot.tmp <- ggplot(MSigDBResult, aes(x = k_div_K, y = reorder(geneSetName, k_div_K), size = NumGenesInOverlap_k, color = log_p_value)) +
  geom_point() +
  scale_size_area(max_size = 7) +  # Use scale_size_area
  scale_color_gradient(low = "blue", high = "red", breaks = c(8, 6, 4, 2)) +  # Set the breaks to 8, 6, 4, 2
  theme_minimal() +
  labs(title = "MSigDB GSEA",
    x = "Gene Ratio",
    y = "Gene Set Name",
    color = expression(-log[10]("p-value")),  # Use expression() to create the subscript
    size = "Overlap Count") +
  guides(color = guide_colorbar(nbin = 4))  # Set the number of bins to 4

# Save the plot as a PNG
png(outfile_png, width = 7, height = 5.5, units = "in", res = 600)
print(dotPlot.tmp)
dev.off()

# Save the plot as a PDF
pdf(outfile_pdf, width = 7, height = 5.5)
print(dotPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r AlexHuTCRBetweenDonorSharingHeatmap}
# Keep only rows with donorIdFigures
cleanTCRs.df.tmp <- cleanTCRs.df[!is.na(cleanTCRs.df$donorIdFigures), ]

# Outer loop: iterate over chains
for (chain in c("TRB", "TRA", "Pair")) {
  # Subset and set matchcol based on chain
  if (chain == "Pair") {
    df.chain <- cleanTCRs.df.tmp
    matchcol <- "threePointCloneID"
  } else if (chain == "TRA") {
    df.chain <- cleanTCRs.df.tmp[cleanTCRs.df.tmp$chain == "TRA", ]
    matchcol <- "threePointCloneID_alpha"
  } else if (chain == "TRB") {
    df.chain <- cleanTCRs.df.tmp[cleanTCRs.df.tmp$chain == "TRB", ]
    matchcol <- "threePointCloneID_beta"
  }

  # Inner loop: iterate over cell type filters
  for (ct in c("Treg", "Tconv", "TregTconv")) {
    # Subset based on cell type selection: if TregTconv, include both
    if (ct == "TregTconv") {
      df.sub <- df.chain %>% dplyr::filter(cellType %in% c("Treg", "Tconv"))
    } else {
      df.sub <- df.chain %>% dplyr::filter(cellType == ct)
    }

    # Create new identifier columns using the appropriate matchcol
    df.sub$donorJunctionType <- paste0(df.sub$donorIdFigures, "_", df.sub[, matchcol], "_", df.sub$cellType)
    df.sub$donorJunction <- paste0(df.sub$donorIdFigures, "_", df.sub[, matchcol])
    df.sub$donorType <- paste0(df.sub$donorIdFigures, "_", df.sub$cellType)

    # Keep one row per unique donorJunctionType
    chainsUnique <- df.sub[!duplicated(df.sub$donorJunctionType), ]

    donorTypes <- unique(chainsUnique$donorType)

    # Set up donor color mapping; adjust palDonorId as needed in your context
    donorCols <- palDonorId
    names(donorCols) <- c("2", "5", "6", "1", "3", "4")

    # Calculate the sharing matrix using the Jaccard index
    sharingMat <- sapply(donorTypes, function(d1) {
      sapply(donorTypes, function(d2) {
        set1 <- unique(chainsUnique[chainsUnique$donorType == d1, matchcol])
        set2 <- unique(chainsUnique[chainsUnique$donorType == d2, matchcol])
        length(intersect(set1, set2)) / length(unique(c(set1, set2)))
      })
    })

    # Build a data frame (dmat) from rownames of sharingMat.
    # The rownames are assumed to be in the format "donorIdFigures_studyGroup_cellType"
    dmat <- data.frame(t(sapply(rownames(sharingMat), function(s) unlist(strsplit(s, "_")))))
    colnames(dmat) <- c("donorIdFigures", "studyGroup", "cellType")
    dmat$group <- dmat$studyGroup
    dmat$id <- as.character(dmat$donorIdFigures)

    sort_order <- paste0(dmat$cellType, " ", dmat$group)
    sharingMat <- sharingMat[order(sort_order), order(sort_order)]
    dmat <- dmat[order(sort_order), ]
    sort_order <- sort_order[order(sort_order)]

    # Prepare the upper-triangular sharing matrix (set lower triangle and diagonal to NA)
    tp <- sharingMat
    tp[lower.tri(tp)] <- NA
    for (i in 1:nrow(tp)) {
      tp[i, i] <- NA
    }

    # Prepare heatmap annotations using dmat and donorCols, palStudyGroup, palCellType
    ha <- HeatmapAnnotation(
      df = dmat[, c("cellType", "studyGroup", "id")],
      col = list(
        studyGroup = palStudyGroup,
        cellType = palCellType,
        id = donorCols
      ),
      show_legend = FALSE
    )
    ra <- rowAnnotation(
      df = dmat[, c("cellType", "studyGroup", "id")],
      col = list(
        studyGroup = palStudyGroup,
        cellType = palCellType,
        id = donorCols
      )
    )

    # Define heatmap color function
    col_fun <- colorRamp2(c(0, max(tp, na.rm = TRUE)), c("gray90", "red"))

    # Define output filename and open PDF device
    out_filename <- file.path(plotDir, paste0(filenameSuffix, chain, "_", ct, "SharingMatrix_allDonors_", matchcol, "_jaccard.pdf"))
    pdf(out_filename, width = 9, height = 8)

    # Create the heatmap
    p <- Heatmap(tp,
      col = col_fun,
      name = "jaccard\nindex",
      na_col = "white",
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      show_heatmap_legend = TRUE,
      top_annotation = ha,
      column_split = sort_order,
      row_split = sort_order,
      show_row_names = FALSE,
      show_column_names = FALSE,
      row_title_side = "right",
      column_title = paste0("Counts of Shared ", chain, " ",
        ifelse(matchcol == "threePointCloneID", "v-gene, CDR3 AA, j-gene", matchcol),
        "_AA", "\nBetween Donors and CD4 Types"),
      row_title_gp = gpar(fontsize = 0)) + ra

    print(p)
    dev.off()
  }
}
```

```{r AlexHuTCRBetweenDonorSharingHeatmapStimulationSplit}
# Keep only rows with donorIdFigures
cleanTCRs.df.tmp <- cleanTCRs.df[!is.na(cleanTCRs.df$donorIdFigures), ]

# Outer loop: iterate over chains
for (chain in c("TRB", "TRA", "Pair")) {
  # Subset and set matchcol based on chain
  if (chain == "Pair") {
    df.chain <- cleanTCRs.df.tmp
    matchcol <- "threePointCloneID"
  } else if (chain == "TRA") {
    df.chain <- cleanTCRs.df.tmp[cleanTCRs.df.tmp$chain == "TRA", ]
    matchcol <- "threePointCloneID_alpha"
  } else if (chain == "TRB") {
    df.chain <- cleanTCRs.df.tmp[cleanTCRs.df.tmp$chain == "TRB", ]
    matchcol <- "threePointCloneID_beta"
  }

  # Inner loop: iterate over cell type filters
  for (ct in c("Treg", "Tconv", "TregTconv")) {
    # Subset based on cell type selection: if TregTconv, include both
    if (ct == "TregTconv") {
      df.sub <- df.chain %>% dplyr::filter(cellType %in% c("Treg", "Tconv"))
    } else {
      df.sub <- df.chain %>% dplyr::filter(cellType == ct)
    }

    # Create new identifier columns using the appropriate matchcol
    df.sub$donorJunctionType <- paste0(df.sub$donorIdFigures, "_", df.sub[, matchcol], "_", df.sub$cellType)
    df.sub$donorJunction <- paste0(df.sub$donorIdFigures, "_", df.sub[, matchcol])
    df.sub$donorType <- paste0(df.sub$donorIdFigures, "_", df.sub$cellType)

    # Keep one row per unique donorJunctionType
    chainsUnique <- df.sub[!duplicated(df.sub$donorJunctionType), ]

    donorTypes <- unique(chainsUnique$donorType)

    # Set up donor color mapping; adjust palDonorId as needed in your context
    donorCols <- palDonorId
    names(donorCols) <- c("2", "5", "6", "1", "3", "4")

    # Calculate the sharing matrix using the Jaccard index
    sharingMat <- sapply(donorTypes, function(d1) {
      sapply(donorTypes, function(d2) {
        set1 <- unique(chainsUnique[chainsUnique$donorType == d1, matchcol])
        set2 <- unique(chainsUnique[chainsUnique$donorType == d2, matchcol])
        length(intersect(set1, set2)) / length(unique(c(set1, set2)))
      })
    })

    # Build a data frame (dmat) from rownames of sharingMat.
    # The rownames are assumed to be in the format "donorIdFigures_studyGroup_cellType"
    dmat <- data.frame(t(sapply(rownames(sharingMat), function(s) unlist(strsplit(s, "_")))))
    colnames(dmat) <- c("donorIdFigures", "studyGroup", "cellType")
    dmat$group <- dmat$studyGroup
    dmat$id <- as.character(dmat$donorIdFigures)

    sort_order <- paste0(dmat$cellType, " ", dmat$group)
    sharingMat <- sharingMat[order(sort_order), order(sort_order)]
    dmat <- dmat[order(sort_order), ]
    sort_order <- sort_order[order(sort_order)]

    # Prepare the upper-triangular sharing matrix (set lower triangle and diagonal to NA)
    tp <- sharingMat
    tp[lower.tri(tp)] <- NA
    for (i in 1:nrow(tp)) {
      tp[i, i] <- NA
    }

    # Prepare heatmap annotations using dmat and donorCols, palStudyGroup, palCellType
    ha <- HeatmapAnnotation(
      df = dmat[, c("cellType", "studyGroup", "id")],
      col = list(
        studyGroup = palStudyGroup,
        cellType = palCellType,
        id = donorCols
      ),
      show_legend = FALSE
    )
    ra <- rowAnnotation(
      df = dmat[, c("cellType", "studyGroup", "id")],
      col = list(
        studyGroup = palStudyGroup,
        cellType = palCellType,
        id = donorCols
      )
    )

    # Define heatmap color function
    col_fun <- colorRamp2(c(0, max(tp, na.rm = TRUE)), c("gray90", "red"))

    # Define output filename and open PDF device
    out_filename <- file.path(plotDir, paste0(filenameSuffix, chain, "_", ct, "SharingMatrix_allDonors_", matchcol, "_jaccard.pdf"))
    pdf(out_filename, width = 9, height = 8)

    # Create the heatmap
    p <- Heatmap(tp,
      col = col_fun,
      name = "jaccard\nindex",
      na_col = "white",
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      show_heatmap_legend = TRUE,
      top_annotation = ha,
      column_split = sort_order,
      row_split = sort_order,
      show_row_names = FALSE,
      show_column_names = FALSE,
      row_title_side = "right",
      column_title = paste0("Counts of Shared ", chain, " ",
        ifelse(matchcol == "threePointCloneID", "v-gene, CDR3 AA, j-gene", matchcol),
        "_AA", "\nBetween Donors and CD4 Types"),
      row_title_gp = gpar(fontsize = 0)) + ra

    print(p)
    dev.off()
  }
}
```

```{r AgReactiveTCRPairsInterIntraStimAccounting}
# First, determine expansion status across ALL data (any barcode sharing)
cleanTCRAgSpecificPairs.df <- cleanTCRAgSpecificPairs.df %>%
  mutate(expanded = fullLengthNT %in% fullLengthNT[duplicated(fullLengthNT)])

# Define all possible stimulation combinations
all_stims <- c("Microbial", "IAR", "Polyclonal")

# Generate all combinations: single, pairs, and triplets
stim_combinations <- list(
  # Single stimulations
  "Microbial",
  "IAR",
  "Polyclonal",
  # Pairs of stimulations
  c("Microbial", "IAR"),
  c("Microbial", "Polyclonal"),
  c("IAR", "Polyclonal"),
  # All three stimulations
  c("Microbial", "IAR", "Polyclonal")
)

# Function to calculate TCR metrics for a given subset
calculate_tcr_metrics <- function(data_subset, subset_name) {
  if (nrow(data_subset) == 0) {
    return(data.frame(
      subset = subset_name,
      total_pairs = 0,
      unique_tcrs = 0,
      expanded_pairs = 0,
      unique_expanded_tcrs = 0,
      percent_expansion = 0
    ))
  }

  total_pairs <- nrow(data_subset)
  unique_tcrs <- length(unique(data_subset$fullLengthNT))
  expanded_pairs <- sum(data_subset$expanded)
  unique_expanded_tcrs <- length(unique(data_subset$fullLengthNT[data_subset$expanded]))
  percent_expansion <- (expanded_pairs / total_pairs) * 100

  return(data.frame(
    subset = subset_name,
    total_pairs = total_pairs,
    unique_tcrs = unique_tcrs,
    expanded_pairs = expanded_pairs,
    unique_expanded_tcrs = unique_expanded_tcrs,
    percent_expansion = round(percent_expansion, 2)
  ))
}

# Function to calculate Treg/Tconv sharing
calculate_sharing <- function(treg_data, tconv_data) {
  if (nrow(treg_data) == 0 || nrow(tconv_data) == 0) {
    return(list(
      treg_shared_with_tconv = 0,
      tconv_shared_with_treg = 0,
      unique_tcrs_shared = 0,
      treg_shared_unique_tcrs = 0,
      tconv_shared_unique_tcrs = 0
    ))
  }

  treg_tcrs <- treg_data$fullLengthNT
  tconv_tcrs <- tconv_data$fullLengthNT

  # Get unique TCR sequences for each cell type
  unique_treg_tcrs <- unique(treg_tcrs)
  unique_tconv_tcrs <- unique(tconv_tcrs)

  # Find shared unique TCR sequences
  shared_unique_tcrs <- intersect(unique_treg_tcrs, unique_tconv_tcrs)

  # Cell-level sharing (current method - counts individual cell pairs)
  treg_shared_with_tconv <- sum(treg_tcrs %in% tconv_tcrs)
  tconv_shared_with_treg <- sum(tconv_tcrs %in% treg_tcrs)

  # Unique TCR-level sharing (new method - counts unique sequences)
  treg_shared_unique_tcrs <- sum(unique_treg_tcrs %in% unique_tconv_tcrs)
  tconv_shared_unique_tcrs <- sum(unique_tconv_tcrs %in% unique_treg_tcrs)

  return(list(
    treg_shared_with_tconv = treg_shared_with_tconv,
    tconv_shared_with_treg = tconv_shared_with_treg,
    unique_tcrs_shared = length(shared_unique_tcrs),
    treg_shared_unique_tcrs = treg_shared_unique_tcrs,
    tconv_shared_unique_tcrs = tconv_shared_unique_tcrs
  ))
}

# Create mutually exclusive stimulation categories based on TCR sharing patterns
# First, determine which stimulations each TCR appears in
tcr_stim_mapping <- cleanTCRAgSpecificPairs.df %>%
  group_by(fullLengthNT) %>%
  summarise(
    stims_present = list(unique(stimulationFigures)),
    n_stims = length(unique(stimulationFigures)),
    .groups = "drop"
  ) %>%
  mutate(
    stim_category = case_when(
      # Single stimulations (TCR only appears in one stim)
      n_stims == 1 & sapply(stims_present, function(x) "Microbial" %in% x) ~ "Microbial_only",
      n_stims == 1 & sapply(stims_present, function(x) "IAR" %in% x) ~ "IAR_only",
      n_stims == 1 & sapply(stims_present, function(x) "Polyclonal" %in% x) ~ "Polyclonal_only",
      # Pairs of stimulations (TCR appears in exactly 2 stims)
      n_stims == 2 & sapply(stims_present, function(x) all(c("Microbial", "IAR") %in% x)) ~ "Microbial_IAR",
      n_stims == 2 & sapply(stims_present, function(x) all(c("Microbial", "Polyclonal") %in% x)) ~ "Microbial_Polyclonal",
      n_stims == 2 & sapply(stims_present, function(x) all(c("IAR", "Polyclonal") %in% x)) ~ "IAR_Polyclonal",
      # All three stimulations (TCR appears in all 3 stims)
      n_stims == 3 ~ "All_three",
      TRUE ~ "Other"
    )
  )

# Debug: Check the mapping
cat("=== Debugging TCR Stimulation Mapping ===\n")
cat("Number of unique TCRs:", nrow(tcr_stim_mapping), "\n")
cat("Category breakdown in mapping:\n")
print(table(tcr_stim_mapping$stim_category, useNA = "always"))
cat("Sample of mapping data:\n")
print(head(tcr_stim_mapping))
cat("==========================================\n\n") # Add category information back to main dataframe
cleanTCRAgSpecificPairs.df <- cleanTCRAgSpecificPairs.df %>%
  left_join(tcr_stim_mapping %>% select(fullLengthNT, stim_category), by = "fullLengthNT")

# Debug: Check if the join worked
cat("=== Debugging TCR Category Assignment ===\n")
cat("Number of rows in cleanTCRAgSpecificPairs.df:", nrow(cleanTCRAgSpecificPairs.df), "\n")
cat("Column names:", paste(colnames(cleanTCRAgSpecificPairs.df), collapse = ", "), "\n")
cat("Number of TCRs with categories assigned:", sum(!is.na(cleanTCRAgSpecificPairs.df$stim_category)), "\n")
cat("Category breakdown:\n")
print(table(cleanTCRAgSpecificPairs.df$stim_category, useNA = "always"))
cat("========================================\n\n")

# Define the 7 mutually exclusive categories
categories <- c("Microbial_only", "IAR_only", "Polyclonal_only",
  "Microbial_IAR", "Microbial_Polyclonal", "IAR_Polyclonal",
  "All_three")

# Initialize results dataframes
all_celltype_results <- data.frame()
treg_results <- data.frame()
tconv_results <- data.frame()

cat("=== TCR Pair Accounting Analysis (Mutually Exclusive Categories) ===\n\n")

# Pre-loop debugging: Check if stim_category column exists
cat("=== Pre-loop Debugging ===\n")
cat("Column names in cleanTCRAgSpecificPairs.df:\n")
print(colnames(cleanTCRAgSpecificPairs.df))
cat("\nChecking for stim_category column:\n")
if ("stim_category" %in% colnames(cleanTCRAgSpecificPairs.df)) {
  cat(" stim_category column found\n")
  cat("stim_category breakdown:\n")
  print(table(cleanTCRAgSpecificPairs.df$stim_category, useNA = "always"))
} else {
  cat(" ERROR: stim_category column NOT found!\n")
  cat("This suggests the tcr_stim_mapping join failed.\n")
  cat("Attempting to recreate stim_category...\n")

  # Recreate the stim_category if it's missing
  tcr_stim_mapping <- cleanTCRAgSpecificPairs.df %>%
    group_by(fullLengthNT) %>%
    summarise(
      stims_present = list(unique(stimulationFigures)),
      n_stims = length(unique(stimulationFigures)),
      .groups = "drop"
    ) %>%
    mutate(
      stim_category = case_when(
        # Single stimulations (TCR only appears in one stim)
        n_stims == 1 & sapply(stims_present, function(x) "Microbial" %in% x) ~ "Microbial_only",
        n_stims == 1 & sapply(stims_present, function(x) "IAR" %in% x) ~ "IAR_only",
        n_stims == 1 & sapply(stims_present, function(x) "Polyclonal" %in% x) ~ "Polyclonal_only",
        # Pairs of stimulations (TCR appears in exactly 2 stims)
        n_stims == 2 & sapply(stims_present, function(x) all(c("Microbial", "IAR") %in% x)) ~ "Microbial_IAR",
        n_stims == 2 & sapply(stims_present, function(x) all(c("Microbial", "Polyclonal") %in% x)) ~ "Microbial_Polyclonal",
        n_stims == 2 & sapply(stims_present, function(x) all(c("IAR", "Polyclonal") %in% x)) ~ "IAR_Polyclonal",
        # All three stimulations (TCR appears in all 3 stims)
        n_stims == 3 ~ "All_three",
        TRUE ~ "Other"
      )
    )

  # Re-join the category information
  cleanTCRAgSpecificPairs.df <- cleanTCRAgSpecificPairs.df %>%
    left_join(tcr_stim_mapping %>% select(fullLengthNT, stim_category), by = "fullLengthNT")

  cat(" stim_category recreated and joined\n")
  print(table(cleanTCRAgSpecificPairs.df$stim_category, useNA = "always"))
}
cat("=============================\n\n")

# Loop through each category
for (category in categories) {
  cat("Category:", category, "\n")
  cat(rep("=", nchar(category) + 10), "\n")

  # Filter data for this category
  combo_data <- cleanTCRAgSpecificPairs.df %>%
    dplyr::filter(stim_category == category)

  treg_data <- combo_data %>% dplyr::filter(cellType == "Treg")
  tconv_data <- combo_data %>% dplyr::filter(cellType == "Tconv")

  # Calculate metrics for all cell types
  all_metrics <- calculate_tcr_metrics(combo_data, category)
  all_celltype_results <- rbind(all_celltype_results, all_metrics)

  cat("ALL CELL TYPES:\n")
  cat("  Total TCR pairs:", all_metrics$total_pairs, "\n")
  cat("  Unique TCRs:", all_metrics$unique_tcrs, "\n")
  cat("  Expanded pairs:", all_metrics$expanded_pairs, "\n")
  cat("  Unique expanded TCRs:", all_metrics$unique_expanded_tcrs, "\n")
  cat("  Percent expansion:", all_metrics$percent_expansion, "%\n\n")

  # Calculate sharing between Treg and Tconv
  sharing_metrics <- calculate_sharing(treg_data, tconv_data)

  # Calculate metrics for Tregs only
  treg_metrics <- calculate_tcr_metrics(treg_data, category)
  treg_metrics$shared_with_tconv <- sharing_metrics$treg_shared_with_tconv
  treg_metrics$shared_unique_tcrs <- sharing_metrics$treg_shared_unique_tcrs
  treg_results <- rbind(treg_results, treg_metrics)

  cat("TREG ONLY:\n")
  cat("  Total TCR pairs:", treg_metrics$total_pairs, "\n")
  cat("  Unique TCRs:", treg_metrics$unique_tcrs, "\n")
  cat("  Expanded pairs:", treg_metrics$expanded_pairs, "\n")
  cat("  Unique expanded TCRs:", treg_metrics$unique_expanded_tcrs, "\n")
  cat("  Percent expansion:", treg_metrics$percent_expansion, "%\n")
  cat("  TCR pairs shared with Tconv (cell-level):", sharing_metrics$treg_shared_with_tconv, "\n")
  cat("  Unique TCRs shared with Tconv:", sharing_metrics$treg_shared_unique_tcrs, "\n\n")

  # Calculate metrics for Tconvs only
  tconv_metrics <- calculate_tcr_metrics(tconv_data, category)
  tconv_metrics$shared_with_treg <- sharing_metrics$tconv_shared_with_treg
  tconv_metrics$shared_unique_tcrs <- sharing_metrics$tconv_shared_unique_tcrs
  tconv_results <- rbind(tconv_results, tconv_metrics)

  cat("TCONV ONLY:\n")
  cat("  Total TCR pairs:", tconv_metrics$total_pairs, "\n")
  cat("  Unique TCRs:", tconv_metrics$unique_tcrs, "\n")
  cat("  Expanded pairs:", tconv_metrics$expanded_pairs, "\n")
  cat("  Unique expanded TCRs:", tconv_metrics$unique_expanded_tcrs, "\n")
  cat("  Percent expansion:", tconv_metrics$percent_expansion, "%\n")
  cat("  TCR pairs shared with Treg (cell-level):", sharing_metrics$tconv_shared_with_treg, "\n")
  cat("  Unique TCRs shared with Treg:", sharing_metrics$tconv_shared_unique_tcrs, "\n")
  cat("  Total unique TCRs shared between cell types:", sharing_metrics$unique_tcrs_shared, "\n\n")

  cat("\n")
}

# Print summary tables
cat("=== SUMMARY TABLES ===\n\n")

cat("All Cell Types Summary:\n")
print(all_celltype_results)

cat("\nTreg Summary:\n")
print(treg_results)

cat("\nTconv Summary:\n")
print(tconv_results)

# Save results to files
write.csv(all_celltype_results, file.path(dataOutputDir, "TCR_accounting_all_celltypes.csv"), row.names = FALSE)
write.csv(treg_results, file.path(dataOutputDir, "TCR_accounting_Treg.csv"), row.names = FALSE)
write.csv(tconv_results, file.path(dataOutputDir, "TCR_accounting_Tconv.csv"), row.names = FALSE)

cat("\nResults saved to:", dataOutputDir, "\n")

# Create cleanTCRAgSpecificInterStimPairs.df with only inter-stimulation TCRs
# (TCRs found in 2 or 3 stimulations)
inter_stim_categories <- c("Microbial_IAR", "Microbial_Polyclonal", "IAR_Polyclonal", "All_three")

cleanTCRAgSpecificInterStimPairs.df <- cleanTCRAgSpecificPairs.df %>%
  filter(stim_category %in% inter_stim_categories)

cat("\n=== Inter-Stimulation TCR Pairs ===\n")
cat("Total inter-stim TCR pairs:", nrow(cleanTCRAgSpecificInterStimPairs.df), "\n")
cat("Breakdown by category:\n")
print(table(cleanTCRAgSpecificInterStimPairs.df$stim_category))
cat("Breakdown by cell type:\n")
print(table(cleanTCRAgSpecificInterStimPairs.df$cellType, cleanTCRAgSpecificInterStimPairs.df$stim_category))
cat("===================================\n")
```

```{r examineClusterLevelsTconv}
# Process hyperparameter grid to handle NA values and keep only the last row per nClusters
optHyperParamGrid.df <- read.xlsx(file.path(dataOutputDir, "20250611_RNA_clustering_TconvOnly_hyperParamGrid.xlsx")) %>%
  data.frame() %>%
  # Remove rows with NA in required parameters
  filter(!is.na(findNeighborsDim) & !is.na(findClustersRes) & !is.na(min.dist) & !is.na(n_neighbors)) %>%
  # Group by nClusters and keep the last row in each group
  group_by(nClusters) %>%
  slice_tail(n = 1) %>%
  ungroup()

# Print a summary of the hyperparameter combinations we'll be testing
print(paste("Processing", nrow(optHyperParamGrid.df), "hyperparameter combinations"))
print(optHyperParamGrid.df[, c("nClusters", "findNeighborsDim", "findClustersRes", "min.dist", "n_neighbors")])

# For each selected hyperparameter combination
for (i in 1:nrow(optHyperParamGrid.df)) {
  # Extract hyperparameters for this row
  findNeighborsDim <- optHyperParamGrid.df$findNeighborsDim[i]
  findClustersRes <- optHyperParamGrid.df$findClustersRes[i]
  min.dist <- optHyperParamGrid.df$min.dist[i]
  n_neighbors <- optHyperParamGrid.df$n_neighbors[i]
  expected_clusters <- optHyperParamGrid.df$nClusters[i]

  current_iter <- i  # Store the current iteration number for use in nested operations

  cat(sprintf("\nProcessing hyperparameter set %d/%d: dims=%d, res=%.2f, min.dist=%.2f, n_neighbors=%d (expecting %d clusters)\n",
    current_iter, nrow(optHyperParamGrid.df),
    findNeighborsDim, findClustersRes, min.dist, n_neighbors, expected_clusters))

  # ==========Re-clustering with the current set of hyperparameters================
  # Reset the Seurat object to original state before reclustering
  DefaultAssay(seuratTconv) <- "RNA"

  set.seed(6022)
  seuratTconv <- FindNeighbors(seuratTconv, dims = 1:findNeighborsDim)
  seuratTconv <- FindClusters(seuratTconv, resolution = findClustersRes)

  set.seed(6022)
  seuratTconv <- RunUMAP(object = seuratTconv,
    reduction = "pca",
    return.model = TRUE,
    dims = 1:findNeighborsDim,
    n.neighbors = n_neighbors,
    min.dist = min.dist)

  # Store cluster info in seurat object metadata
  # Initialize clusterName and clusterMarkers
  clusterName <- character()
  clusterMarkers <- list()

  # Create the cluster name for RNA
  clusterName <- "seurat_clusters_Tconv"

  # Add metadata to the Seurat object
  seuratTconv <- seuratTconv %>%
    Seurat::AddMetaData(Idents(seuratTconv), col.name = clusterName)

  # Set the identifiers
  Idents(seuratTconv) <- seuratTconv@meta.data[[clusterName]]

  # Ensure data layers are joined
  seuratTconv <- JoinLayers(seuratTconv)

  # Get the actual number of clusters (may differ from expected)
  num_clusters <- n_distinct(seuratTconv@meta.data[[clusterName]])
  nClustString <- paste0("_", as.character(num_clusters), "Clusters")

  # Check if the actual number of clusters matches expected
  if (num_clusters != expected_clusters) {
    cat(sprintf("Warning: Expected %d clusters but found %d clusters\n", expected_clusters, num_clusters))
  }

  # Generate a fresh color palette for the specific number of clusters in this iteration
  palRNAClustersTconv <- paletteer_d("khroma::land", n = num_clusters) %>%
    sample() %>%  # Shuffle colors
    .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
    setNames(sort(unique(seuratTconv@meta.data[[clusterName]])))

  # Find cluster markers for this iteration
  clusterMarkers <- list()
  clusterMarkers[[paste0("RNA_", clusterName)]] <- FindAllMarkers(seuratTconv, assay = "RNA")

  # Filter for genes expressed in at least 30% of cells in their cluster
  expressionData <- FetchData(seuratTconv, vars = unique(clusterMarkers[[paste0("RNA_", clusterName)]]$gene))
  metadata <- seuratTconv@meta.data %>%
    dplyr::select(seurat_clusters) %>%
    rownames_to_column("cell")

  expressionData <- expressionData %>%
    rownames_to_column("cell") %>%
    left_join(metadata, by = "cell")

  expressionDataLong <- expressionData %>%
    pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

  expressionDataSummary <- expressionDataLong %>%
    group_by(seurat_clusters, gene) %>%
    summarise(percent_expressed = mean(expression > 0) * 100, .groups = "drop")

  min_percent_expressed <- 30
  clusterMarkers[[paste0("RNA_", clusterName)]] <- clusterMarkers[[paste0("RNA_", clusterName)]] %>%
    left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
    filter(percent_expressed >= min_percent_expressed)

  # Get top markers for plotting (10 per cluster)
  topMarkersPlotLong <- clusterMarkers[[paste0("RNA_", clusterName)]] %>%
    dplyr::group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 0) %>%
    dplyr::slice_max(avg_log2FC, n = 10) %>%
    dplyr::slice_min(p_val_adj, n = 10) %>%
    dplyr::mutate(fc_order = order(avg_log2FC))

  topMarkersPlot <- topMarkersPlotLong %>%
    pivot_wider(id_cols = "fc_order",
      names_from = "cluster",
      values_from = "gene") %>%
    dplyr::select(-one_of("fc_order"))

  # Also save the top 30 genes per cluster
  nGenes <- 30
  nGenesString <- as.character(nGenes)
  nGenesPlot <- 10
  nGenesStringPlot <- as.character(nGenesPlot)

  topMarkersLong <- clusterMarkers[[paste0("RNA_", clusterName)]] %>%
    dplyr::group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 0) %>%
    dplyr::slice_max(avg_log2FC, n = nGenes) %>%
    dplyr::slice_min(p_val_adj, n = nGenes) %>%
    dplyr::mutate(fc_order = order(avg_log2FC))

  topMarkers <- topMarkersLong %>%
    pivot_wider(id_cols = "fc_order",
      names_from = "cluster",
      values_from = "gene") %>%
    dplyr::select(-one_of("fc_order"))

  # Save the top cluster defining genes
  write.csv(
    topMarkers,
    file.path(dataOutputDir, paste0("top", nGenesString, "_genes_per_cluster_Tconv", nClustString, ".csv")),
    quote = FALSE,
    row.names = TRUE
  )

  # =================Reference map the non-downsampled cells onto seuratTconv=============
  # Create a fresh copy of seuratQCMergedCleaned for this iteration to avoid conflicts
  seuratQCMergedCleaned_iter <- seuratQCMergedCleaned

  # Remove any existing ref.umap and ref.umap_Tconv reductions to avoid conflicts
  if ("ref.umap" %in% names(seuratQCMergedCleaned_iter@reductions)) {
    seuratQCMergedCleaned_iter@reductions[["ref.umap"]] <- NULL
  }
  if ("ref.umap_Tconv" %in% names(seuratQCMergedCleaned_iter@reductions)) {
    seuratQCMergedCleaned_iter@reductions[["ref.umap_Tconv"]] <- NULL
  }

  # Normalize data
  seuratQCMergedCleaned_iter <- NormalizeData(seuratQCMergedCleaned_iter,
    verbose = FALSE,
    normalization.method = "LogNormalize",
    margin = 2,
    assay = "RNA")
  seuratTconv <- NormalizeData(seuratTconv,
    verbose = FALSE,
    normalization.method = "LogNormalize",
    margin = 2,
    assay = "RNA")

  # Find variable features
  seuratQCMergedCleaned_iter <- FindVariableFeatures(seuratQCMergedCleaned_iter,
    selection.method = "vst", nfeatures = 2000, verbose = FALSE)
  seuratTconv <- FindVariableFeatures(seuratTconv,
    selection.method = "vst", nfeatures = 2000, verbose = FALSE)

  # Find shared features
  featuresShared <- intersect(VariableFeatures(seuratQCMergedCleaned_iter), VariableFeatures(seuratTconv))

  # Find transfer anchors
  anchors <- FindTransferAnchors(reference = seuratTconv, query = seuratQCMergedCleaned_iter,
    features = featuresShared, reference.reduction = "pca")

  # Transfer cluster labels with unique column name for this iteration
  col_name <- paste0("seurat_clusters_Tconv_iter", current_iter)
  predictions <- TransferData(anchorset = anchors, refdata = seuratTconv$seurat_clusters, dims = 1:30)
  colnames(predictions)[1] <- col_name

  # Add predictions to BOTH objects
  seuratQCMergedCleaned <- AddMetaData(seuratQCMergedCleaned, metadata = predictions[, col_name], col.name = col_name)
  seuratQCMergedCleaned_iter <- AddMetaData(seuratQCMergedCleaned_iter, metadata = predictions[, col_name], col.name = col_name)

  # Project UMAP with explicit reduction name for this iteration
  seuratQCMergedCleaned_iter <- MapQuery(
    anchorset = anchors,
    reference = seuratTconv,
    query = seuratQCMergedCleaned_iter,
    reference.reduction = "pca",
    reduction.model = "umap"
  )

  # After mapping, rename the resulting reduction to keep iterations distinct
  reduction_name <- paste0("ref.umap_Tconv_iter", current_iter)
  seuratQCMergedCleaned_iter@reductions[["ref.umap"]]@key <- paste0("refumap", current_iter, "_")
  seuratQCMergedCleaned_iter@reductions[[reduction_name]] <- seuratQCMergedCleaned_iter@reductions[["ref.umap"]]

  # ================Make a dotplot from the top 10 cluster-defining genes================
  # Subset down to Tconv cells only for visualization
  seurat.tmp <- subset(seuratQCMergedCleaned_iter, cellType == "Tconv")

  fontSize <- 8

  # Extract the gene names from topMarkersPlot (top 10 per cluster)
  genes.tmp <- unique(unlist(topMarkersPlot))

  # Create a DotPlot using the current iteration's predictions
  dotPlot.tmp <- DotPlot(seurat.tmp, dot.scale = 3.75, features = genes.tmp, group.by = col_name) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Tconv Clusters", x = "Cluster-defining genes") +
    guides(color = guide_colorbar(title = "Average\nExpression\nz-score"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Save the dotplot
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_top", nGenesStringPlot, "ClusterDefiningGenesDotPlotTconvs"),
    height = 4,
    width = 7,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # make a DotPlot with the 'curated' gene list
  dotPlot.tmp <- DotPlot(seurat.tmp, dot.scale = 3.75, features = geneListTconvCurated, group.by = col_name) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Treg Clusters", x = "Curated genes (Tconv)") +
    guides(color = guide_colorbar(title = "Average\nExpression\nz-score"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Save the dotplot
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "curatedGenesDotPlotTconvs"),
    height = 4,
    width = 7,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make UMAP colored by clusters================
  seurat.tmp.umap <- seuratTconv
  print(seurat.tmp.umap@reductions)
  print(table(seurat.tmp.umap@meta.data$seurat_clusters))
  print(table(seurat.tmp.umap@meta.data$seurat_clusters_Tconv))

  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "seurat_clusters",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palRNAClustersTconv) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TconvOnly"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make UMAP colored by stimulation================
  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "stimulationFigures",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palStimulation) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TconvOnly_stimulation"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )
  # ================Make UMAP colored by CellTypistL1================
  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "cellTypistCalling",
    shuffle = TRUE,
    pt.size = 1) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TconvOnly_cellTypistL1"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make UMAP colored by CellTypistL3================
  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "cellTypistCallingL3",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palCellTypistL3) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TconvOnly_cellTypistL3"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )
  # ================Make reference-mapped UMAPs (showing only Tconv cells)================
  # Create a subset with only Tconv cells
  seurat.ref.map <- subset(seuratQCMergedCleaned_iter, cellType == "Tconv")

  # Get the specific reduction name for this iteration
  ref_map_reduction <- paste0("ref.umap_Tconv_iter", current_iter)

  # 1. UMAP colored by transferred clusters
  set.seed(314)
  ref_map_cluster_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = col_name,
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palRNAClustersTconv) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster",
      title = "Reference-mapped Tconv cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_cluster_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TconvOnly_clusters"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # 2. UMAP colored by stimulation
  set.seed(314)
  ref_map_stim_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = "stimulationFigures",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palStimulation) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation",
      title = "Reference-mapped Tconv cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_stim_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TconvOnly_stimulation"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # 3. UMAP colored by CellTypistL1
  set.seed(314)
  ref_map_cluster_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = "cellTypistCalling",
    shuffle = TRUE,
    pt.size = 1) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster",
      title = "Reference-mapped Tconv cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_cluster_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TconvOnly_cellTypistL1"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # 4. UMAP colored by CellTypistL3
  set.seed(314)
  ref_map_cluster_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = "cellTypistCallingL3",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palCellTypistL3) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster",
      title = "Reference-mapped Tconv cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_cluster_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TconvOnly_cellTypistL3"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # Clean up temporary variables - SAFELY check if they exist first
  to_remove <- c()
  if (exists("seuratQCMergedCleaned_iter")) to_remove <- c(to_remove, "seuratQCMergedCleaned_iter")
  if (exists("anchors")) to_remove <- c(to_remove, "anchors")
  if (exists("predictions")) to_remove <- c(to_remove, "predictions")
  if (exists("seurat.tmp")) to_remove <- c(to_remove, "seurat.tmp")
  if (exists("seurat.tmp.umap")) to_remove <- c(to_remove, "seurat.tmp.umap")
  if (exists("dotPlot.tmp")) to_remove <- c(to_remove, "dotPlot.tmp")
  if (exists("plot.tmp")) to_remove <- c(to_remove, "plot.tmp")
  if (exists("ref_map_cluster_plot")) to_remove <- c(to_remove, "ref_map_cluster_plot")
  if (exists("ref_map_stim_plot")) to_remove <- c(to_remove, "ref_map_stim_plot")
  if (exists("seurat.ref.map")) to_remove <- c(to_remove, "seurat.ref.map")

  if (length(to_remove) > 0) {
    rm(list = to_remove)
  }

  # Force garbage collection
  gc()

  # Keep the loop counter (i) intact!
  cat(sprintf("Completed hyperparameter set %d/%d with %d clusters\n",
    i, nrow(optHyperParamGrid.df), num_clusters))
}

# Final message
cat("Processing complete!\n")
```

```{r examineClusterLevelsTreg}
# Process hyperparameter grid to handle NA values and keep only the last row per nClusters
optHyperParamGrid.df <- read.xlsx(file.path(dataOutputDir, "20250609_RNA_clustering_TregOnly_hyperParamGrid.xlsx")) %>%
  data.frame() %>%
  # Remove rows with NA in required parameters
  filter(!is.na(findNeighborsDim) & !is.na(findClustersRes) & !is.na(min.dist) & !is.na(n_neighbors)) %>%
  # Group by nClusters and keep the last row in each group
  group_by(nClusters) %>%
  slice_tail(n = 1) %>%
  ungroup()

# Print a summary of the hyperparameter combinations we'll be testing
print(paste("Processing", nrow(optHyperParamGrid.df), "hyperparameter combinations"))
print(optHyperParamGrid.df[, c("nClusters", "findNeighborsDim", "findClustersRes", "min.dist", "n_neighbors")])

# For each selected hyperparameter combination
for (i in 1:nrow(optHyperParamGrid.df)) {
  # Extract hyperparameters for this row
  findNeighborsDim <- optHyperParamGrid.df$findNeighborsDim[i]
  findClustersRes <- optHyperParamGrid.df$findClustersRes[i]
  min.dist <- optHyperParamGrid.df$min.dist[i]
  n_neighbors <- optHyperParamGrid.df$n_neighbors[i]
  expected_clusters <- optHyperParamGrid.df$nClusters[i]

  current_iter <- i  # Store the current iteration number for use in nested operations

  cat(sprintf("\nProcessing hyperparameter set %d/%d: dims=%d, res=%.2f, min.dist=%.2f, n_neighbors=%d (expecting %d clusters)\n",
    current_iter, nrow(optHyperParamGrid.df),
    findNeighborsDim, findClustersRes, min.dist, n_neighbors, expected_clusters))

  # ==========Re-clustering with the current set of hyperparameters================
  # Reset the Seurat object to original state before reclustering
  DefaultAssay(seuratTreg) <- "RNA"

  set.seed(6022)
  seuratTreg <- FindNeighbors(seuratTreg, dims = 1:findNeighborsDim)
  seuratTreg <- FindClusters(seuratTreg, resolution = findClustersRes)

  set.seed(6022)
  seuratTreg <- RunUMAP(object = seuratTreg,
    reduction = "pca",
    return.model = TRUE,
    dims = 1:findNeighborsDim,
    n.neighbors = n_neighbors,
    min.dist = min.dist)

  # Store cluster info in seurat object metadata
  # Initialize clusterName and clusterMarkers
  clusterName <- character()
  clusterMarkers <- list()

  # Create the cluster name for RNA
  clusterName <- "seurat_clusters_Treg"

  # Add metadata to the Seurat object
  seuratTreg <- seuratTreg %>%
    Seurat::AddMetaData(Idents(seuratTreg), col.name = clusterName)

  # Set the identifiers
  Idents(seuratTreg) <- seuratTreg@meta.data[[clusterName]]

  # Ensure data layers are joined
  seuratTreg <- JoinLayers(seuratTreg)

  # Get the actual number of clusters (may differ from expected)
  num_clusters <- n_distinct(seuratTreg@meta.data[[clusterName]])
  nClustString <- paste0("_", as.character(num_clusters), "Clusters")

  # Check if the actual number of clusters matches expected
  if (num_clusters != expected_clusters) {
    cat(sprintf("Warning: Expected %d clusters but found %d clusters\n", expected_clusters, num_clusters))
  }

  # Generate a fresh color palette for the specific number of clusters in this iteration
  palRNAClustersTreg <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
    sample() %>%  # Shuffle colors
    .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
    setNames(sort(unique(seuratTreg@meta.data[[clusterName]])))

  # Find cluster markers for this iteration
  clusterMarkers <- list()
  clusterMarkers[[paste0("RNA_", clusterName)]] <- FindAllMarkers(seuratTreg, assay = "RNA")

  # Filter for genes expressed in at least 30% of cells in their cluster
  expressionData <- FetchData(seuratTreg, vars = unique(clusterMarkers[[paste0("RNA_", clusterName)]]$gene))
  metadata <- seuratTreg@meta.data %>%
    dplyr::select(seurat_clusters) %>%
    rownames_to_column("cell")

  expressionData <- expressionData %>%
    rownames_to_column("cell") %>%
    left_join(metadata, by = "cell")

  expressionDataLong <- expressionData %>%
    pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

  expressionDataSummary <- expressionDataLong %>%
    group_by(seurat_clusters, gene) %>%
    summarise(percent_expressed = mean(expression > 0) * 100, .groups = "drop")

  min_percent_expressed <- 30
  clusterMarkers[[paste0("RNA_", clusterName)]] <- clusterMarkers[[paste0("RNA_", clusterName)]] %>%
    left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
    filter(percent_expressed >= min_percent_expressed)

  # Get top markers for plotting (10 per cluster)
  topMarkersPlotLong <- clusterMarkers[[paste0("RNA_", clusterName)]] %>%
    dplyr::group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 0) %>%
    dplyr::slice_max(avg_log2FC, n = 10) %>%
    dplyr::slice_min(p_val_adj, n = 10) %>%
    dplyr::mutate(fc_order = order(avg_log2FC))

  topMarkersPlot <- topMarkersPlotLong %>%
    pivot_wider(id_cols = "fc_order",
      names_from = "cluster",
      values_from = "gene") %>%
    dplyr::select(-one_of("fc_order"))

  # Also save the top 30 genes per cluster
  nGenes <- 30
  nGenesString <- as.character(nGenes)
  nGenesPlot <- 10
  nGenesStringPlot <- as.character(nGenesPlot)

  topMarkersLong <- clusterMarkers[[paste0("RNA_", clusterName)]] %>%
    dplyr::group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 0) %>%
    dplyr::slice_max(avg_log2FC, n = nGenes) %>%
    dplyr::slice_min(p_val_adj, n = nGenes) %>%
    dplyr::mutate(fc_order = order(avg_log2FC))

  topMarkers <- topMarkersLong %>%
    pivot_wider(id_cols = "fc_order",
      names_from = "cluster",
      values_from = "gene") %>%
    dplyr::select(-one_of("fc_order"))

  # Save the top cluster defining genes
  write.csv(
    topMarkers,
    file.path(dataOutputDir, paste0("top", nGenesString, "_genes_per_cluster_Treg", nClustString, ".csv")),
    quote = FALSE,
    row.names = TRUE
  )

  # =================Reference map the non-downsampled cells onto seuratTreg=============
  # Create a fresh copy of seuratQCMergedCleaned for this iteration to avoid conflicts
  seuratQCMergedCleaned_iter <- seuratQCMergedCleaned

  # Remove any existing ref.umap and ref.umap_Treg reductions to avoid conflicts
  if ("ref.umap" %in% names(seuratQCMergedCleaned_iter@reductions)) {
    seuratQCMergedCleaned_iter@reductions[["ref.umap"]] <- NULL
  }
  if ("ref.umap_Treg" %in% names(seuratQCMergedCleaned_iter@reductions)) {
    seuratQCMergedCleaned_iter@reductions[["ref.umap_Treg"]] <- NULL
  }

  # Normalize data
  seuratQCMergedCleaned_iter <- NormalizeData(seuratQCMergedCleaned_iter,
    verbose = FALSE,
    normalization.method = "LogNormalize",
    margin = 2,
    assay = "RNA")
  seuratTreg <- NormalizeData(seuratTreg,
    verbose = FALSE,
    normalization.method = "LogNormalize",
    margin = 2,
    assay = "RNA")

  # Find variable features
  seuratQCMergedCleaned_iter <- FindVariableFeatures(seuratQCMergedCleaned_iter,
    selection.method = "vst", nfeatures = 2000, verbose = FALSE)
  seuratTreg <- FindVariableFeatures(seuratTreg,
    selection.method = "vst", nfeatures = 2000, verbose = FALSE)

  # Find shared features
  featuresShared <- intersect(VariableFeatures(seuratQCMergedCleaned_iter), VariableFeatures(seuratTreg))

  # Find transfer anchors
  anchors <- FindTransferAnchors(reference = seuratTreg, query = seuratQCMergedCleaned_iter,
    features = featuresShared, reference.reduction = "pca")

  # Transfer cluster labels with unique column name for this iteration
  col_name <- paste0("seurat_clusters_Treg_iter", current_iter)
  predictions <- TransferData(anchorset = anchors, refdata = seuratTreg$seurat_clusters, dims = 1:30)
  colnames(predictions)[1] <- col_name

  # Add predictions to BOTH objects
  seuratQCMergedCleaned <- AddMetaData(seuratQCMergedCleaned, metadata = predictions[, col_name], col.name = col_name)
  seuratQCMergedCleaned_iter <- AddMetaData(seuratQCMergedCleaned_iter, metadata = predictions[, col_name], col.name = col_name)

  # Project UMAP with explicit reduction name for this iteration
  seuratQCMergedCleaned_iter <- MapQuery(
    anchorset = anchors,
    reference = seuratTreg,
    query = seuratQCMergedCleaned_iter,
    reference.reduction = "pca",
    reduction.model = "umap"
  )

  # After mapping, rename the resulting reduction to keep iterations distinct
  reduction_name <- paste0("ref.umap_Treg_iter", current_iter)
  seuratQCMergedCleaned_iter@reductions[["ref.umap"]]@key <- paste0("refumap", current_iter, "_")
  seuratQCMergedCleaned_iter@reductions[[reduction_name]] <- seuratQCMergedCleaned_iter@reductions[["ref.umap"]]

  # ================Make a dotplot from the top 10 cluster-defining genes================
  # Subset down to Treg cells only for visualization
  seurat.tmp <- subset(seuratQCMergedCleaned_iter, cellType == "Treg")

  fontSize <- 8

  # Extract the gene names from topMarkersPlot (top 10 per cluster)
  genes.tmp <- unique(unlist(topMarkersPlot))

  # Create a DotPlot using the current iteration's predictions
  dotPlot.tmp <- DotPlot(seurat.tmp, dot.scale = 3.75, features = genes.tmp, group.by = col_name) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Treg Clusters", x = "Cluster-defining genes") +
    guides(color = guide_colorbar(title = "Average\nExpression\nz-score"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Save the dotplot
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_top", nGenesStringPlot, "ClusterDefiningGenesDotPlotTregs"),
    height = 4,
    width = 7,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # make a DotPlot with the 'curated' gene list
  dotPlot.tmp <- DotPlot(seurat.tmp, dot.scale = 3.75, features = geneListTregCurated, group.by = col_name) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
      text = element_text(size = fontSize),
      axis.text.y = element_text(size = fontSize),
      axis.title.y = element_text(size = fontSize),
      legend.text = element_text(size = fontSize),
      legend.title = element_text(size = fontSize),
      strip.text = element_text(size = fontSize),
      plot.title = element_text(size = fontSize)) +
    labs(y = "Treg Clusters", x = "Curated genes (Treg)") +
    guides(color = guide_colorbar(title = "Average\nExpression\nz-score"),
      size = guide_legend(title = "Percent\nExpressed")) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red")

  # Save the dotplot
  savePlot(
    plot = dotPlot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "curatedGenesDotPlotTregs"),
    height = 4,
    width = 7,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make UMAP colored by clusters================
  seurat.tmp.umap <- seuratTreg
  print(seurat.tmp.umap@reductions)
  print(table(seurat.tmp.umap@meta.data$seurat_clusters))
  print(table(seurat.tmp.umap@meta.data$seurat_clusters_Treg))

  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "seurat_clusters",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palRNAClustersTreg) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TregOnly"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make UMAP colored by stimulation================
  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "stimulationFigures",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palStimulation) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TregOnly_stimulation"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )
  # ================Make UMAP colored by CellTypistL1================
  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "cellTypistCalling",
    shuffle = TRUE,
    pt.size = 1) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TregOnly_cellTypistL1"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make UMAP colored by CellTypistL3================
  set.seed(314)
  plot.tmp <- DimPlot(object = seurat.tmp.umap,
    reduction = "umap",
    group = "cellTypistCallingL3",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palCellTypistL3) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = plot.tmp,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RNA_TregOnly_cellTypistL3"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # ================Make reference-mapped UMAPs (showing only Treg cells)================
  # Create a subset with only Treg cells
  seurat.ref.map <- subset(seuratQCMergedCleaned_iter, cellType == "Treg")

  # Get the specific reduction name for this iteration
  ref_map_reduction <- paste0("ref.umap_Treg_iter", current_iter)

  # 1. UMAP colored by transferred clusters
  set.seed(314)
  ref_map_cluster_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = col_name,
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palRNAClustersTreg) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster",
      title = "Reference-mapped Treg cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_cluster_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TregOnly_clusters"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # 2. UMAP colored by stimulation
  set.seed(314)
  ref_map_stim_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = "stimulationFigures",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palStimulation) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Stimulation",
      title = "Reference-mapped Treg cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_stim_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TregOnly_stimulation"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # 3. UMAP colored by CellTypistL1
  set.seed(314)
  ref_map_cluster_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = "cellTypistCalling",
    shuffle = TRUE,
    pt.size = 1) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster",
      title = "Reference-mapped Treg cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_cluster_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TregOnly_cellTypistL1"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # 4. UMAP colored by CellTypistL3
  set.seed(314)
  ref_map_cluster_plot <- DimPlot(object = seurat.ref.map,
    reduction = ref_map_reduction,
    group.by = "cellTypistCallingL3",
    shuffle = TRUE,
    pt.size = 1) +
    scale_color_manual(values = palCellTypistL3) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster",
      title = "Reference-mapped Treg cells") +
    theme(aspect.ratio = 1)

  savePlot(
    plot = ref_map_cluster_plot,
    plotDir = plotDir,
    filename = paste0(nClustString, "_UMAP_RefMapped_TregOnly_cellTypistL3"),
    height = 6,
    width = 10,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
  )

  # Clean up temporary variables - SAFELY check if they exist first
  to_remove <- c()
  if (exists("seuratQCMergedCleaned_iter")) to_remove <- c(to_remove, "seuratQCMergedCleaned_iter")
  if (exists("anchors")) to_remove <- c(to_remove, "anchors")
  if (exists("predictions")) to_remove <- c(to_remove, "predictions")
  if (exists("seurat.tmp")) to_remove <- c(to_remove, "seurat.tmp")
  if (exists("seurat.tmp.umap")) to_remove <- c(to_remove, "seurat.tmp.umap")
  if (exists("dotPlot.tmp")) to_remove <- c(to_remove, "dotPlot.tmp")
  if (exists("plot.tmp")) to_remove <- c(to_remove, "plot.tmp")
  if (exists("ref_map_cluster_plot")) to_remove <- c(to_remove, "ref_map_cluster_plot")
  if (exists("ref_map_stim_plot")) to_remove <- c(to_remove, "ref_map_stim_plot")
  if (exists("seurat.ref.map")) to_remove <- c(to_remove, "seurat.ref.map")

  if (length(to_remove) > 0) {
    rm(list = to_remove)
  }

  # Force garbage collection
  gc()

  # Keep the loop counter (i) intact!
  cat(sprintf("Completed hyperparameter set %d/%d with %d clusters\n",
    i, nrow(optHyperParamGrid.df), num_clusters))
}

# Final message
cat("Processing complete!\n")
```

```{r cellCounts}
# numbers of cells per donorIdFigures by $cellType, $stimulationFigures, and $seurat_clusters_DS

# Extract metadata
metadata <- seuratQCMergedCleaned@meta.data

# replace "Other" in $cellType with "Not Ag-specific"
metadata$cellType <- ifelse(metadata$cellType == "Other", "Not Ag-specific", metadata$cellType)

# Create comprehensive cell count table
cell_counts <- metadata %>%
  group_by(donorIdFigures, cellType, stimulationFigures, seurat_clusters_DS) %>%
  summarise(cell_count = n(), .groups = "drop") %>%
  arrange(donorIdFigures, cellType, stimulationFigures, seurat_clusters_DS)

# Create a summary table with totals
summary_counts <- list(
  # Detailed breakdown
  "Detailed_Counts" = cell_counts,

  # Total cells per donor by cell type and stimulation
  "Donor_CellType_Stim" = metadata %>%
    group_by(donorIdFigures, cellType, stimulationFigures) %>%
    summarise(cell_count = n(), .groups = "drop") %>%
    arrange(donorIdFigures, cellType, stimulationFigures),

  # Total cells per donor by cell type
  "Donor_CellType" = metadata %>%
    group_by(donorIdFigures, cellType) %>%
    summarise(cell_count = n(), .groups = "drop") %>%
    arrange(donorIdFigures, cellType),

  # Total cells per donor by stimulation
  "Donor_Stimulation" = metadata %>%
    group_by(donorIdFigures, stimulationFigures) %>%
    summarise(cell_count = n(), .groups = "drop") %>%
    arrange(donorIdFigures, stimulationFigures),

  # Total cells per donor by cluster
  "Donor_Cluster" = metadata %>%
    group_by(donorIdFigures, seurat_clusters_DS) %>%
    summarise(cell_count = n(), .groups = "drop") %>%
    arrange(donorIdFigures, seurat_clusters_DS),

  # Overall totals per donor
  "Donor_Totals" = metadata %>%
    group_by(donorIdFigures) %>%
    summarise(total_cells = n(), .groups = "drop") %>%
    arrange(donorIdFigures)
)

# Create filename with timestamp
filename <- file.path(dataOutputDir, paste0(filenameSuffix, "CellCounts_Breakdown.xlsx"))

# Write to Excel with multiple sheets
write.xlsx(summary_counts, file = filename, rowNames = FALSE)

# Print summary to console
cat("Cell count summary saved to:", filename, "\n\n")
cat("Total cells in dataset:", nrow(metadata), "\n")
cat("Number of donors:", length(unique(metadata$donorIdFigures)), "\n")
cat("Cell types:", paste(unique(metadata$cellType), collapse = ", "), "\n")
cat("Stimulations:", paste(unique(metadata$stimulationFigures), collapse = ", "), "\n")
cat("Number of clusters:", length(unique(metadata$seurat_clusters_DS)), "\n\n")

# Print sample of detailed counts
cat("Sample of detailed cell counts:\n")
print(head(cell_counts, 10))

# Print totals by cell type and stimulation
cat("\nTotals by cell type and stimulation:\n")
totals_summary <- metadata %>%
  group_by(cellType, stimulationFigures) %>%
  summarise(total_cells = n(), .groups = "drop") %>%
  arrange(cellType, stimulationFigures)
print(totals_summary)


# Create a second Excel file with transposed layout (donors as columns, categories as rows)

# 1. Cell type breakdown by donor
celltype_by_donor <- metadata %>%
  group_by(donorIdFigures, cellType) %>%
  summarise(cell_count = n(), .groups = "drop") %>%
  pivot_wider(names_from = donorIdFigures, values_from = cell_count, values_fill = 0)

# 2. Stimulation breakdown by donor
stimulation_by_donor <- metadata %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(cell_count = n(), .groups = "drop") %>%
  pivot_wider(names_from = donorIdFigures, values_from = cell_count, values_fill = 0)

# 3. Cluster breakdown by donor
cluster_by_donor <- metadata %>%
  group_by(donorIdFigures, seurat_clusters_DS) %>%
  summarise(cell_count = n(), .groups = "drop") %>%
  pivot_wider(names_from = donorIdFigures, values_from = cell_count, values_fill = 0) %>%
  rename(category = seurat_clusters_DS) %>%
  mutate(category = paste("Cluster", category))

# 4. Total cells per donor
total_by_donor <- metadata %>%
  group_by(donorIdFigures) %>%
  summarise(total_cells = n(), .groups = "drop") %>%
  pivot_wider(names_from = donorIdFigures, values_from = total_cells) %>%
  mutate(cellType = "Total") %>%
  select(cellType, everything())

# Rename columns to match
colnames(celltype_by_donor)[1] <- "category"
colnames(stimulation_by_donor)[1] <- "category"
colnames(total_by_donor)[1] <- "category"

# Combine all tables into one
final_table <- bind_rows(
  celltype_by_donor,
  stimulation_by_donor,
  cluster_by_donor,
  total_by_donor
)

# Create filename for single sheet version
filename_single <- file.path(dataOutputDir, paste0(filenameSuffix, "CellCountsCombined.xlsx"))

# Write to Excel as a single sheet
write.xlsx(final_table, file = filename_single, rowNames = FALSE)

# Print summary
cat("\nSingle table cell count summary saved to:", filename_single, "\n")
cat("Layout: Single sheet with donors as columns, categories as separate row groups\n")
cat("Total rows:", nrow(final_table), "\n")
```

```{r GSEAIARVsCEFX_geneRatioHorizontalAxis}
# Get hallmark, C2, and C5 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)

c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)

c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)

c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Produce a dotplot for the top enriched pathways (up to 15 categories)
      dp <- dotplot(gsea_obj, showCategory = 15) +
        ggtitle(paste(comp, "(", direction, " - ", cat, ")"))

      # Save the dotplot as a PDF
      pdf_filename <- file.path(plotDir, paste0(comp, "_GSEA_dotplot_", direction, "_", cat, ".pdf"))
      pdf(file = pdf_filename, width = 9, height = 9)
      print(dp)
      dev.off()
    }
  }
}
```

```{r GSEAIARVsCEFXDirectionSplit_enrichmentScoreHorizontalAxis}
fontSize <- 12

# Get hallmark, C2, and C5 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)

c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)

c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)

c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

# Mapping for gene set categories
category_titles <- c(
  "H" = "Hallmark",
  "C2" = "Curated",
  "C5" = "GO",
  "C7" = "Immunologic"
)

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Filter for modules with gene count > 10
      gsea_res_filt <- gsea_obj@result %>% dplyr::filter(setSize > 10)

      if (nrow(gsea_res_filt) == 0) {
        message("No enriched terms with gene count > 10 for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }


      # Dotplot: x-axis is NES (signed enrichment score), color by p.adjust (red=low, blue=high), size by gene count
      gsea_res_filt_top <- gsea_res_filt %>% head(15)
      pvals <- gsea_res_filt_top$p.adjust

      if (length(unique(pvals)) == 1) {
        # All p-values are the same, use a single color
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize), color = "red") +
          labs(title = paste0(comparison_titles[comp], " (", category_titles[cat], ", ", direction, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count",
            color = "Adj. p-value"
          ) +
          theme_minimal(base_size = fontSize)
      } else {
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize, color = p.adjust)) +
          scale_color_gradient(
            low = "red", high = "blue",
            name = "Adj. p-value",
            guide = guide_colorbar(reverse = TRUE)
          ) +
          labs(
            title = paste(comp, "(", direction, "-", cat, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count"
          ) +
          theme_minimal(base_size = fontSize)
      }

      # Save the dotplot
      savePlot(
        plot = dp.tmp,
        plotDir = plotDir,
        filename = paste0(comp, "_GSEA_dotplot_ES", direction, "_", cat),
        height = 9,
        width = 9,
        units = "in",
        dpi = 600,
        formats = c("pdf", "png")
      )

    }
  }
}

rm_tmp(ask = FALSE)
```

```{r GSEAIARVsCEFX_enrichmentScoreHorizontalAxis}
fontSize <- 12

# Get hallmark, C2, C5, and C7 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)
c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)
c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

# Mapping for gene set categories
category_titles <- c(
  "H" = "Hallmark",
  "C2" = "Curated",
  "C5" = "GO",
  "C7" = "Immunologic"
)

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Filter for modules with gene count > 10
      gsea_res_filt <- gsea_obj@result %>% dplyr::filter(setSize > 10)

      if (nrow(gsea_res_filt) == 0) {
        message("No enriched terms with gene count > 10 for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Dotplot: x-axis is NES (signed enrichment score), color by p.adjust (red=low, blue=high), size by gene count
      gsea_res_filt_top <- gsea_res_filt %>% head(15)
      pvals <- gsea_res_filt_top$p.adjust

      if (length(unique(pvals)) == 1) {
        # All p-values are the same, use a single color
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize), color = "red") +
          labs(title = paste0(comparison_titles[comp], " (", category_titles[cat], ", ", direction, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count",
            color = "Adj. p-value"
          ) +
          theme_minimal(base_size = fontSize)
      } else {
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize, color = p.adjust)) +
          scale_color_gradient(
            low = "red", high = "blue",
            name = "Adj. p-value",
            guide = guide_colorbar(reverse = TRUE)
          ) +
          labs(
            title = paste(comp, "(", direction, "-", cat, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count"
          ) +
          theme_minimal(base_size = fontSize)
      }

      # Save the dotplot
      savePlot(
        plot = dp.tmp,
        plotDir = plotDir,
        filename = paste0(comp, "_GSEA_dotplot_ES", direction, "_", cat),
        height = 9,
        width = 9,
        units = "in",
        dpi = 600,
        formats = c("pdf", "png")
      )

    }
  }
}

rm_tmp(ask = FALSE)
```

```{r GSEAHorizontalAxis}
fontSize <- 12

# Get hallmark, C2, C5, and C7 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)
c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)
c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

categories <- c("H", "C2", "C5", "C7")

comparisons <- list(
  "results_Treg_IARVMicrobial" = results_Treg_IARVMicrobial,
  "results_Tconv_IARVMicrobial" = results_Tconv_IARVMicrobial
)

comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

category_titles <- c(
  "H" = "Hallmark",
  "C2" = "Curated",
  "C5" = "GO",
  "C7" = "Immunologic"
)

gsea_results <- list()

for (comp in names(comparisons)) {
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  geneList <- df_sig$logFC
  names(geneList) <- df_sig$gene
  geneList <- sort(geneList, decreasing = TRUE)

  gsea_results[[comp]] <- list()

  for (cat in categories) {
    term2gene <- switch(cat,
      "H" = hs_sets,
      "C2" = c2_sets,
      "C5" = c5_sets,
      "C7" = c7_sets
    )

    # DEBUG: Print gene list info
    cat("DEBUG - comp:", comp, "cat:", cat, "\n")
    cat("DEBUG - geneList length:", length(geneList), "\n")
    cat("DEBUG - geneList range:", range(geneList), "\n")
    cat("DEBUG - term2gene nrow:", nrow(term2gene), "\n")

    gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
      minGSSize = 10, maxGSSize = 1000,
      pvalueCutoff = 0.05)

    # DEBUG: Print GSEA results info
    cat("DEBUG - gsea_obj@result nrow:", nrow(gsea_obj@result), "\n")
    if (nrow(gsea_obj@result) > 0) {
      cat("DEBUG - p.adjust range:", range(gsea_obj@result$p.adjust), "\n")
    }

    gsea_results[[comp]][[cat]] <- gsea_obj

    if (nrow(gsea_obj@result) == 0) {
      message("No enriched terms for ", comp, " with category ", cat, ", skipping dotplot.")
      next
    }

    gsea_res_filt <- gsea_obj@result %>% dplyr::filter(setSize > 10)

    if (nrow(gsea_res_filt) == 0) {
      message("No enriched terms with gene count > 10 for ", comp, " with category ", cat, ", skipping dotplot.")
      next
    }

    gsea_res_filt_top <- gsea_res_filt %>% head(15)
    pvals <- gsea_res_filt_top$p.adjust
    print(comp)
    print(cat)
    print(length(pvals))

    dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
      geom_point(aes(size = setSize, color = p.adjust)) +
      scale_color_gradient(
        low = "red", high = "blue",
        name = "Adj. p-value",
        guide = guide_colorbar(reverse = TRUE)
      ) +
      labs(
        title = paste0(comparison_titles[comp], " (", category_titles[cat], ")"),
        x = "Normalized Enrichment Score (NES)",
        y = "Gene Set",
        size = "Gene Count"
      ) +
      theme_minimal(base_size = fontSize)

    savePlot(
      plot = dp.tmp,
      plotDir = plotDir,
      filename = paste0(comp, "_GSEA_dotplot_", cat),
      height = 9,
      width = 9,
      units = "in",
      dpi = 600,
      formats = c("pdf", "png")
    )
  }
}
```

```{r Figure2CNareshStyleEnrichmentPlotHallmark}
comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

create_hallmark_gsea_comparison <- function(comparisons) {
  # Get Hallmark gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  # 1. SINGLE COMPREHENSIVE GSEA RUN: Get all pathways with correct multiple-testing adjustment

  # Get gene lists for each cell type
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA ONCE with p-value=1.0 to get ALL pathways with properly adjusted p-values
  treg_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  tconv_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  # 2. SELECT TERMS using the properly adjusted p-values from the comprehensive analysis

  # Find significantly enriched terms (p.adjust < 0.05) in each cell type
  treg_significant <- treg_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  tconv_significant <- tconv_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  # Print counts of significant terms for debugging
  cat("Significant HALLMARK pathways in Treg:", nrow(treg_significant), "\n")
  cat("Significant HALLMARK pathways in Tconv:", nrow(tconv_significant), "\n")

  # Get top 3 from Treg (or all if fewer)
  treg_top <- treg_significant %>%
    dplyr::slice(1:min(10, nrow(.)))

  # Get top 7 from Tconv that don't overlap with Treg
  tconv_nonoverlap <- tconv_significant %>%
    dplyr::filter(!(ID %in% treg_top$ID)) %>%
    dplyr::slice(1:min(10, nrow(.)))

  # List of terms to display
  display_terms <- c(treg_top$ID, tconv_nonoverlap$ID)

  # Print for debugging
  cat("Selected", length(treg_top$ID), "terms from Treg and",
    length(tconv_nonoverlap$ID), "terms from Tconv\n")

  # 3. PREPARE DATA: Extract selected terms from each cell type's results

  # Get results for these terms from Treg data
  treg_results <- treg_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Treg",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% treg_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% treg_top$ID)

  # Get results for these terms from Tconv data
  tconv_results <- tconv_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Tconv",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% tconv_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% tconv_nonoverlap$ID)

  # Handle any missing terms by adding with placeholder values
  missing_in_treg <- setdiff(display_terms, treg_results$ID)
  missing_in_tconv <- setdiff(display_terms, tconv_results$ID)

  if (length(missing_in_treg) > 0) {
    for (term in missing_in_treg) {
      term_desc <- tconv_results$Description[tconv_results$ID == term]
      if (length(term_desc) > 0) {
        treg_results <- rbind(treg_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Treg",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  if (length(missing_in_tconv) > 0) {
    for (term in missing_in_tconv) {
      term_desc <- treg_results$Description[treg_results$ID == term]
      if (length(term_desc) > 0) {
        tconv_results <- rbind(tconv_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Tconv",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  # 4. COMBINE AND FORMAT: Merge results for plotting

  # Combine the results
  combined_results <- rbind(treg_results, tconv_results)

  # Clean up pathway names
  combined_results$Description <- gsub("HALLMARK_", "", combined_results$Description)

  # Sort pathways by average NES magnitude
  description_order <- combined_results %>%
    dplyr::group_by(Description) %>%
    dplyr::summarize(mean_abs_NES = mean(abs(NES), na.rm = TRUE)) %>%
    dplyr::arrange(desc(mean_abs_NES)) %>%
    dplyr::pull(Description)

  combined_results$Description <- factor(combined_results$Description,
    levels = description_order)

  # 5. CREATE PLOT: Using selected top terms for coloring
  p <- ggplot(combined_results, aes(x = NES, y = Description)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description, yend = Description, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      # Size based on -log10(p.adjust)
      size = -log10(p.adjust),
      # Only color the originally selected top terms as significant
      fill = ifelse(is_selected_top, "Significant", "Not Significant")
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~CellType, nrow = 1) +
    scale_fill_manual(
      values = c("Significant" = "red", "Not Significant" = "lightblue"),
      name = "Significance"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Hallmark Gene Sets: IAR vs Microbial"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white"),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 14),
      axis.text.x = element_text(size = 14),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank()
    )

  # Return the plot and data
  return(list(plot = p, data = combined_results))
}

# Run the function and save the plot
result <- create_hallmark_gsea_comparison(comparisons)

# Save the plot
savePlot(
  plot = result$plot,
  plotDir = plotDir,
  filename = "Hallmark_GSEA_Comparison_TregTconv",
  height = 8,
  width = 12,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)

# Save the data for reference
# write.csv(result$data, file = file.path(dataOutputDir, "Hallmark_GSEA_Comparison_Data.csv"),
#           row.names = FALSE)
```

```{r Figure2DNareshStyleEnrichmentPlotGO}
comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

create_GO_gsea_comparison <- function(comparisons) {
  # Get Hallmark gene sets
  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # 1. SINGLE COMPREHENSIVE GSEA RUN: Get all pathways with correct multiple-testing adjustment

  # Get gene lists for each cell type
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.05)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.05)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA ONCE with p-value=1.0 to get ALL pathways with properly adjusted p-values
  treg_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  tconv_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  # 2. SELECT TERMS using the properly adjusted p-values from the comprehensive analysis

  # Find significantly enriched terms (p.adjust < 0.05) in each cell type
  treg_significant <- treg_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  tconv_significant <- tconv_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  # Print counts of significant terms for debugging
  cat("Significant HALLMARK pathways in Treg:", nrow(treg_significant), "\n")
  cat("Significant HALLMARK pathways in Tconv:", nrow(tconv_significant), "\n")

  # Get top 8 from Treg (or all if fewer)
  treg_top <- treg_significant %>%
    dplyr::slice(1:min(8, nrow(.)))

  # Get top 8 from Tconv that don't overlap with Treg
  tconv_nonoverlap <- tconv_significant %>%
    dplyr::filter(!(ID %in% treg_top$ID)) %>%
    dplyr::slice(1:min(8, nrow(.)))

  # List of terms to display
  display_terms <- c(treg_top$ID, tconv_nonoverlap$ID)

  # Print for debugging
  cat("Selected", length(treg_top$ID), "terms from Treg and",
    length(tconv_nonoverlap$ID), "terms from Tconv\n")

  # 3. PREPARE DATA: Extract selected terms from each cell type's results

  # Get results for these terms from Treg data
  treg_results <- treg_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Treg",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% treg_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% treg_top$ID)

  # Get results for these terms from Tconv data
  tconv_results <- tconv_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Tconv",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% tconv_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% tconv_nonoverlap$ID)

  # Handle any missing terms by adding with placeholder values
  missing_in_treg <- setdiff(display_terms, treg_results$ID)
  missing_in_tconv <- setdiff(display_terms, tconv_results$ID)

  if (length(missing_in_treg) > 0) {
    for (term in missing_in_treg) {
      term_desc <- tconv_results$Description[tconv_results$ID == term]
      if (length(term_desc) > 0) {
        treg_results <- rbind(treg_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Treg",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  if (length(missing_in_tconv) > 0) {
    for (term in missing_in_tconv) {
      term_desc <- treg_results$Description[treg_results$ID == term]
      if (length(term_desc) > 0) {
        tconv_results <- rbind(tconv_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Tconv",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  # 4. COMBINE AND FORMAT: Merge results for plotting

  # Combine the results
  combined_results <- rbind(treg_results, tconv_results)

  # Clean up pathway names
  combined_results$Description <- gsub("GOCC_", "", combined_results$Description)
  combined_results$Description <- gsub("GOBP_", "", combined_results$Description)
  combined_results$Description <- gsub("GOMF_", "", combined_results$Description)

  # Sort pathways by average NES magnitude
  description_order <- combined_results %>%
    dplyr::group_by(Description) %>%
    dplyr::summarize(mean_abs_NES = mean(abs(NES), na.rm = TRUE)) %>%
    dplyr::arrange(desc(mean_abs_NES)) %>%
    dplyr::pull(Description)

  combined_results$Description <- factor(combined_results$Description,
    levels = description_order)

  # 5. CREATE PLOT: Using selected top terms for coloring
  p <- ggplot(combined_results, aes(x = NES, y = Description)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description, yend = Description, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      # Size based on -log10(p.adjust)
      size = -log10(p.adjust),
      # Only color the originally selected top terms as significant
      fill = ifelse(is_selected_top, "Significant", "Not Significant")
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~CellType, nrow = 1) +
    scale_fill_manual(
      values = c("Significant" = "red", "Not Significant" = "lightblue"),
      name = "Significance"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "GO Gene Sets: IAR vs Microbial"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white"),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 14),
      axis.text.x = element_text(size = 14),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank()
    )

  # Return the plot and data
  return(list(plot = p, data = combined_results))
}

# Run the function and save the plot
result <- create_GO_gsea_comparison(comparisons)

# Save the plot
savePlot(
  plot = result$plot,
  plotDir = plotDir,
  filename = "Hallmark_GO_Comparison_TregTconv",
  height = 8,
  width = 12,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)

# Save the data for reference
# write.csv(result$data, file = file.path(dataOutputDir, "GO_GSEA_Comparison_Data.csv"),
#           row.names = FALSE)
```

```{r Figure2ECombinedTregHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
# comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Treg figure with Hallmark on left and GO on right
create_combined_treg_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Treg gene list
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  treg_hallmark_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  treg_go_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  # Export GSEA results to Excel
  gsea_data_list <- list(
    "Treg_Hallmark" = treg_hallmark_gsea@result,
    "Treg_GO" = treg_go_gsea@result
  )

  output_filename <- file.path(dataOutputDir, paste0(filenameSuffix, "GSEA_results_Treg_IARVMicrobial.xlsx"))
  write.xlsx(gsea_data_list, file = output_filename, overwrite = TRUE)
  cat("GSEA results exported to:", output_filename, "\n")

  # Select significant terms
  hallmark_significant <- treg_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- treg_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Print debugging info
  cat("Treg Hallmark significant terms (p.adjust < 0.05):", nrow(hallmark_significant), "\n")
  cat("Treg GO significant terms (p.adjust < 0.05):", nrow(go_significant), "\n")

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Treg. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Treg: No Significant Terms (IAR vs Microbial)")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~GeneSet, scales = "free_y", nrow = 1) +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Treg: Hallmark and GO Gene Sets (IAR vs Microbial)"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    ) +
    ggh4x::facetted_pos_scales(
      y = list(
        scale_y_discrete(position = "left"),   # GO on left
        scale_y_discrete(position = "right")   # Hallmark on right
      )
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
treg_result <- create_combined_treg_gsea(comparisons)

# Save the plot
savePlot(
  plot = treg_result$plot,
  plotDir = plotDir,
  filename = "Combined_Treg_Hallmark_GO_GSEA",
  height = 8,
  width = 18,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```

```{r Figure2FCombinedTconvHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
# comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Tconv figure with Hallmark on left and GO on right
create_combined_tconv_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Tconv gene list
  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  tconv_hallmark_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  tconv_go_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  # Export GSEA results to Excel
  gsea_data_list <- list(
    "Tconv_Hallmark" = tconv_hallmark_gsea@result,
    "Tconv_GO" = tconv_go_gsea@result
  )

  output_filename <- file.path(dataOutputDir, paste0(filenameSuffix, "GSEA_results_Tconv_IARVMicrobial.xlsx"))
  write.xlsx(gsea_data_list, file = output_filename, overwrite = TRUE)
  cat("GSEA results exported to:", output_filename, "\n")

  # Select significant terms
  hallmark_significant <- tconv_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- tconv_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Print debugging info
  cat("Tconv Hallmark significant terms (p.adjust < 0.05):", nrow(hallmark_significant), "\n")
  cat("Tconv GO significant terms (p.adjust < 0.05):", nrow(go_significant), "\n")

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Tconv. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Tconv: No Significant Terms (IAR vs Microbial)")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~GeneSet, scales = "free_y", nrow = 1) +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Tconv: Hallmark and GO Gene Sets (IAR vs Microbial)"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    ) +
    ggh4x::facetted_pos_scales(
      y = list(
        scale_y_discrete(position = "left"),   # GO on left
        scale_y_discrete(position = "right")   # Hallmark on right
      )
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
tconv_result <- create_combined_tconv_gsea(comparisons)

# Save the plot
savePlot(
  plot = tconv_result$plot,
  plotDir = plotDir,
  filename = "Combined_Tconv_Hallmark_GO_GSEA",
  height = 8,
  width = 18,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```

```{r Figure2EStackedTregHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial

# Combined Treg figure with Hallmark on top and GO on bottom (stacked)
create_stacked_treg_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Treg gene list
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  treg_hallmark_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  treg_go_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  # Select significant terms
  hallmark_significant <- treg_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- treg_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Treg. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Treg: No Significant Terms (IAR vs Microbial) - Stacked")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot with proportional panel heights using facet_grid
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_grid(GeneSet ~ ., scales = "free_y", space = "free_y") +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Treg: Hallmark and GO Gene Sets (IAR vs Microbial) - Stacked"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
treg_stacked_result <- create_stacked_treg_gsea(comparisons)

# Save the plot
savePlot(
  plot = treg_stacked_result$plot,
  plotDir = plotDir,
  filename = "Stacked_Treg_Hallmark_GO_GSEA",
  height = 14,
  width = 16,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```


## Stacked Tconv Plot
```{r Figure2FStackedTconvHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Tconv figure with Hallmark on top and GO on bottom (stacked)
create_stacked_tconv_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Tconv gene list
  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  tconv_hallmark_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  tconv_go_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  # Select significant terms
  hallmark_significant <- tconv_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- tconv_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Tconv. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Tconv: No Significant Terms (IAR vs Microbial) - Stacked")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot with proportional panel heights using facet_grid
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_grid(GeneSet ~ ., scales = "free_y", space = "free_y") +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Tconv: Hallmark and GO Gene Sets (IAR vs Microbial) - Stacked"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
tconv_stacked_result <- create_stacked_tconv_gsea(comparisons)

# Save the plot
savePlot(
  plot = tconv_stacked_result$plot,
  plotDir = plotDir,
  filename = "Stacked_Tconv_Hallmark_GO_GSEA",
  height = 14,
  width = 16,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```