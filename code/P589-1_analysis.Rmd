---
title: "MAS and control monocytes and lymphocytes, 10X study"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
setwd("/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X")

library(knitr)
library(dplyr)
library(tibble)
library(ggplot2)
library(GGally)
theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, size = 1),
      axis.text = element_text(colour = "black"),
      axis.ticks = element_line(colour = "black"),
      legend.key = element_blank(),
      strip.text.x = element_text(size = 14, margin = margin(b = 2, t = 2)),
      strip.background = element_rect(fill = "white", colour = "black")))

library(ggthemes)
library(ggforce)
library(ggbeeswarm)
library(ggvenn)
library(viridis)
library(stringr)
library(readxl)
library(kableExtra)
library(RColorBrewer)
library(plotly)
library(tidyr)
library(gtools)
library(data.table)
library(miscHelpers)
# library(edgeR)
library(ggrepel)
library(ComplexHeatmap)
library(egg) # For ggarrange
library(ggpubr) # Also for ggarrange
library(umap)
library(igraph)
library(forcats)
library(Seurat)
library(apird)
library(randomcoloR)
library(rcartocolor)
library(paletteer)
library(circlize)
library(gridExtra)
library(ggpointdensity)
library(cowplot)
library(clusterSim) # for cluster-evaluation metrics
library(foreach) # for parallel for-loops
library(TCRtools) # for making circos plots with Matt D's code
library(scDEED)
library(dsb)

opts_chunk$set(fig.width = 6, fig.height = 4.0, cache = TRUE, echo = FALSE, warning = FALSE, message = FALSE, cache.lazy = FALSE, results = "hide")
opts_knit$set(root.dir = "/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X")

options(stringsAsFactors = FALSE)

options(future.globals.maxSize = 1591289600)
```

```{r set_up_directories, cache = TRUE}

baseDir <- "/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X"
dataInputDir <- file.path(baseDir, "data/input")
plotDir <- file.path(baseDir, "figures")
dataOutputDir <- file.path(baseDir, "data/output")
dataDate <- "2024-12-09"
filenameSuffix <- paste0("P589-1_autoreactive_CD4_Tcell_10X.", dataDate)

P589_1Samples <- c("pool589-1_1",
  "pool589-1_2")
# /mnt/bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/
P589_1Files <- paste0("/Volumes/Bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/",
  P589_1Samples,
  "/outs/per_sample_outs/",
  P589_1Samples,
  "/count/sample_filtered_feature_bc_matrix.h5")

P589_1RawFiles <- paste0("/Volumes/Bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/",
  P589_1Samples,
  "/outs/multi/count/",
  "raw_feature_bc_matrix.h5")

poolOrder <- c("1", "2")
```

```{r read_P589_1}
gexAb <- Read10X_h5(P589_1Files[1])

processP589_1 <- function(sample) {
  print(sample) # debugging

  gexAb <- Read10X_h5(sample)

  # seuratSample <- CreateSeuratObject(counts = gexAb,
  #                                    min.features = 100,
  #                                    min.cells = 3)
  # note: removing min.features prevents the error: Error: No feature overlap between existing object and new layer data
  seuratSample <- CreateSeuratObject(counts = gexAb,
    min.cells = 3)

  # Clean memory
  #   remove(gexAb)

  seuratSample[["sample"]] <- str_extract(sample, "pool[1-9][1-9][1-9]-1_[1-9]")
  seuratSample[["percentMT"]] <- PercentageFeatureSet(seuratSample, pattern = "^MT-")

  return(seuratSample)

}

gexP589_1 <- lapply(P589_1Files, processP589_1)
```

```{r read_10x_gex_data_from_all_flowcells}
gexAbObjects <- lapply(P589_1Files, Read10X_h5)

gexObjects <- list(gexAbObjects[[1]]$`Gene Expression`,
  gexAbObjects[[2]]$`Gene Expression`)

abObjects <- list(gexAbObjects[[1]]$`Antibody Capture`,
  gexAbObjects[[2]]$`Antibody Capture`)

# # temp
pool1HT <- c("CerosalettiLab632811_CD3CD28",
  "CerosalettiLab448473_CD3CD28",
  "CerosalettiLab839987_CD3CD28",
  "CerosalettiLab632811_CEFX",
  "CerosalettiLab448473_CEFX",
  "CerosalettiLab839987_CEFX",
  "CerosalettiLab632811_Islet",
  "CerosalettiLab448473_Islet",
  "CerosalettiLab839987_Islet")

pool1HTVars <- c("CerosalettiLab632811-CD3CD28",
  "CerosalettiLab448473-CD3CD28",
  "CerosalettiLab839987-CD3CD28",
  "CerosalettiLab632811-CEFX",
  "CerosalettiLab448473-CEFX",
  "CerosalettiLab839987-CEFX",
  "CerosalettiLab632811-Islet",
  "CerosalettiLab448473-Islet",
  "CerosalettiLab839987-Islet")

pool2HT <- c("CerosalettiLab1464776_CD3CD28",
  "CerosalettiLab1059994_CD3CD28",
  "CerosalettiLab942655_CD3CD28",
  "CerosalettiLab1464776_CEFX",
  "CerosalettiLab1059994_CEFX",
  "CerosalettiLab942655_CEFX",
  "CerosalettiLab1464776_Islet",
  "CerosalettiLab1059994_Islet",
  "CerosalettiLab942655_Islet")

pool2HTVars <- c("CerosalettiLab1464776-CD3CD28",
  "CerosalettiLab1059994-CD3CD28",
  "CerosalettiLab942655-CD3CD28",
  "CerosalettiLab1464776-CEFX",
  "CerosalettiLab1059994-CEFX",
  "CerosalettiLab942655-CEFX",
  "CerosalettiLab1464776-Islet",
  "CerosalettiLab1059994-Islet",
  "CerosalettiLab942655-Islet")

# Make a list of Seurat gene expression count objects
# Set parameters to define cells
seuratObjects <- lapply(gexObjects,
  function(x) CreateSeuratObject(counts = x,
    min.features = 100,
    min.cells = 3))


# Read in raw samples individually (for BSD normalizationm)
rawGexAbObjects <- lapply(P589_1RawFiles, Read10X_h5)

rawGexObjects <- list(rawGexAbObjects[[1]]$`Gene Expression`,
  rawGexAbObjects[[2]]$`Gene Expression`)

rawAbObjects <- list(rawGexAbObjects[[1]]$`Antibody Capture`,
  rawGexAbObjects[[2]]$`Antibody Capture`)

# Make a list of Seurat gene expression count objects
# Set parameters to define cells
seuratRawObjects <- lapply(rawGexObjects,
  function(x) CreateSeuratObject(counts = x,
    min.features = 0,
    min.cells = 0))
```

```{r add_fb_data}
# Create a separate "FB" assay slot within the Seurat object
# This is preferable over adding the ab data as metadata because
# it allows for seurat's normalization routine to be run on it.

# Separate hastags into a HT object assay, separate surface antibody tags into an FB (feature barcode) object assay
for (i in 1:length(seuratObjects)) {
  seurat <- seuratObjects[[i]]

  ht <- abObjects[[i]]
  if (i == 1) {
    ht <- ht[c("CerosalettiLab632811_CD3CD28",
      "CerosalettiLab448473_CD3CD28",
      "CerosalettiLab839987_CD3CD28",
      "CerosalettiLab632811_CEFX",
      "CerosalettiLab448473_CEFX",
      "CerosalettiLab839987_CEFX",
      "CerosalettiLab632811_Islet",
      "CerosalettiLab448473_Islet",
      "CerosalettiLab839987_Islet"), ]

  } else if (i == 2) {
    ht <- ht[c("CerosalettiLab1464776_Islet",
      "CerosalettiLab1464776_CEFX",
      "CerosalettiLab1059994_Islet",
      "CerosalettiLab1059994_CEFX",
      "CerosalettiLab942655_Islet",
      "CerosalettiLab942655_CEFX",
      "CerosalettiLab1464776_CD3CD28",
      "CerosalettiLab1059994_CD3CD28",
      "CerosalettiLab942655_CD3CD28"), ]
  }
  fb <- abObjects[[i]]
  fb <- fb[c("anti-human CD154",
    "anti-human CD137",
    "anti-human CD69",
    "anti-human CD127",
    "anti-human CD25",
    "anti-human CD45RA",
    "anti-human CD45RO",
    "anti-human CCR7",
    "Mouse IgG1, _ isotype Ctrl"), ]

  keepCells <- colnames(seurat)

  ht <- ht[, keepCells]
  seurat[["HT"]] <- CreateAssayObject(ht)

  fb <- fb[, keepCells]
  seurat[["FB"]] <- CreateAssayObject(fb)

  seuratObjects[[i]] <- seurat

}

# now for the raw files
for (i in 1:length(seuratRawObjects)) {
  seurat <- seuratRawObjects[[i]]

  ht <- rawAbObjects[[i]]
  if (i == 1) {
    ht <- ht[c("CerosalettiLab632811_CD3CD28",
      "CerosalettiLab448473_CD3CD28",
      "CerosalettiLab839987_CD3CD28",
      "CerosalettiLab632811_CEFX",
      "CerosalettiLab448473_CEFX",
      "CerosalettiLab839987_CEFX",
      "CerosalettiLab632811_Islet",
      "CerosalettiLab448473_Islet",
      "CerosalettiLab839987_Islet"), ]

  } else if (i == 2) {
    ht <- ht[c("CerosalettiLab1464776_Islet",
      "CerosalettiLab1464776_CEFX",
      "CerosalettiLab1059994_Islet",
      "CerosalettiLab1059994_CEFX",
      "CerosalettiLab942655_Islet",
      "CerosalettiLab942655_CEFX",
      "CerosalettiLab1464776_CD3CD28",
      "CerosalettiLab1059994_CD3CD28",
      "CerosalettiLab942655_CD3CD28"), ]
  }
  fb <- rawAbObjects[[i]]
  fb <- fb[c("anti-human CD154",
    "anti-human CD137",
    "anti-human CD69",
    "anti-human CD127",
    "anti-human CD25",
    "anti-human CD45RA",
    "anti-human CD45RO",
    "anti-human CCR7",
    "Mouse IgG1, _ isotype Ctrl"), ]

  keepCells <- colnames(seurat)

  ht <- ht[, keepCells]
  seurat[["HT"]] <- CreateAssayObject(ht)

  fb <- fb[, keepCells]
  seurat[["FB"]] <- CreateAssayObject(fb)

  seuratRawObjects[[i]] <- seurat
}
```

```{r loadTCRData}
# load the data
TCRsPool1.df <-
  read.csv(file.path(dataInputDir, "filtered_contig_annotations_pool1.csv")) %>%
  data.frame() %>%
  dplyr::mutate(barcode = paste0("1_", barcode))

TCRsPool2.df <-
  read.csv(file.path(dataInputDir, "filtered_contig_annotations_pool2.csv")) %>%
  data.frame() %>%
  dplyr::mutate(barcode = paste0("2_", barcode))

# merge the two pools
TCRs.df <- rbind(TCRsPool1.df, TCRsPool2.df)
```

```{r callMultipletsFunctionDefinition}
# Remove cells with: a) 3+ betas or alphas and, b) cells with 2 alphas and 2 betas
# Remove iNKT and MAIT cells
callMultiplets <- function(tcrs,
                           nAlphaCut = 3,
                           nBetaCut = 3,
                           alphaAndBetaCut = 2,
                           callINKT = TRUE,
                           callMAIT = TRUE) {
  # Count chains
  chainCounts <- tcrs %>%
    dplyr::group_by(barcode) %>%
    dplyr::summarise(nAlpha = sum(chain ==  "TRA"),
      nBeta = sum(chain == "TRB"))

  multiplets <- chainCounts %>%
    dplyr::filter(nAlpha > nAlphaCut |
      nBeta > nBetaCut |
      (nAlpha >= alphaAndBetaCut & nBeta >= alphaAndBetaCut))

  tcrs$multiplet <- tcrs$barcode %in% multiplets$barcode

  if (callMAIT == TRUE) {
    tcrs <- tcrs %>%
      dplyr::mutate(isMAIT = (str_detect(v_gene, "TRAV1-2") &
        str_detect(j_gene, "TRAJ(33|12|20)")))
  }

  if (callINKT == TRUE) {
    tcrs <- tcrs %>%
      dplyr::mutate(isINKT = (str_detect(v_gene, "TRAV10") &
        str_detect(j_gene, "TRAJ18")))
  }
  return(tcrs)
}
```

```{r define_callClonesFunction}
# From a list of TCRs, call clones
callClones <- function(tcrs,
                       cloneOption = "",
                       cloneColumnName = "CloneID") {

  possibleCloneOptions <- c("CDR3",
    "VJandCDR3",
    "CDR3nt")

  if (is.null(cloneOption) || length(cloneOption) != 1L || !cloneOption %in% possibleCloneOptions) {
    stop("'cloneOption' argument must be one of: 'CDR3','VJandCDR3', 'CDR3nt'")
  }

  if (cloneOption == "CDR3") {
    tcrs$cloneKey <- tcrs$cdr3
  }

  if (cloneOption == "VJandCDR3") {
    tcrs$cloneKey <- paste(tcrs$v_gene, tcrs$cdr3, tcrs$j_gene, sep = "_")
  }

  if (cloneOption == "CDR3nt") {
    tcrs$cloneKey <- tcrs$cdr3_nt
  }

  cloneLookup <- tcrs %>%
    dplyr::group_by(barcode, chain) %>%
    dplyr::summarise(key = list(sort(unique(cloneKey)))) %>%
    pivot_wider(names_from = "chain",
      values_from = "key")

  cloneDictionary <- cloneLookup %>%
    dplyr::ungroup() %>%
    dplyr::select(-one_of(c("barcode"))) %>%
    unique()

  # Assign each row a clone ID
  cloneDictionary$cloneID <- paste0("Clone", "_", 1:nrow(cloneDictionary))

  # Merge the clone IDs back into the dataframe where each cell(lib is a row)
  cloneLookup <- merge(cloneLookup, cloneDictionary)

  # Propagate the narrow clone definition back up to the tcrs data frame
  tcrs[, cloneColumnName] <- cloneLookup$cloneID[match(tcrs$barcode,
    cloneLookup$barcode)]

  tcrs$cloneKey <- NULL

  return(tcrs)
}
```

```{r clean_and_call_clones}
TCRs.df <- callMultiplets(TCRs.df)

cleanTCRs.df <- TCRs.df %>%
  dplyr::filter(!multiplet) %>%
  dplyr::filter(!isMAIT) %>%
  dplyr::filter(!isINKT)

barcodesToFilter <- TCRs.df$barcode[which(TCRs.df$multiplet |
  TCRs.df$isMAIT |
  TCRs.df$isINKT)]

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3",
  cloneColumnName = "cdr3CloneID")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "CDR3nt",
  cloneColumnName = "cdr3CloneID_nt")

cleanTCRs.df <- callClones(cleanTCRs.df,
  cloneOption = "VJandCDR3",
  cloneColumnName = "threePointCloneID")
```

```{r add_qc_metrics_anno}
## Add % mito information, library name info
for (i in 1:length(seuratObjects)) {
  seurat <- seuratObjects[[i]]
  seurat[["percent_mt"]] <- PercentageFeatureSet(seurat, pattern = "^MT-")
  seurat[["pool"]] <- i
  seuratObjects[[i]] <- seurat
}

for (i in 1:length(seuratRawObjects)) {
  seurat <- seuratRawObjects[[i]]
  seurat[["percent_mt"]] <- PercentageFeatureSet(seurat, pattern = "^MT-")
  seurat[["pool"]] <- i
  seuratRawObjects[[i]] <- seurat
}
```

```{r plot_n_features, fig.height = 3, fig.width=3}
# Select QC cutoffs
nFeatureLow <- 1000
nFeatureHigh <- 4500
pctMt <- 4

# Look at distributions of quality features
nFeatureHistograms <- lapply(seuratObjects, function(x) hist(x$nFeature_RNA, 200, xlim = c(0, 5000), main = unique(x$pool), xlab = "nFeature RNA"))

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_NFeatureHistograms.pdf")),
height = 4,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratObjects, function(x) {
  hist(x$nFeature_RNA, 50, xlim = c(0, 6000), main = unique(x$pool), xlab = "nFeature RNA")
  abline(v = nFeatureHigh)
  abline(v = nFeatureLow)
})

invisible(dev.off())
```

```{r plot_pct_mito, fig.height = 3, fig.width=3}
pctMitoHistograms <- lapply(seuratObjects, function(x) hist(x$percent_mt, 50, xlim = c(0, 25), main = unique(x$pool), xlab = "% mitochondrial reads"))

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_PctMitoHistograms.pdf")),
height = 4,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratObjects, function(x) {
  hist(x$percent_mt, 100, xlim = c(0, 25), main = unique(x$pool), xlab = "% mitochondrial reads")
  abline(v = pctMt)
})

invisible(dev.off())
```

```{r inspect_qc_cutoffs, fig.width=8, fig.height=2}
plotLayers <- list(geom_vline(xintercept = nFeatureLow),
  geom_vline(xintercept = nFeatureHigh),
  geom_hline(yintercept = pctMt),
  labs(x = "Number of genes",
    y = "% mito reads",
    title = ""),
  xlim(c(0, 7000)),
  ylim(c(0, 50)),
  theme(legend.position = "none"))

featureScatterPlots <- lapply(seuratObjects, function(x) FeatureScatter(x,
  feature1 = "nFeature_RNA",
  feature2 = "percent_mt") +
  plotLayers +
  ggtitle(unique(x$pool)))

ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_QCscatterplots.pdf")),
height = 6,
width = 10)

ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

invisible(dev.off())
```

```{r nCountsRNA}
rasterResolutionDpi <- 300

qcMetricsThresholds <-
  c(
    "min_nFeature_RNA" = 250,
    "max_nFeature_RNA" = 6000,
    "min_nCount_RNA" = 450,
    "max_nCount_RNA" = 35000,
    # "nFeature_ADT" = 50,
    # "nCount_ADT" = 500,
    "percent_mt" = 12.5
    # "percent_ribo" = 50,
    # "percent_hb" = 10
  )

qcMetricsDfForPlot <-
  data.frame(
    metric = str_replace(names(qcMetricsThresholds), "^(min|max)_", ""),
    threshold = unname(qcMetricsThresholds)
  )

qcMetrics.tmp <-
  c("nFeature_RNA", "nCount_RNA",
    # "nFeature_ADT", "nCount_ADT",
    "percent_mt"
    # "percent_ribo", "percent_hb")
  )

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_QCmetricplots.pdf")),
height = 5.5,
width = 12)

plot.tmp <-
  seuratObjects[[1]]@meta.data %>%
  dplyr::select(all_of(qcMetrics.tmp)) %>%
  pivot_longer(
    cols = one_of(qcMetrics.tmp),
    names_to = "metric", values_to = "value") %>%
  mutate(metric = metric %>% factor(levels = qcMetrics.tmp)) %>%
  ggplot(mapping = aes(x = "sample", y = value)) +
  geom_violin() +
  ggrastr::rasterise(
    geom_jitter(size = 0.5), dpi = rasterResolutionDpi) +
  facet_wrap(facets = vars(metric), ncol = 2, scales = "free_y") +
  geom_hline(
    data =
      qcMetricsDfForPlot %>%
        dplyr::filter(metric %in% qcMetrics.tmp) %>%
        mutate(metric = metric %>% factor(levels = qcMetrics.tmp)),
    mapping = aes(yintercept = threshold),
    color = "red", linetype = "dashed") +
  theme(
    axis.text.x = element_blank(),
    # axis.text.x = element_text(angle=-45, hjust=0, size = 10),
    strip.text = element_text(size = rel(0.8), margin = margin(t = 3, b = 3))) +
  labs(x = NULL, y = NULL)

print(plot.tmp)

dev.off()
```

```{r add_anno}
annoP589_1 <- read_excel(file.path(dataInputDir, "P589-1_Final_Annotation.xlsx"),
  "Final Annotation")

# Remove duplicated columns based on their values
annoP589_1 <- annoP589_1 %>% dplyr::select(which(!duplicated(as.list(.))))

# clean up colnames
colnames(annoP589_1) <- gsub("\\.", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub(" ", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("/", "Per", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\r\n", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("%", "Percent", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("#", "Num", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("-", "", colnames(annoP589_1))
colnames(annoP589_1) <- sub("[1-9]$", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\\(", "_", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\\)", "", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("\\(", "_", colnames(annoP589_1))
colnames(annoP589_1) <- gsub("10x", "tenx", colnames(annoP589_1))
colnames(annoP589_1) <- sub("^([A-Z])", "\\L\\1", colnames(annoP589_1), perl = TRUE)

names(annoP589_1)[names(annoP589_1) == "gateforcellcounter"] <- "gateForCellCounter"
names(annoP589_1)[names(annoP589_1) == "libtype"] <- "libType"
names(annoP589_1)[names(annoP589_1) == "tenxdillibQubitn"]

names(annoP589_1)[names(annoP589_1) == "index_name"] <- "indexName"
names(annoP589_1)[names(annoP589_1) == "samplelocationPlateWellPerTubeNum"] <- "sampleLocationPlateWellPerTubeNum"
names(annoP589_1)[names(annoP589_1) == "cellCountafterWashPerResuspcellsPerul"] <- "cellCountAfterWashPerResuspcellsPerul"
names(annoP589_1)[names(annoP589_1) == "poolratio"] <- "poolRatio"
names(annoP589_1)[names(annoP589_1) == "datecollected"] <- "dateCollected"

# Define the mapping of donor IDs to numbers
donor_mapping <- c(
  "CerosalettiLab1059994" = 1,
  "CerosalettiLab1464776" = 2,
  "CerosalettiLab448473" = 3,
  "CerosalettiLab632811" = 4,
  "CerosalettiLab839987" = 5,
  "CerosalettiLab942655" = 6
)

# Add the #donorIdFigures column to seuratQCMerged@meta.data
annoP589_1$donorIdFigures <- with(annoP589_1, {
  donor_id <- as.character(donor_mapping[donorID])
  paste0(donor_id, "_", studyGroup)
})
```

```{r setupPalettes}
# Extract unique donor IDs
unique_donor_ids <- unique(annoP589_1$donorIdFigures)

# Reorder unique donor IDs to match the desired order
desired_order <- c("2_T1D", "5_T1D", "6_T1D", "1_Control", "3_Control", "4_Control")
unique_donor_ids <- unique_donor_ids[order(match(unique_donor_ids, desired_order))]

# Ensure the number of colors matches the number of unique donor IDs
colors <- paletteer::paletteer_d(palette = "LaCroixColoR::Lemon", n = length(unique_donor_ids))

# Create named vector
palDonorId <- setNames(colors, unique_donor_ids)

# create stimulation color palette
palStimulation <- setNames(paletteer::paletteer_d("khroma::highcontrast", n = 3), c("Polyclonal", "IAR", "Microbial"))

# create cellType (TotalSeq) color palette
palCellType <- c("Treg" = "blue", "Tconv" = "red", "Other" = "gray")

# create studyGroup color palette
palStudyGroup <- c("Control" = "lightblue", "T1D" = "orange")
```

```{r make_qc_cuts, results = "show"}
seuratQC <- NULL

for (i in 1:length(seuratObjects)) {
  seurat <- seuratObjects[[i]]

  seuratQC[[i]] <- subset(seurat,
    subset = nFeature_RNA > nFeatureLow & nFeature_RNA < nFeatureHigh & percent_mt < pctMt)
}

# Tally how many cells pass QC
poolAnno <- data.frame("pool" = c("1",
  "2"))

poolAnno$nCells <- NA
poolAnno$nCellsQC <- NA

for (i in 1:length(seuratObjects)) {
  selectedPool <- unique(seuratObjects[[i]]$pool) %>%
    as.character()

  poolAnno$nCells[poolAnno$pool == selectedPool] <- dim(seuratObjects[[i]])[2]

  poolAnno$nCellsQC[poolAnno$pool == selectedPool] <- dim(seuratQC[[i]])[2]
}

poolAnno$pctPass <- round(poolAnno$nCellsQC / poolAnno$nCells * 100, 2)

poolAnno %>%
  dplyr::select(pool, nCells, nCellsQC, pctPass) %>%
  dplyr::rename(Pool = pool,
    `Number of cells` = nCells,
    `Number of high quality cells` = nCellsQC,
    `Percent of cells that pass QC` = pctPass) %>%
  kable(row.names = F,
    caption = "Quality analysis summary") %>%
  kable_styling(full_width = F,
    position = "left")
```

```{r qc_nfeature}

# QC cutoffs should be applied differently in P407-1 and P407-2

# Select QC cutoffs separately for -1 and -2

# nFeatureLow1 <- 500
# nFeatureHigh1 <- 4000
# pctMtCutoff1 <- 15

# nFeatureLow2 <- 500
# nFeatureHigh2 <- 2500
# pctMtCutoff2 <- 5

# mergedMono$qcPass <- case_when(mergedMono$project == "P407-1" ~ (mergedMono$nFeature_RNA > nFeatureLow1 & mergedMono$nFeature_RNA < nFeatureHigh1 & mergedMono$percentMT < pctMtCutoff1),
#   mergedMono$project == "P407-2" ~ (mergedMono$nFeature_RNA > nFeatureLow2 & mergedMono$nFeature_RNA < nFeatureHigh2 & mergedMono$percentMT < pctMtCutoff2))

# mergedLymph$qcPass <- mergedLymph$nFeature_RNA > nFeatureLow2 & mergedLymph$nFeature_RNA < nFeatureHigh2 & mergedLymph$percentMT < pctMtCutoff2

# seuratMonoQC <- subset(mergedMono,
#   subset = (qcPass == TRUE))

# seuratLymphQC <- subset(mergedLymph,
#   subset = (qcPass == TRUE))

# remove(mergedMono)
# remove(mergedLymph)
```

### Examine empty drop, do DSB normalization
```{r remove_cells_from_raw}
seuratEmptyObjects <- NULL

for (i in 1:length(seuratRawObjects)) {
  # Remove things that were called cells but failed QC as well as things that were called cells and passed QC
  seuratRaw <- seuratRawObjects[[i]]
  seuratCells <- seuratObjects[[i]]

  # check assay sizes of rna and fb data
  rnaSize <- log10(Matrix::colSums(seuratRaw[["RNA"]]))
  fbSize <- log10(Matrix::colSums(seuratRaw[["FB"]]))
  # filter raw data barcodes to only include those with data for both assays (done in DSB analysis)
  # nonZeroBCIdx <- which(rnaSize > 0 &fbSize > 0)
  # Maybe keeping cells with non-zero fb, but zero rna data is better
  seuratRaw <- seuratRaw[, rnaSize > 0]

  emptyBarcodes <-  setdiff(colnames(seuratRaw), colnames(seuratCells))
  ## check sizes
  # length(emptyBarcodes)+ncol(seuratCells)
  # ncol(seuratRaw)
  seuratEmpty <- seuratRaw[, emptyBarcodes]

  # Filter objects with > 100 RNA features (in line with DSB paper)
  seuratEmpty <- subset(seuratEmpty,
    subset = nFeature_RNA < 100)

  # Filter objects with < 10 or > 1000 Ab counts (like in DSB paper)
  seuratEmpty <- subset(seuratEmpty,
    subset = nCount_FB > 10 & nCount_FB < 1000)

  seuratEmptyObjects[[i]] <- seuratEmpty
}

# Clean up
remove(seuratRawObjects)
remove(seuratRaw)
```

#Examine empty droplets

```{r plot_n_features_empty, fig.height = 3, fig.width=3}
# Select QC cutoffs

# Look at distributions of quality features
nFeatureHistograms <- lapply(seuratEmptyObjects, function(x) hist(x$nFeature_RNA, 200, xlim = c(0, 100), main = unique(x$pool), xlab = "nFeature RNA"))

pdf(file.path(plotDir,
  "NFeatureHistograms_EmptyDrops.pdf"),
height = 6,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratEmptyObjects, function(x) {
  hist(x$nFeature_RNA, 50, xlim = c(0, 100), main = unique(x$pool), xlab = "nFeature RNA")
  abline(v = nFeatureHigh)
  abline(v = nFeatureLow)
})

invisible(dev.off())
```

```{r plot_n_features_abs, fig.height = 3, fig.width=3}
# Look at distributions of quality features
nFeatureHistograms <- lapply(seuratEmptyObjects, function(x) hist(x$nFeature_FB, 200, xlim = c(0, 200), main = unique(x$pool), xlab = "nFeature FB"))

pdf(file.path(plotDir,
  "NFeatureHistogramsFB_EmptyDrops.pdf"),
height = 6,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratEmptyObjects, function(x) {
  hist(x$nFeature_FB, 50, xlim = c(0, 200), main = unique(x$pool), xlab = "nFeature Abs")
})

invisible(dev.off())

# Make a single plot of n feature distributions
nFeatureFBList <- NULL
for (i in 1:length(seuratEmptyObjects)) {
  seurat <- seuratEmptyObjects[[i]]

  nFeatureFBList[[i]] <- data.frame(pool = seurat$pool,
    nFeatureFB = seurat$nFeature_FB)
}

nFeatureFB <- bind_rows(nFeatureFBList)

gNFeatureAb <- nFeatureFB %>%
  dplyr::mutate(dilution = factor(pool,
    levels = c ("1",
      "2"))) %>%
  ggplot() +
  geom_density(aes(x = nFeatureFB,
    color = pool)) +
  # scale_color_manual(values = dilutionColors) +
  labs(x = "Number of unique antibody features",
    y = "Density (area under each curve = 1)",
    color = "Pool")

pdf(file.path(plotDir,
  "NFeatureDensityPlotsFB_EmptyDrops.pdf"),
height = 6,
width = 8)

print(gNFeatureAb)

invisible(dev.off())
```

##Plots of the percent mitochondrial reads per library

The following plots show the percent of features that mapped to mitochondrial genes. High percentages can indicate a poor quality or dying cell. 

```{r plot_pct_mito, fig.height = 3, fig.width=3}
pctMitoHistograms <- lapply(seuratEmptyObjects, function(x) hist(x$percent_mt, 50, xlim = c(0, 20), main = unique(x$pool), xlab = "% mitochondrial reads"))

pdf(file.path(plotDir,
  "PctMitoHistograms_EmptyDrops.pdf"),
height = 6,
width = 10)

par(mfrow = c(1, 2))
lapply(seuratEmptyObjects, function(x) {
  hist(x$percent_mt, 100, xlim = c(0, 25), main = unique(x$pool), xlab = "% mitochondrial reads")
  abline(v = pctMt)
})

invisible(dev.off())
```

## Quality metric scatterplots with cutoffs

The plots below explore the relationship between percent mitochonridal reads and the number of features detected. Each point represents a cell. Lines on the plots indicate quality cutoffs for features (both a lower and an upper bound) and mitochrondial reads (an upper bound). 

```{r inspect_qc_cutoffs, fig.width=8, fig.height=2}
plotLayers <- list(labs(x = "Number of genes",
  y = "Number of ab features",
  title = ""),
scale_y_log10(),
theme(legend.position = "none"))

featureScatterPlots <- lapply(seuratEmptyObjects, function(x) FeatureScatter(x,
  feature1 = "nFeature_RNA",
  feature2 = "nCount_FB") +
  plotLayers +
  ggtitle(unique(x$pool)))


ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

png(file.path(plotDir,
  "NFeatureScatterplots_EmptyDrops.png"),
height = 600,
width = 800)

ggpubr::ggarrange(plotlist = featureScatterPlots,
  ncol = 2,
  nrow = 1)

invisible(dev.off())

for (i in 1:length(seuratEmptyObjects)) {
  seuratEmpty <- seuratEmptyObjects[[i]]
  gFeature <- seuratEmpty@meta.data %>%
    ggplot(aes(x = nFeature_RNA,
      y = nCount_FB)) +
    geom_bin2d(bins = 300) +
    plotLayers +
    scale_fill_viridis_c(option = "C")
}
```

### end of examining empty drops for DSB normalization


```{r hist_and_biaxial_HT_plots}
# merge Seurat objects
seuratQCMerged <- merge(seuratQC[[1]],
  y = c(seuratQC[2]),
  add.cell.ids = poolOrder,
  merge.data = TRUE)

# DSB normalization on the FB/CITEseq/TotalSeq/whatever data
controlAbs <- c("Mouse IgG1, - isotype Ctrl")

dsbNormProtList <- NULL

seuratEmptyMerged <- merge(seuratEmptyObjects[[1]],
  y = c(seuratQC[2]),
  add.cell.ids = poolOrder,
  merge.data = TRUE)

emptyMatrix <- GetAssayData(seuratEmptyMerged, assay = "FB")
cellMatrix <- GetAssayData(seuratQCMerged, assay = "FB")

dsbNormProtMerged <- DSBNormalizeProtein(
  cell_protein_matrix = cellMatrix,
  empty_drop_matrix = emptyMatrix,
  denoise.counts = TRUE,
  use.isotype.control = TRUE,
  isotype.control.name.vec = controlAbs
)

# add DSB normalized FB data to seurat object
seuratQCMerged[["DSB"]] <- CreateAssayObject(dsbNormProtMerged)

DefaultAssay(seuratQCMerged) <- "HT"

htVariables <- rownames(seuratQCMerged)
htDF <- FetchData(seuratQCMerged,
  vars = c(htVariables))

# manually transform as log(count + 1)
htDF <- log(htDF + 1)

# manually transform as log(cpm +1)
# htDF <- log(((htDF * 10^6) / colSums(htDF)) + 1)

# Convert the data frame to a matrix
htMatrix <- as.matrix(htDF)

# Transpose htMatrix
htMatrix <- t(htMatrix)

# Get the cell names (columns) and feature names (rows) from the existing "HT" assay data
cells <- colnames(seuratQCMerged[["HT"]]@data)
features <- rownames(seuratQCMerged[["HT"]]@data)

# Ensure the cell names (columns) and feature names (rows) in htMatrix match those in the existing "HT" assay data
colnames(htMatrix) <- cells
rownames(htMatrix) <- features

# Overwrite the "HT" assay data with the normalized data
seuratQCMerged[["HT"]]@data <- htMatrix

png(file.path(plotDir,
  paste0(filenameSuffix, "_Scatterplots_HTExpression.png")),
height = 1000,
width = 2400)

ggpairs(htDF[sample(1:nrow(htDF)), ],
  columns = 1:18,
  aes(alpha = 0.4))

invisible(dev.off())
```

```{r stephanPribitzerHTODemuxAltApproach}
# #Usually performs better for human samples than hto demux

# individual cutoffs determined by examining ridgeplots of the individual hashtags (log(counts + 1))

# Create a vector of cutoffs
htCutoffs <- c("CerosalettiLab1464776-Islet" = 3.5,
  "CerosalettiLab1464776-CEFX" = 4,
  "CerosalettiLab1059994-Islet" = 4,
  "CerosalettiLab1059994-CEFX" = 3.85,
  "CerosalettiLab942655-Islet" = 4,
  "CerosalettiLab942655-CEFX" = 4,
  "CerosalettiLab1464776-CD3CD28" = 5,
  "CerosalettiLab1059994-CD3CD28" = 6,
  "CerosalettiLab942655-CD3CD28" = 5.5,
  "CerosalettiLab632811-CD3CD28" = 6.25,
  "CerosalettiLab448473-CD3CD28" = 7.25,
  "CerosalettiLab839987-CD3CD28" = 6.5,
  "CerosalettiLab632811-CEFX" = 4.25,
  "CerosalettiLab448473-CEFX" = 3.5,
  "CerosalettiLab839987-CEFX" = 3.5,
  "CerosalettiLab632811-Islet" = 4.25,
  "CerosalettiLab448473-Islet" = 3.5,
  "CerosalettiLab839987-Islet" = 3.5)

# Define the mapping of donor IDs to numbers
donor_mapping <- c(
  "CerosalettiLab1059994" = 1,
  "CerosalettiLab1464776" = 2,
  "CerosalettiLab448473" = 3,
  "CerosalettiLab632811" = 4,
  "CerosalettiLab839987" = 5,
  "CerosalettiLab942655" = 6
)

# # Add the #donorIdFigures column to seuratQCMerged@meta.data
# seuratQCMerged@meta.data$donorIdFigures <- with(seuratQCMerged@meta.data, {
#   donor_id <- as.character(donor_mapping[donorId])
#   paste0(donor_id, "_", studyGroup)
# })

# # Ensure that the donorIdFigures column is correctly formatted
# seuratQCMerged@meta.data$donorIdFigures <- ifelse(
#   is.na(seuratQCMerged@meta.data$donorIdFigures),
#   NA,
#   seuratQCMerged@meta.data$donorIdFigures
# )

# # make $stimulationFigures where the values in $stimulation map from "CD3CD28", "CEFX", "Islet"
# # to "Polyclonal", "Microbial", "IAR"
# stimulation_mapping <- c(
#   "CD3CD28" = "Polyclonal",
#   "CEFX" = "Microbial",
#   "Islet" = "IAR"
# )

# # Assuming your data frame is named df
# # Add the stimulationFigures column to the data frame
# seuratQCMerged@meta.data$stimulationFigures <- stimulation_mapping[seuratQCMerged@meta.data$stimulation]

# # Ensure that the stimulationFigures column is correctly formatted
# seuratQCMerged@meta.data$stimulationFigures <- ifelse(
#   is.na(seuratQCMerged@meta.data$stimulationFigures),
#   NA,
#   seuratQCMerged@meta.data$stimulationFigures
# )

# # make $stimulationFigures a factor with order "Microbial", "IAR", "Polyclonal"
# seuratQCMerged@meta.data$stimulationFigures <- factor(seuratQCMerged@meta.data$stimulationFigures,
#   levels = c("Microbial", "IAR", "Polyclonal"))

hashtagHistograms.tmp <- htDF %>%
  pivot_longer(cols = all_of(pool1HTVars),
    names_to = "ht",
    values_to = "counts") %>%
  mutate(cutoff = htCutoffs[ht]) %>%  # Add a column with the cutoff for each hashtag
  ggplot(aes(x = counts)) +
  geom_histogram() +
  geom_vline(aes(xintercept = cutoff),  # Use the cutoff column as the xintercept
    color = "red") +
  labs(x = "hashtag expression",
    y = "log10(Number of cells)") +
  scale_y_log10() +
  scale_x_continuous(breaks = 0:12) +
  facet_wrap(~ht,
    scales = "free_y",
    ncol = 3)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_HistogramsHashtags_pool1.pdf")),
width = 12,
height = 5.5)

print(hashtagHistograms.tmp)

invisible(dev.off())

rm_tmp(ask = FALSE)

hashtagHistograms.tmp <- htDF %>%
  pivot_longer(cols = all_of(pool2HTVars),
    names_to = "ht",
    values_to = "counts") %>%
  mutate(cutoff = htCutoffs[ht]) %>%  # Add a column with the cutoff for each hashtag
  ggplot(aes(x = counts)) +
  geom_histogram() +
  geom_vline(aes(xintercept = cutoff),  # Use the cutoff column as the xintercept
    color = "red") +
  labs(x = "hashtag expression",
    y = "log10(Number of cells)") +
  scale_y_log10() +
  scale_x_continuous(breaks = 0:12) +
  facet_wrap(~ht,
    scales = "free_y",
    ncol = 3)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_HistogramsHashtags_pool2.pdf")),
width = 12,
height = 5.5)

print(hashtagHistograms.tmp)

invisible(dev.off())

rm_tmp(ask = FALSE)

# htCutoffs <- c("CerosalettiLab1464776-Islet" = 1, "CerosalettiLab1464776-CEFX" = 1, "CerosalettiLab1059994-Islet" = 1,
#                "CerosalettiLab1059994-CEFX" = 1, "CerosalettiLab942655-Islet" = 1, "CerosalettiLab942655-CEFX" = 1,
#                "CerosalettiLab1464776-CD3CD28" = 1, "CerosalettiLab1059994-CD3CD28" = 1, "CerosalettiLab942655-CD3CD28" = 1)

# Match the names in htCutoffs to the column names in htDF
htCutoffs <- htCutoffs[match(colnames(htDF), names(htCutoffs))]

# Apply the cutoffs to each column
htDF$nCells <- rowSums(sweep(htDF, 2, htCutoffs, ">"))

htDF <- htDF %>%
  dplyr::mutate(manualHT = case_when(nCells > 1 ~ "Multiplet",
    nCells == 0 ~ "Negative",
    `CerosalettiLab1464776-Islet` > htCutoffs["CerosalettiLab1464776-Islet"] ~ "CerosalettiLab1464776-Islet",
    `CerosalettiLab1464776-CEFX` > htCutoffs["CerosalettiLab1464776-CEFX"] ~ "CerosalettiLab1464776-CEFX",
    `CerosalettiLab1059994-Islet` > htCutoffs["CerosalettiLab1059994-Islet"] ~ "CerosalettiLab1059994-Islet",
    `CerosalettiLab1059994-CEFX` > htCutoffs["CerosalettiLab1059994-CEFX"] ~ "CerosalettiLab1059994-CEFX",
    `CerosalettiLab942655-Islet` > htCutoffs["CerosalettiLab942655-Islet"] ~ "CerosalettiLab942655-Islet",
    `CerosalettiLab942655-CEFX` > htCutoffs["CerosalettiLab942655-CEFX"] ~ "CerosalettiLab942655-CEFX",
    `CerosalettiLab1464776-CD3CD28` > htCutoffs["CerosalettiLab1464776-CD3CD28"] ~ "CerosalettiLab1464776-CD3CD28",
    `CerosalettiLab1059994-CD3CD28` > htCutoffs["CerosalettiLab1059994-CD3CD28"] ~ "CerosalettiLab1059994-CD3CD28",
    `CerosalettiLab942655-CD3CD28` > htCutoffs["CerosalettiLab942655-CD3CD28"] ~ "CerosalettiLab942655-CD3CD28",
    `CerosalettiLab632811-CD3CD28` > htCutoffs["CerosalettiLab632811-CD3CD28"] ~ "CerosalettiLab632811-CD3CD28",
    `CerosalettiLab448473-CD3CD28` > htCutoffs["CerosalettiLab448473-CD3CD28"] ~ "CerosalettiLab448473-CD3CD28",
    `CerosalettiLab839987-CD3CD28` > htCutoffs["CerosalettiLab839987-CD3CD28"] ~ "CerosalettiLab839987-CD3CD28",
    `CerosalettiLab632811-CEFX` > htCutoffs["CerosalettiLab632811-CEFX"] ~ "CerosalettiLab632811-CEFX",
    `CerosalettiLab448473-CEFX` > htCutoffs["CerosalettiLab448473-CEFX"] ~ "CerosalettiLab448473-CEFX",
    `CerosalettiLab839987-CEFX` > htCutoffs["CerosalettiLab839987-CEFX"] ~ "CerosalettiLab839987-CEFX",
    `CerosalettiLab632811-Islet` > htCutoffs["CerosalettiLab632811-Islet"] ~ "CerosalettiLab632811-Islet",
    `CerosalettiLab448473-Islet` > htCutoffs["CerosalettiLab448473-Islet"] ~ "CerosalettiLab448473-Islet",
    `CerosalettiLab839987-Islet` > htCutoffs["CerosalettiLab839987-Islet"] ~ "CerosalettiLab839987-Islet"))

# Check ht calls. Many things are multiplets according to this
table(htDF$manualHT)

png(file.path(plotDir,
  paste0(filenameSuffix, "_Scatterplots_HTExpression_ManualDemux_V3.png")),
height = 18,
width = 30,
units = "in",
res = 600)


ggpairs(htDF[sample(1:nrow(htDF)), ],
  columns = 1:length(htVariables),
  aes(color = manualHT,
    fill = manualHT,
    alpha = 0.4))

invisible(dev.off())

# add the manual demultiplexing results into @meta.data
seuratQCMerged@meta.data <- seuratQCMerged@meta.data %>%
  dplyr::mutate(htDemux = htDF$manualHT,
    donorId = sub("-.*", "", htDemux),
    stimulation = sub(".*-", "", htDemux))

# Check with additional plots

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Ridgeplots_HTExpression_ManualDemux_pool1.pdf")),
height = 20,
width = 30)

# RidgePlot(seuratQCMerged,
#           assay = "HT",
#           features = htVariables,
#           group.by = "htDemux",
#           ncol = 3) &
#   labs(x = "Hashtag expression",
#        y = "Assigned demux group") +
#   scale_x_continuous(limits = c(0, 9), breaks = seq(0, 9, by = 0.5))

# Create a list to store the plots
plots <- list()

# Create a plot for each feature
for (feature in pool1HTVars) {
  p <- RidgePlot(seuratQCMerged,
    assay = "HT",
    features = feature,
    group.by = "htDemux") +
    labs(x = "Hashtag expression",
      y = "Assigned demux group") +
    scale_x_continuous(limits = c(0, 10), breaks = seq(0, 10, by = 0.5)) +
    theme(legend.position = "none")  # Remove the legend

  # Add the plot to the list
  plots[[feature]] <- p
}

# Combine the plots
combined_plot <- patchwork::wrap_plots(plots, ncol = 3)

# Print the combined plot
print(combined_plot)

invisible(dev.off())

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_Ridgeplots_HTExpression_ManualDemux_pool2.pdf")),
height = 20,
width = 30)

# Create a list to store the plots
plots <- list()

# Create a plot for each feature
for (feature in pool2HTVars) {
  p <- RidgePlot(seuratQCMerged,
    assay = "HT",
    features = feature,
    group.by = "htDemux") +
    labs(x = "Hashtag expression",
      y = "Assigned demux group") +
    scale_x_continuous(limits = c(0, 10), breaks = seq(0, 10, by = 0.5)) +
    theme(legend.position = "none")  # Remove the legend

  # Add the plot to the list
  plots[[feature]] <- p
}

# Combine the plots
combined_plot <- patchwork::wrap_plots(plots, ncol = 3)

# Print the combined plot
print(combined_plot)

invisible(dev.off())


DefaultAssay(seuratQCMerged) <- "HT"
seuratQCMerged <- ScaleData(seuratQCMerged, features = rownames(htVariables),
  verbose = FALSE)
seuratQCMerged <- RunPCA(seuratQCMerged, features = htVariables, approx = FALSE)
# ElbowPlot(seuratQCMerged)
seuratQCMerged <- FindNeighbors(seuratQCMerged, dims = 1:6)
clusterResolution <- c("HT" = 0.1, "RNA" = 0.3)
seuratQCMerged <- FindClusters(seuratQCMerged, resolution = clusterResolution["HT"])

seuratQCMerged <- RunUMAP(seuratQCMerged, dims = 1:6)

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

clusterName[["HT"]] <-
  paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["HT"]], "\\.", "p"))
seuratQCMerged <- seuratQCMerged %>%
  AddMetaData(Idents(seuratQCMerged), col.name = clusterName[["HT"]])

Idents(seuratQCMerged) <- seuratQCMerged@meta.data[[clusterName[["HT"]]]]
clusterMarkers[[paste0("HT_", clusterName[["HT"]])]] <-
  FindAllMarkers(seuratQCMerged, assay = "HT")

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_HT_labels.pdf")),
height = 5,
width = 12)
umap_plot <- DimPlot(seuratQCMerged,
  label = TRUE,
  repel = TRUE,
  group.by = "htDemux")

print(umap_plot)

invisible(dev.off())
```

```{r cleanSeuratWithTCRData}
# removes iNKT cells, mait cells, and TCR multiplets
seuratQCMerged <- subset(seuratQCMerged, cells = barcodesToFilter, invert = TRUE)

# add_clone_info_to_seurat_object
cellLevelTCRInfo <- cleanTCRs.df %>%
  dplyr::group_by(barcode) %>%
  dplyr::summarise(nAlpha = sum(str_detect(chain, "TRA")),
    nBeta = sum(str_detect(chain, "TRB")),
    cdr3CloneID = unique(cdr3CloneID),
    threePointCloneID = unique(threePointCloneID)) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(cdr3CloneID) %>%
  dplyr::mutate(cdr3CloneCount = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(threePointCloneID) %>%
  dplyr::mutate(threePointCloneCount = n()) %>%
  as.data.frame()

rownames(cellLevelTCRInfo) <- cellLevelTCRInfo$barcode

seuratQCMerged <- AddMetaData(object = seuratQCMerged,
  metadata = cellLevelTCRInfo)
```

```{r addAnnoToSeurat}
# now that we've demultiplexed by hashtag, we can add certain metadata to the Seurat object

# add studyGroup from annoP589_1
sampleNameStudyGroup.tmp <- unique(annoP589_1[, c("sampleName", "studyGroup")])
sampleNameStudyGroup.tmp$sampleName <- gsub("_", "-", sampleNameStudyGroup.tmp$sampleName)

studyGroup_vector.tmp <- setNames(sampleNameStudyGroup.tmp$studyGroup, sampleNameStudyGroup.tmp$sampleName)

seuratQCMerged@meta.data$studyGroup <- studyGroup_vector.tmp[seuratQCMerged@meta.data$htDemux]

rm_tmp(ask = FALSE)

# add $donorIdFigures where
# CerosalettiLab1059994 CerosalettiLab1464776  CerosalettiLab448473  CerosalettiLab632811  CerosalettiLab839987  CerosalettiLab942655 map to
# 1, 2, 3, 4, 5, 6, then an underscore, and then the value of $studyGroup
# Define the mapping of donor IDs to numbers
donor_mapping <- c(
  "CerosalettiLab1059994" = 1,
  "CerosalettiLab1464776" = 2,
  "CerosalettiLab448473" = 3,
  "CerosalettiLab632811" = 4,
  "CerosalettiLab839987" = 5,
  "CerosalettiLab942655" = 6
)

# Add the #donorIdFigures column to seuratQCMerged@meta.data
seuratQCMerged@meta.data$donorIdFigures <- with(seuratQCMerged@meta.data, {
  donor_id <- as.character(donor_mapping[donorId])
  paste0(donor_id, "_", studyGroup)
})

# Ensure that the donorIdFigures column is correctly formatted
seuratQCMerged@meta.data$donorIdFigures <- ifelse(
  is.na(seuratQCMerged@meta.data$donorIdFigures),
  NA,
  seuratQCMerged@meta.data$donorIdFigures
)

# make $stimulationFigures where the values in $stimulation map from "CD3CD28", "CEFX", "Islet"
# to "Polyclonal", "Microbial", "IAR"
stimulation_mapping <- c(
  "CD3CD28" = "Polyclonal",
  "CEFX" = "Microbial",
  "Islet" = "IAR"
)

# Assuming your data frame is named df
# Add the stimulationFigures column to the data frame
seuratQCMerged@meta.data$stimulationFigures <- stimulation_mapping[seuratQCMerged@meta.data$stimulation]

# Ensure that the stimulationFigures column is correctly formatted
seuratQCMerged@meta.data$stimulationFigures <- ifelse(
  is.na(seuratQCMerged@meta.data$stimulationFigures),
  NA,
  seuratQCMerged@meta.data$stimulationFigures
)

# make $stimulationFigures a factor with order "Microbial", "IAR", "Polyclonal"
seuratQCMerged@meta.data$stimulationFigures <- factor(seuratQCMerged@meta.data$stimulationFigures,
  levels = c("Microbial", "IAR", "Polyclonal"))
```

```{r printCellTable}
# Extract the relevant metadata columns
metadata <- seuratQCMerged@meta.data[, c("stimulationFigures", "donorIdFigures")]

# Create a contingency table
cell_count_table <- table(metadata$donorIdFigures, metadata$stimulationFigures)

# Convert the table to a data frame for better readability
cell_count_df <- as.data.frame.matrix(cell_count_table)

# Print the table
print(cell_count_df)


# Define the output file path
output_file_path <- file.path(dataOutputDir, "cell_count_table_cleaned.csv")

# Write the table to a CSV file
write.csv(cell_count_df, file = output_file_path, row.names = TRUE)
```

```{r MattLawranceHTODemuxAltMethod}
# cell barcode with colors for HTO_M1 through HTO_M3, black for unassigned, red for multiplePositive. This is just a named vector of unassigned, multiplepositive, and each of my hashes with a color from miscHelper's big_colorblind_pal function. You can make a named vector with any colors you want. This is just for plotting.

pal.sampleBarcode <-
  big_colorblind_pal(
    n_colors = 4,
    drop_yellow = TRUE, drop_black = FALSE) %>%
  # B0251 = Hashtag1, B0260 = Hashtag2
  setNames(c("unassigned", paste0("HTO-M", 1:3))) %>%
  c("multiplePositive" = "red")

# add logCPM counts for the hashes. My assay was HTO in your case it might be Hashes

# add logCpm for each
offset.tmp <- 1
Pool1InclMultiplets <- Pool1InclMultiplets %>%
  AddMetaData(
    metadata =
      log(t(as.matrix(Pool1InclMultiplets[["HTO"]]@counts + offset.tmp)) /
        Pool1InclMultiplets$nCount_HTO * 1e6) %>%
        as.data.frame() %>%
        set_colnames(make.names(paste0("logCpm", colnames(.))))
  )

# These are my thresholds. You'll get a ridgeplot with these lines drawn soon, the objective is to get the red and blue lines in the middle of the valley between positive and negative samples. ADjust them as necessary

thresholdsHtoPool1 <-
  list(logCpm = c("posAbove" = 11.5, "negBelow" = 11, "minGap" = 1.5))

# Makes a ridgeplot of the hashtag CPMs. Your cols might need to matches logCpmHashes not HTO based on your assay name. Important thing is where the lines are and that they're cleanly splitting your positive and negative peaks. Keep adjusting thresholdsHto until you're happy.

Pool1InclMultiplets@meta.data %>%
  pivot_longer(
    cols = matches("logCpmHTO"),
    names_to = "hashtag", names_prefix = "clrMd",
    values_to = "count") %>%
  ggplot(mapping = aes(x = count)) +
  geom_density(size = 1) +
  facet_wrap(vars(hashtag), nrow = 2) +
  labs(x = "Hashtag counts (log CPM)") +
  geom_vline(
    xintercept = thresholdsHtoPool1[["logCpm"]]["negBelow"],
    linetype = "dashed", color = "red") +
  geom_vline(
    xintercept = thresholdsHtoPool1[["logCpm"]]["posAbove"],
    linetype = "dashed", color = "blue")

# Now that our thresholds are good for what we want, we make a big fat dataframe for every cell's condition at every single hashtag (positive or negative), then count everything that is negative at all hashes as negative for hashes, everything that is positive for multiple hashes as a multiplet, and everything that is exlusively positive for one hash as positive for that hash. Huge chunk, sorry

ogCpmHTO.tmp <-
  Pool1InclMultiplets@meta.data %>%
  dplyr::select(matches("logCpmHTO"))

thresholdLogCpmHTOStatus.tmp <-
  matrix(
    "ambiguous",
    nrow = nrow(logCpmHTO.tmp), ncol = ncol(logCpmHTO.tmp),
    dimnames = dimnames(logCpmHTO.tmp))

thresholdLogCpmHTOStatus.tmp[logCpmHTO.tmp > thresholdsHtoPool1[["logCpm"]]["posAbove"]] <- "positive"
thresholdLogCpmHTOStatus.tmp[logCpmHTO.tmp < thresholdsHtoPool1[["logCpm"]]["negBelow"]] <- "negative"

thresholdLogCpmHTOStatus.tmp <-
  matrix(
    "ambiguous",
    nrow = nrow(logCpmHTO.tmp), ncol = ncol(logCpmHTO.tmp),
    dimnames = dimnames(logCpmHTO.tmp))
thresholdLogCpmHTOStatus.tmp[logCpmHTO.tmp > thresholdsHtoPool1[["logCpm"]]["posAbove"]] <- "positive"
thresholdLogCpmHTOStatus.tmp[
  t(apply(logCpmHTO.tmp, MARGIN = 1, function(x) {
    max(x) - x
  })) >
    thresholdsHtoPool1[["logCpm"]]["minGap"]] <-
  "negative"

sampleBarcode.tmp <- rep("unassigned", ncol(Pool1InclMultiplets))

# identify multiplePositive
cells.tmp <-
  which(apply(thresholdLogCpmHTOStatus.tmp,
    MARGIN = 1, FUN = function(x) {
      sum(x %in% c("ambiguous", "positive")) > 1
    }))
sampleBarcode.tmp[cells.tmp] <- "multiplePositive"

# identify  single positives
cells.tmp <-
  which(apply(thresholdLogCpmHTOStatus.tmp,
    MARGIN = 1,
    FUN = function(x) {
      (sum(x %in% "positive") == 1) & (sum(x %in% "ambiguous") == 0)
    }))
sampleBarcode.tmp[cells.tmp] <-
  colnames(thresholdLogCpmHTOStatus.tmp)[
    apply(thresholdLogCpmHTOStatus.tmp[cells.tmp, ],
      MARGIN = 1, function(x) which(x %in% "positive"))] %>%
  str_replace_all("logCpmHTO.", "HTO-")

sampleBarcode.tmp <-
  sampleBarcode.tmp %>%
  factor(levels = str_sort(unique(.), numeric = TRUE))

# add to Seurat object metadata
Pool1InclMultiplets <- Pool1InclMultiplets %>%
  AddMetaData(
    metadata = sampleBarcode.tmp,
    col.name = "hashtagIdentity")

# Final product is your seurat file with new metadata column called hashtagIdentity with the identity of the hash
```

```{r removeMultipletsAndNegatives}
seuratQCMergedCleaned <- subset(seuratQCMerged,
  subset = (htDemux %in% c("CerosalettiLab1464776-Islet",
    "CerosalettiLab1464776-CEFX",
    "CerosalettiLab1059994-Islet",
    "CerosalettiLab1059994-CEFX",
    "CerosalettiLab942655-Islet",
    "CerosalettiLab942655-CEFX",
    "CerosalettiLab1464776-CD3CD28",
    "CerosalettiLab1059994-CD3CD28",
    "CerosalettiLab942655-CD3CD28",
    "CerosalettiLab632811-CD3CD28",
    "CerosalettiLab448473-CD3CD28",
    "CerosalettiLab839987-CD3CD28",
    "CerosalettiLab632811-CEFX",
    "CerosalettiLab448473-CEFX",
    "CerosalettiLab839987-CEFX",
    "CerosalettiLab632811-Islet",
    "CerosalettiLab448473-Islet",
    "CerosalettiLab839987-Islet")))

# these cells wind up way out in no-man's land in UMAPs:

# 1_ACCCTATTCGCTCCGT-1 1_AGAGAGAAGGTGAGAT-1 1_AGTGTACGTAGCGGGA-1 1_GCGCTCCGTAGAGTGA-1 1_GTCTGCGAGATATTGC-1 2_CAAGACCTCGCTTTAC-1 2_CCCAATTTCATTGTAA-1
suspiciousCellBarcodes <- c("1_ACCCTATTCGCTCCGT-1", "1_AGAGAGAAGGTGAGAT-1", "1_AGTGTACGTAGCGGGA-1", "1_GCGCTCCGTAGAGTGA-1", "1_GTCTGCGAGATATTGC-1", "2_CAAGACCTCGCTTTAC-1", "2_CCCAATTTCATTGTAA-1")
# metaData.df <- seuratQCMergedCleanedDS@meta.data

# #filter metaData.df down to just the $barcode matching suspiciousCellBarcodes
# metaData.df <- metaData.df[metaData.df$HT_names %in% suspiciousCellBarcodes,]

# results: 3 control donors, 1 T1D. All Islet cells. No TCRs. Remove them.

# remove the rows in seuratQCMergedCleaned with the rownames in suspiciousCellBarcodes
# Identify the cell barcodes to keep
cells_to_keep <- setdiff(rownames(seuratQCMergedCleaned@meta.data), suspiciousCellBarcodes)

# Subset the @meta.data slot to keep only the rows not in suspiciousCellBarcodes
seuratQCMergedCleaned <- subset(seuratQCMergedCleaned, cells = cells_to_keep)

# now that we've removed multiplets and negatives, we can set the order of the donorIdFigures factor
seuratQCMergedCleaned@meta.data$donorIdFigures <- factor(
  seuratQCMergedCleaned@meta.data$donorIdFigures,
  levels = c("1_Control", "3_Control", "4_Control", "2_T1D", "5_T1D", "6_T1D")
)
```

```{r clusterByHTAfterRemoval}
seuratQCMergedCleaned <- RunPCA(seuratQCMergedCleaned, features = htVariables, approx = FALSE)
seuratQCMergedCleaned <- RunUMAP(seuratQCMergedCleaned, dims = 1:6)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_HT_labels_multiplet_removed.pdf")),
height = 5,
width = 12)
umap_plot <- DimPlot(seuratQCMergedCleaned,
  label = TRUE,
  repel = TRUE,
  group.by = "htDemux")

print(umap_plot)

invisible(dev.off())
```

```{r CD8CheckAndFilter}
library(openxlsx)

# set the default assay to RNA
DefaultAssay(seuratQCMergedCleaned) <- "RNA"

# we want to remove cells that are likely to be CD8s

# Extract the expression data for CD8A and CD8B
CD8AExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "CD8A")
CD8BExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "CD8B")

# Let's also look at CD4
CD4Expression.tmp <- FetchData(seuratQCMergedCleaned, vars = "CD4")

# Convert the data to a data frame
expressionData.tmp <- data.frame(
  CD8A = CD8AExpression.tmp$CD8A,
  CD8B = CD8BExpression.tmp$CD8B,
  CD4 = CD4Expression.tmp$CD4
)
rownames(expressionData.tmp) <- rownames(CD4Expression.tmp)

# Identify the non-zero entries in CD8A and CD8B
nonZeroBarcodes.tmp <- rownames(expressionData.tmp)[CD8AExpression.tmp$CD8A != 0 | CD8BExpression.tmp$CD8B != 0]
# nonZeroBarcodesCD8A.tmp <- rownames(expressionData.tmp)[CD8AExpression.tmp$CD8A != 0]
# nonZeroBarcodesCD8B.tmp <- rownames(expressionData.tmp)[CD8BExpression.tmp$CD8B != 0]

# make a subset of expressionData.tmp that only has the nonZeroBarcodes.tmp
expressionDataCD8Pos.tmp <- expressionData.tmp[nonZeroBarcodes.tmp, ]

# Subset seuratQCMergedCleaned@meta.data based on these barcodes
metaDataSubset.df.tmp <- seuratQCMergedCleaned@meta.data %>%
  filter(barcode %in% nonZeroBarcodes.tmp)

table(metaDataSubset.df.tmp$stimulationFigures)
# microbial: 288, IAR: 1, Polyclonal: 12

# Group the data by stimulationFigures and donorIdFigures and count the number of cells
cell_counts.tmp <- metaDataSubset.df.tmp %>%
  group_by(stimulationFigures, donorIdFigures) %>%
  summarise(count = n()) %>%
  ungroup()

# Define the output file path
output_file.tmp <- file.path(dataOutputDir, "CD8PosCells.xlsx")

# Save the table to an Excel file
write.xlsx(cell_counts.tmp, output_file.tmp)

# Create histograms using ggplot2
histCD8A.tmp <- ggplot(expressionData.tmp, aes(x = CD8A)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Histogram of CD8A Expression", x = "CD8A Expression", y = "Frequency") +
  theme_minimal() +
  theme(text = element_text(size = 16))

histCD8B.tmp <- ggplot(expressionData.tmp, aes(x = CD8B)) +
  geom_histogram(binwidth = 0.1, fill = "red", color = "black", alpha = 0.7) +
  labs(title = "Histogram of CD8B Expression", x = "CD8B Expression", y = "Frequency") +
  theme_minimal() +
  theme(text = element_text(size = 16))

scatterPlotCD4CD8A.tmp <- ggplot(expressionDataCD8Pos.tmp, aes(x = CD4, y = CD8A)) +
  geom_point() +
  labs(title = "Scatterplot of CD8A vs CD4", x = "CD4 Expression", y = "CD8A") +
  theme_minimal() +
  theme(text = element_text(size = 16))

scatterPlotCD4CD8B.tmp <- ggplot(expressionDataCD8Pos.tmp, aes(x = CD4, y = CD8B)) +
  geom_point() +
  labs(title = "Scatterplot of CD8B vs CD4", x = "CD4 Expression", y = "CD8B") +
  theme_minimal() +
  theme(text = element_text(size = 16))

# Print the histograms
# print(histCD8A.tmp)
# print(histCD8B.tmp)

# let's remove the CD8 positive cells
# Identify the cell barcodes to keep
cellsToKeep.tmp <- setdiff(rownames(seuratQCMergedCleaned@meta.data), nonZeroBarcodes.tmp)

# Subset the @meta.data slot to keep only the rows not in snonZeroBarcodes.tmp
seuratQCMergedCleaned <- subset(seuratQCMergedCleaned, cells = cellsToKeep.tmp)


rm_tmp(ask = FALSE)
```

```{r removeTCRGenesFromGEXData}
# we need to remove TCR genes (TRA, TRB, TRD, TRG) so that they don't drive clustering
# result: none of these genes are present in the RNA assay

# TCRAExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRA")
# TCRBExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRB")
# TCRDExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRD")
# TCRGExpression.tmp <- FetchData(seuratQCMergedCleaned, vars = "TRG")

# rm_tmp(ask = FALSE)
```

```{r reProcessCleanedData}
# Re-run normalization, clustering, UMAP, etc on this subset
seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned, assay = "RNA")

DefaultAssay(seuratQCMergedCleaned) <- "RNA"
seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned, verbose = FALSE, assay = "RNA")

seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratQCMergedCleaned <- FindVariableFeatures(object = seuratQCMergedCleaned,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleaned <- ScaleData(object = seuratQCMergedCleaned, verbose = FALSE)
seuratQCMergedCleaned <- RunPCA(object = seuratQCMergedCleaned, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleaned)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# # let's do some hyperparameter optimization
# # create grid of hyperparameters to test
# hyperParamGrid.df <- expand.grid(
#   findNeighborsDim = c(10, 14, 16),
#   findClustersRes = c(0.01, 0.05, 0.1, 0.3, 0.4, 0.6, 0.8, 1, 1.3, 1.5, 2)
# )

# # detect nuymber of cores, leave one available for the machine to do other things
# nCores <- parallel::detectCores() - 1

# # create the cluster
# myCluster <- parallel::makeCluster(
#   nCores,
#   type = "FORK"
# )

# # check the cluster definition (optional)
# print(myCluster)

# # register it to be used by %dopar%
# doParallel::registerDoParallel(cl = myCluster)

# # check if it is registered (optional)
# foreach::getDoParRegistered()

# # how many workers are available? (optional)
# foreach::getDoParWorkers()

# # Hyperparameter grid search
# clusteringMetrics <- foreach(
#   findNeighborsDim = hyperParamGrid.df$findNeighborsDim,
#   findClustersRes = hyperParamGrid.df$findClustersRes,
#   .combine = "cbind"
# ) %dopar% {
#   # do the UMAP clustering on the Seurat object
#   set.seed(6022)
#   seuratQCMergedCleaned <- FindNeighbors(seuratQCMergedCleaned, dims = 1:findNeighborsDim, verbose = FALSE)
#   seuratQCMergedCleaned <- FindClusters(seuratQCMergedCleaned, resolution = findClustersRes, verbose = FALSE)

#   # extract the cluster information
#   metaData.df <- seuratQCMergedCleaned@meta.data

#   # Extract PCA embeddings
#   pca_embeddings <- seuratQCMergedCleaned@reductions$pca@cell.embeddings

#   clusterMat <- pca_embeddings
#   clusterVect <- as.numeric(metaData.df$seurat_clusters)
#   nClusters <- dim(table(metaData.df$seurat_clusters))

#   # calculate clustering metrics
#   daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
#   calinskiHarabasz <- index.G1(clusterMat, clusterVect)
#   silScore <- silhouette(clusterVect, dist(clusterMat))
#   if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
#     medianSilScore <- NaN
#   } else {
#     silScoreSummary <- summary(silScore)
#     medianSilScore <- silScoreSummary$si.summary["Median"]
#   }

#   clusteringMetrics <- c("nClusters" = nClusters,
#     "DBIndex" = daviesBouldinIdx$DB,
#     "CHMetric" = calinskiHarabasz,
#     "medianSilScore" = medianSilScore)
#   return(clusteringMetrics)
# }

# # transpose the result
# clusteringMetrics <- t(clusteringMetrics)

# # adding the prediction error column
# hyperParamGrid.df$DBIndex <- clusteringMetrics[, "DBIndex"]
# hyperParamGrid.df$CHMetric <- clusteringMetrics[, "CHMetric"]
# hyperParamGrid.df$medianSilScore <- clusteringMetrics[, "medianSilScore.Median"]
# hyperParamGrid.df$nClusters <- clusteringMetrics[, "nClusters"]

# # stop cluster after we're done
# parallel::stopCluster(cl = myCluster)

seuratQCMergedCleaned <- FindNeighbors(seuratQCMergedCleaned, dims = 1:10)
seuratQCMergedCleaned <- FindClusters(seuratQCMergedCleaned, resolution = 0.4)

set.seed(6022)
seuratQCMergedCleaned <- RunUMAP(object = seuratQCMergedCleaned, reduction = "pca",
  dims = 1:10,
  n.neighbors = 30,
  min.dist = 0.1)

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["RNA"]], "\\.", "p"))

# Add metadata to the Seurat object
seuratQCMergedCleaned <- seuratQCMergedCleaned %>%
  AddMetaData(Idents(seuratQCMergedCleaned), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratQCMergedCleaned) <- seuratQCMergedCleaned@meta.data[[clusterName[["RNA"]]]]

# Join the data layers in the RNA assay if not already joined
if (!"RNA" %in% names(seuratQCMergedCleaned@assays)) {
  seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned, layers = c("RNA"))
}

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratQCMergedCleaned, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])
```


```{r tcr_detection_plot_QC}

seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# Add on overall average
tcrDetectionPctsAvg <- seuratQCMergedCleaned@meta.data %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::group_by(tcrGroup, nCells) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = "Average over all")

tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
  tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQC.pdf"),
  height = 4,
  width = 8)

print(gTcrGroup)

dev.off()
```

```{r saveSeuratToH5AD}
# save seuratQCMergedCleaned to h5ad (for CellTypist)

# Convert to V3 object
seuratQCMergedCleanedV3.tmp <- seuratQCMergedCleaned
seuratQCMergedCleanedV3.tmp[["RNA"]] <- as(object = seuratQCMergedCleanedV3.tmp[["RNA"]], Class = "Assay")
library(SeuratDisk)
SaveH5Seurat(
  seuratQCMergedCleanedV3.tmp,
  filename =
    file.path(dataOutputDir, "seuratP589AllCells.h5Seurat"),
  overwrite = TRUE)
Convert(
  source = file.path(dataOutputDir, "seuratP589AllCells.h5Seurat"),
  dest = "h5ad",
  assay = "RNA",
  overwrite = TRUE)

rm_tmp(ask = FALSE)
```

```{r loadCellTypistResultsAndAddToSeurat}
# load in the cellTypist output
cellTypist.df <-
  read.csv(file.path(dataOutputDir, "P589_1_Metadata_With_CelltypistPredictions.csv")) %>%
  data.frame()

# add cellTypist.df$majority_voting to seuratQCMergedCleaned metadata as $cellTypistCalling
# Extract barcodes from cellTypist.df and Seurat object metadata
cellTypistBarcodes <- cellTypist.df$X
seuratBarcodes <- seuratQCMergedCleaned@meta.data$barcode

# Match barcodes and create a named vector for majority_voting
matchingIndices <- match(seuratBarcodes, cellTypistBarcodes)
cellTypistCalling <- cellTypist.df$majority_voting[matchingIndices]

# Add cellTypistCalling to seuratQCMergedCleaned metadata
seuratQCMergedCleaned <- AddMetaData(
  object = seuratQCMergedCleaned,
  metadata = cellTypistCalling,
  col.name = "cellTypistCalling"
)

# Replace NA values in cellTypistCalling column with "Other"
seuratQCMergedCleaned$cellTypistCalling[is.na(seuratQCMergedCleaned$cellTypistCalling)] <- "Other"

# create $cellTypistSimplified where "Treg" stays the same, "Memory CD4 T cell" becomes "Tconv", and all other cells are "Other"
seuratQCMergedCleaned@meta.data$cellTypistSimplified <- ifelse(
  seuratQCMergedCleaned@meta.data$cellTypistCalling == "Treg",
  "Treg",
  ifelse(seuratQCMergedCleaned@meta.data$cellTypistCalling == "Memory CD4 T cell",
    "Tconv",
    "Other")
)

# make a color palette for these cell types
# Define the cell types including NA
cell_types.tmp <- c("Memory CD4 T cell", "cDC1", "Memory CD8 T cell", "Treg", "Other")

# Generate the color palette
palCellTypist <- paletteer::paletteer_d("fishualize::Centropyge_loricula", n = length(cell_types.tmp))
palCellTypist[1] <- "#FF0000" # to match palCellType
palCellTypist[4] <- "#0000FF" # to match palCellType
palCellTypist[5] <- "#808080" # to match palCellType

#
# Create a named vector of colors
names(palCellTypist) <- cell_types.tmp

rm_tmp(ask = FALSE)
```

```{r stemness}
# load in the file containing the stemness ML weights
stemnessWeights <- read_excel(file.path(dataInputDir,
  "Malta_et_al_2018_SignatureWeights_Machine Learning Identifies Stemness Features Associated with Oncogenic Dedifferentiation_Cell.xlsx"),
sheet = "mRNAsi")

# Filter down to just the genes that we have in the RNA assay counts of the Seurat object
stemnessWeights <- stemnessWeights[stemnessWeights$HUGO %in% rownames(seuratQCMergedCleaned[["RNA"]]$counts), ]

# counts_overlap <- log2(counts_pc_norm[rownames(counts_pc_norm) %in% stemness_weights$HUGO, ]+1)

# Filter down to just the genes that we have in the RNA assay counts of the Seurat object
countsOverlap <- seuratQCMergedCleaned[["RNA"]]$counts[rownames(seuratQCMergedCleaned[["RNA"]]$counts) %in% stemnessWeights$HUGO, ]

stemnessWeights$Weight <- as.numeric(stemnessWeights$Weight)

# countsOverlap <- countsOverlap[stemnessWeights$HUGO, ]

# Follow PanCanStem github page appraoch for assigning a stemness score
stemnessScores <- apply(countsOverlap, 2, function(z) {
  cor(z, stemnessWeights$Weight, method = "sp", use = "complete.obs")
})

# Scale the scores to be between 0 and 1
stemnessScores <- stemnessScores - min(stemnessScores)
stemnessScores <- stemnessScores / max(stemnessScores)

# Add stemnessScores to the meta.data of the Seurat object
seuratQCMergedCleaned <- AddMetaData(seuratQCMergedCleaned, metadata = stemnessScores, col.name = "stemnessScore")

# Verify that the stemnessScores have been added
head(seuratQCMergedCleaned@meta.data)
```

```{r tcr_detection_plot_QC_stimulation_facet}
# Define the tcrGroup column
seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Group and summarize the data
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorIdFigures, stimulationFigures) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorIdFigures, stimulationFigures, tcrGroup, nCells, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n(), .groups = "drop") %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup, levels = c("no TCR", "alpha only", "beta only", "both")))

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorIdFigures,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~stimulationFigures)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(file = file.path(plotDir, "TCRDetectionBySampleQCStimulationFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorIdFigures,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1, size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16)) +
  facet_wrap(~stimulationFigures)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(file = file.path(plotDir, "TCRDetectionBySampleQCStimulationFacetPoster.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_facet}

seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~studyGroup)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1, size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16)) +
  facet_wrap(~studyGroup)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupFacetPoster.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_stimulation_facet}

seuratQCMergedCleaned@meta.data$tcrGroup <- ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0 & seuratQCMergedCleaned@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleaned@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleaned@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleaned@meta.data$nAlpha == 0 & seuratQCMergedCleaned@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~ studyGroup + stimulation)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupStimulationFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_table}

chainCounts <- seuratQCMergedCleaned@meta.data %>%
  dplyr::mutate(nCellsTot = n()) %>%
  dplyr::group_by(nAlpha, nBeta, nCellsTot) %>%
  dplyr::summarise(nCells = n()) %>%
  dplyr::mutate(pctCells = round(nCells / nCellsTot * 100, 1),
    stringOutput = paste0(nCells, " (", pctCells, "%)"),
    nAlpha = paste0(nAlpha, " alpha"),
    nBeta = paste0(nBeta, " beta"), ) %>%
  pivot_wider(id_cols = nBeta,
    names_from = nAlpha,
    values_from = stringOutput)

colnames(chainCounts)[1] <- ""

chainCounts <- as.data.frame(chainCounts) # change class from table to dataframe
write.csv(chainCounts,
  file.path(dataOutputDir,
    "tcrChainCountsQC.csv"),
  row.names = F)
```

```{r savePreprocData}
# save the workspace as an .RData file
save.image(file.path(dataOutputDir, "preprocData.RData"))

# load the saved image
load(file.path(dataOutputDir, "preprocData.RData"))
```

```{r downsamplingCEFX}
# First, generate a table of the number of cells from each $donorId in each $stimulation
cellCounts.tmp <- seuratQCMergedCleaned@meta.data %>%
  group_by(donorId, stimulation) %>%
  summarise(cell_count = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = stimulation, values_from = cell_count, values_fill = list(cell_count = 0))

# Print the table
# print(cellCounts.tmp)
#   donorId               CD3CD28  CEFX Islet
#   <chr>                   <int> <int> <int>
# 1 CerosalettiLab1059994      42  1392   110
# 2 CerosalettiLab1464776     159  1858   152
# 3 CerosalettiLab448473      488  3064   236
# 4 CerosalettiLab632811      598  1315   384
# 5 CerosalettiLab839987      274  8188   237
# 6 CerosalettiLab942655      435 12291   244

# set # of CEFX cells to downsample to
# nCEFXDownsample <- 600 # 1300

# Calculate the mean of the cell count for CD3CD28 and Islet cells per donor
meanCellCounts.tmp <- cellCounts.tmp %>%
  rowwise() %>%
  mutate(meanCount = round(mean(c(CD3CD28, Islet)))) %>%
  dplyr::select(donorId, meanCount)

# Convert to a named list
meanCellCountsList.tmp <- setNames(meanCellCounts.tmp$meanCount, meanCellCounts.tmp$donorId)

# Print the list
# print(meanCellCountsList.tmp)

# Identify unique CEFX hashtags
unique_cefx_hashtags <- unique(seuratQCMergedCleaned@meta.data$htDemux[grepl("CEFX$", seuratQCMergedCleaned@meta.data$htDemux)])

# Initialize an empty list to store sampled cells
sampled_cefx_cells_list <- list()

# Iterate over each unique CEFX hashtag
set.seed(6022)
for (hashtag in unique_cefx_hashtags) {
  # set.seed(6022)  # Set seed for reproducibility #NOTE move this out of the loop!! moved on 20241017
  # during changes from downsampling from 600 CEFX to IAR count

  # set nCEFXDownsample to the number of Islet cells for the current donor
  # Extract the donor ID from the hashtag
  donor_id <- sub("-CEFX$", "", hashtag)

  # Look up the Islet cell count for the current donor
  nCEFXDownsample <- cellCounts.tmp %>%
    filter(donorId == donor_id) %>%
    pull(Islet)

  # Identify cells belonging to the current hashtag
  cefx_cells <- rownames(seuratQCMergedCleaned@meta.data)[seuratQCMergedCleaned@meta.data$htDemux == hashtag]

  # Check if any cells were found
  if (length(cefx_cells) == 0) {
    print(paste("No cells belonging to the group", hashtag, "were found."))
  } else {
    # Determine the number of cells to sample
    num_cells_to_sample <- min(nCEFXDownsample, length(cefx_cells))

    if (num_cells_to_sample < nCEFXDownsample) {
      warning(paste("Only", num_cells_to_sample, "cells found belonging to the group", hashtag, ". Proceeding with available cells."))
    }

    # Randomly sample the determined number of cells from the identified cells
    sampled_cefx_cells <- sample(cefx_cells, num_cells_to_sample)

    # Add the sampled cells to the list
    sampled_cefx_cells_list <- c(sampled_cefx_cells_list, sampled_cefx_cells)
  }
}

# Combine all sampled CEFX cells into a single vector
sampled_cefx_cells <- unlist(sampled_cefx_cells_list)

# Identify non-CEFX cells
non_cefx_cells <- rownames(seuratQCMergedCleaned@meta.data)[!grepl("CEFX$", seuratQCMergedCleaned@meta.data$htDemux)]

# Combine sampled CEFX cells with non-CEFX cells
all_cells_to_keep <- c(sampled_cefx_cells, non_cefx_cells)

# Subset the Seurat object to include only the cells to keep
seuratQCMergedCleanedDS <- subset(seuratQCMergedCleaned, cells = all_cells_to_keep)

# Verify the downsampling
print(paste("Number of cells after downsampling:", length(all_cells_to_keep)))

cellCountsDS.tmp <- seuratQCMergedCleanedDS@meta.data %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(cell_count = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = stimulationFigures, values_from = cell_count, values_fill = list(cell_count = 0))

print(cellCountsDS.tmp)

rm_tmp(ask = FALSE)
```


```{r addMetaDataToTCRs, echo=TRUE, message=FALSE, warning=FALSE}
# create $barcode in the seurat object for convenience
seuratQCMergedCleanedDS@meta.data$barcode <- rownames(seuratQCMergedCleanedDS@meta.data)

# subset the TCR dataframe to only the cells to keep after downsampling CEFX
TCRs.DS.df <- TCRs.df %>%
  filter(barcode %in% all_cells_to_keep)

# save seurat metadata as a .tmp
meta_data_df.tmp <- as.data.frame(seuratQCMergedCleanedDS@meta.data)

# Step 3: Merge TCRs.df with the modified meta_data_df based on the barcode
TCRs.DS.df <- TCRs.DS.df %>%
  left_join(meta_data_df.tmp[, c("barcode", "htDemux", "donorId", "stimulation", "studyGroup")], by = c("barcode" = "barcode"))

# Now TCRs.df contains the additional columns from seuratQCMergedCleaned@meta.data
rm_tmp(ask = FALSE)

# let's do some checking
# Extract the barcodes from seuratQCMergedCleanedDS@meta.data
seurat_barcodes <- seuratQCMergedCleanedDS@meta.data$barcode

# Extract the barcodes from TCRs.df
tcr_barcodes <- TCRs.DS.df$barcode

# Find barcodes in seurat_barcodes that are not in tcr_barcodes
missing_barcodes <- setdiff(seurat_barcodes, tcr_barcodes)

# Print the number of missing barcodes
length(missing_barcodes)

# Step 4: Filter the Seurat object to include only the missing barcodes
missing_meta_data <- seuratQCMergedCleanedDS@meta.data[seuratQCMergedCleanedDS@meta.data$barcode %in% missing_barcodes, ]

# Step 5: Create a table that counts the occurrences of each category
missing_counts <- missing_meta_data %>%
  group_by(donorId, stimulation, studyGroup) %>%
  summarise(count = n())

# Step 6: Display the table using kable
missing_TCR_kable <- kable(missing_counts, caption = "Counts of Missing Barcodes by DonorId, Stimulation, and StudyGroup")
```

```{r TCRAccounting_obselete_from_HD_contribution}

# # Then with QCd data
# tcrChainCountsQC <- TCRs.DS.df %>%
#   dplyr::group_by(chain, barcode) %>%
#   summarize(num = n()) %>%
#   pivot_wider(names_from = chain,
#     values_from = num)

# seuratQCMergedCleanedDS@meta.data$nAlpha <- tcrChainCountsQC$TRA[match(seuratQCMergedCleanedDS@meta.data$barcode,
#   tcrChainCountsQC$barcode)]

# seuratQCMergedCleanedDS@meta.data$nBeta <- tcrChainCountsQC$TRB[match(seuratQCMergedCleanedDS@meta.data$barcode,
#   tcrChainCountsQC$barcode)]

# seuratQCMergedCleanedDS@meta.data$nAlpha[is.na(seuratQCMergedCleanedDS@meta.data$nAlpha)] <- 0
# seuratQCMergedCleanedDS@meta.data$nBeta[is.na(seuratQCMergedCleanedDS@meta.data$nBeta)] <- 0

# numDoubletsQC <- sum(seuratQCMergedCleanedDS@meta.data$nAlpha >= 3 | seuratQCMergedCleanedDS@meta.data$nBeta >= 3)
```

```{r filter_doublets_obsolete_from_HD_contribution}

# # Remove cells with: a) 3+ betas or alphas and, b) cells with 2 alphas and 2 betas
# filtered_meta_data <- seuratQCMergedCleanedDS@meta.data %>%
#   filter(!(nBeta >= 3 | nAlpha >= 3 | (nAlpha == 2 & nBeta == 2)))

# # Subset the Seurat object based on the filtered metadata
# seuratQCMergedCleanedDS <- subset(seuratQCMergedCleanedDS, cells = rownames(filtered_meta_data))

# TCRs.DS.df <- TCRs.DS.df %>%
#   dplyr::filter(barcode %in% seuratQCMergedCleanedDS@meta.data$barcode)
```

```{r tcr_detection_plot_QC}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# Add on overall average
tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::group_by(tcrGroup, nCells) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = "Average over all")

tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
  tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQC.pdf"),
  height = 4,
  width = 8)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_stimulation_facet}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~stimulation)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStimulationFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_facet}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~studyGroup)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_plot_QC_studygroup_stimulation_facet}

seuratQCMergedCleanedDS@meta.data$tcrGroup <- ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0 & seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "both",
  ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha > 0, "alpha only",
    ifelse(seuratQCMergedCleanedDS@meta.data$nBeta > 0, "beta only",
      ifelse(seuratQCMergedCleanedDS@meta.data$nAlpha == 0 & seuratQCMergedCleanedDS@meta.data$nBeta == 0, "no TCR", 0))))

# Plot % of alpha only, beta only, both, none, chains by sample (sub-project)
tcrDetectionPcts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::group_by(donorId) %>%
  dplyr::mutate(nCells = n()) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(donorId, tcrGroup, nCells, stimulation, studyGroup) %>%
  dplyr::summarise(nCellsTCRGroup = n()) %>%
  dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
    tcrGroup = factor(tcrGroup,
      levels = c("no TCR",
        "alpha only",
        "beta only",
        "both")),
    donorId = factor(donorId,
      levels = mixedsort(unique(donorId))))

# # Add on overall average
# tcrDetectionPctsAvg <- seuratQCMergedCleanedDS@meta.data %>%
#   dplyr::mutate(nCells = n()) %>%
#   dplyr::group_by(tcrGroup, nCells) %>%
#   dplyr::summarise(nCellsTCRGroup = n()) %>%
#   dplyr::mutate(pctTCRGroup = nCellsTCRGroup / nCells,
#     tcrGroup = factor(tcrGroup,
#       levels = c("no TCR",
#         "alpha only",
#         "beta only",
#         "both")),
#     donorId = "Average over all")

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg)

# tcrDetectionPcts <- bind_rows(tcrDetectionPcts,
#   tcrDetectionPctsAvg) %>%
#   dplyr::mutate(
#     donorId = factor(donorId,
#       levels = str_sort(unique(tcrDetectionPcts$donorId), numeric = TRUE)),
#     donorId = fct_relevel(donorId, "Average over all", after = Inf)
#   )

gTcrGroup <- tcrDetectionPcts %>%
  ggplot(aes(x = donorId,
    y = pctTCRGroup,
    fill = tcrGroup)) +
  geom_col() +
  # scale_x_discrete(labels = str_sort(unique(tcrDetectionPcts$project), numeric = TRUE)) +
  # scale_fill_manual(values = as.vector(GetColors(4, "bright"))) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "",
    y = "% cells",
    fill = "") +
  theme(axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)) +
  facet_wrap(~ studyGroup + stimulation)

# Close any open graphics devices
if (dev.cur() != 1) {
  dev.off()
}

pdf(gTcrGroup,
  file = file.path(plotDir, "TCRDetectionBySampleQCStudyGroupStimulationFacet.pdf"),
  height = 6,
  width = 12)

print(gTcrGroup)

dev.off()
```

```{r tcr_detection_table}

chainCounts <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::mutate(nCellsTot = n()) %>%
  dplyr::group_by(nAlpha, nBeta, nCellsTot) %>%
  dplyr::summarise(nCells = n()) %>%
  dplyr::mutate(pctCells = round(nCells / nCellsTot * 100, 1),
    stringOutput = paste0(nCells, " (", pctCells, "%)"),
    nAlpha = paste0(nAlpha, " alpha"),
    nBeta = paste0(nBeta, " beta"), ) %>%
  pivot_wider(id_cols = nBeta,
    names_from = nAlpha,
    values_from = stringOutput)

colnames(chainCounts)[1] <- ""

chainCounts <- as.data.frame(chainCounts) # change class from table to dataframe
write.csv(chainCounts,
  file.path(dataOutputDir,
    "tcrChainCountsQCDS.csv"),
  row.names = F)
```

```{r strict_clone_calling}

# Define clonality based on shared alpha and beta
# Clone = cells with all chains in common (unlike graph where shared alpha but different beta would be grouped into a common clone)
# Note - Cells that only have an alpha or only a beta are not grouped with
# cells that contain both and alpha and beta.

# Make a table where each row contains a cell and columns list the alpha and beta junctions
cloneLookup <- TCRs.DS.df %>%
  dplyr::group_by(barcode, chain) %>%
  dplyr::summarise(junctions = list(sort(unique(cdr3)))) %>%
  pivot_wider(names_from = "chain",
    values_from = "junctions")

# Take the above table and make a dictionary of possible unique junction pairings
# This is a strict way to define clones
# Want alpha1, alpha2 to be the same clone as alpha2, alpha1.
# Doing sort(junction) above should make sure this happens. The default is to group based on nt alphabetic order. This is problematic for comparison with 10X
# 10X starts reporting the nt sequence at a different location

cloneDict <- cloneLookup %>%
  dplyr::ungroup() %>%
  dplyr::select(-one_of(c("barcode"))) %>%
  unique()

# Assign each row a clone ID
cloneDict$cloneID <- paste0("Clone", "_", 1:nrow(cloneDict))

# Merge the clone IDs back into the dataframe where each cell(lib is a row)
cloneLookup <- merge(cloneLookup, cloneDict)

# Propagate the narrow clone definition back up to the tcrs data frame
TCRs.DS.df$narrowCloneID <- cloneLookup$cloneID[match(TCRs.DS.df$barcode,
  cloneLookup$barcode)]

seuratQCMergedCleanedDS@meta.data$narrowCloneID <- cloneLookup$cloneID[match(seuratQCMergedCleanedDS@meta.data$barcode,
  cloneLookup$barcode)]

# Count how often a strictly defined clone is observed
# This makes a dataframe where each row is a strictly defined clone
cloneCounts <- cloneLookup %>%
  dplyr::ungroup() %>%
  dplyr::select(-one_of(c("barcode"))) %>%
  dplyr::group_by(cloneID) %>%
  dplyr::mutate(cloneFreq = n()) %>%
  unique()

TCRs.DS.df$narrowCloneCounts <- cloneCounts$cloneFreq[match(TCRs.DS.df$narrowCloneID,
  cloneCounts$cloneID)]

seuratQCMergedCleanedDS@meta.data$narrowCloneCounts <- cloneCounts$cloneFreq[match(seuratQCMergedCleanedDS@meta.data$narrowCloneID,
  cloneCounts$cloneID)]

# Clean up NAs, repetitions in columns formatted as lists
clean_list_columns <- function(list_column) {

  cleaned_col <- sapply(list_column,
    function(x)
      paste(unlist(x),
        sep = ", ", collapse = ", "))

  cleaned_col[cleaned_col == "NA"] <- " "
  cleaned_col[cleaned_col == ""] <- " "

  return(cleaned_col)

}

cloneCounts <- cloneCounts %>%
  dplyr::mutate_if(is.list, clean_list_columns) %>%
  dplyr::arrange(desc(cloneFreq))

# table(seuratQCMergedCleanedDS@meta.data$narrowCloneCounts, seuratQCMergedCleanedDS@meta.data$graphCloneCounts)
table(seuratQCMergedCleanedDS@meta.data$narrowCloneCounts)
```

```{r reProcessCleanedDownsampledData}
# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS, layers = c("RNA"))
seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

# seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS, verbose = FALSE)
seuratQCMergedCleanedDS <- FindVariableFeatures(object = seuratQCMergedCleanedDS,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleanedDS <- ScaleData(object = seuratQCMergedCleanedDS, verbose = FALSE)
seuratQCMergedCleanedDS <- RunPCA(object = seuratQCMergedCleanedDS, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleanedDS)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGrid.df <- expand.grid(
  findNeighborsDim = c(5, 7, 14, 16, 18, 20),
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5)
)

# hyperParamGrid.df <- expand.grid(
#   findNeighborsDim = c(5, 2),
#   findClustersRes = c(0.01, 1)
# )

# detect nuymber of cores, leave one available for the machine to do other things
nCores <- parallel::detectCores() - 1

# create the cluster
myCluster <- parallel::makeCluster(
  nCores,
  type = "FORK"
)

# check the cluster definition (optional)
print(myCluster)

# register it to be used by %dopar%
doParallel::registerDoParallel(cl = myCluster)

# check if it is registered (optional)
foreach::getDoParRegistered()

# how many workers are available? (optional)
foreach::getDoParWorkers()

# Hyperparameter grid search
clusteringMetrics <- foreach(
  findNeighborsDim = hyperParamGrid.df$findNeighborsDim,
  findClustersRes = hyperParamGrid.df$findClustersRes,
  .combine = "cbind"
) %dopar% {
  # do the UMAP clustering on the Seurat object
  set.seed(6022)
  seuratQCMergedCleanedDS <- FindNeighbors(seuratQCMergedCleanedDS, dims = 1:findNeighborsDim, verbose = FALSE)
  seuratQCMergedCleanedDS <- FindClusters(seuratQCMergedCleanedDS, resolution = findClustersRes, verbose = FALSE)

  # extract the cluster information
  metaData.df <- seuratQCMergedCleanedDS@meta.data

  # Extract PCA embeddings
  pca_embeddings <- seuratQCMergedCleanedDS@reductions$pca@cell.embeddings

  clusterMat <- pca_embeddings
  clusterVect <- as.numeric(metaData.df$seurat_clusters)
  nClusters <- dim(table(metaData.df$seurat_clusters))

  # calculate clustering metrics
  daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
  calinskiHarabasz <- index.G1(clusterMat, clusterVect)
  silScore <- silhouette(clusterVect, dist(clusterMat))
  if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
    medianSilScore <- NaN
  } else {
    silScoreSummary <- summary(silScore)
    medianSilScore <- silScoreSummary$si.summary["Median"]
  }

  clusteringMetrics <- c("nClusters" = nClusters,
    "DBIndex" = daviesBouldinIdx$DB,
    "CHMetric" = calinskiHarabasz,
    "medianSilScore" = medianSilScore)
  return(clusteringMetrics)
}

# transpose the result
clusteringMetrics <- t(clusteringMetrics)

# adding the prediction error column
hyperParamGrid.df$DBIndex <- clusteringMetrics[, "DBIndex"]
hyperParamGrid.df$CHMetric <- clusteringMetrics[, "CHMetric"]
hyperParamGrid.df$medianSilScore <- clusteringMetrics[, "medianSilScore"]
hyperParamGrid.df$nClusters <- clusteringMetrics[, "nClusters"]

# stop cluster after we're done
parallel::stopCluster(cl = myCluster)

# scale the clustering metrics to fall between 0 and 1
hyperParamGrid.df$DBIndex <- (hyperParamGrid.df$DBIndex - min(hyperParamGrid.df$DBIndex, na.rm = TRUE)) /
  (max(hyperParamGrid.df$DBIndex, na.rm = TRUE) - min(hyperParamGrid.df$DBIndex, na.rm = TRUE))

hyperParamGrid.df$CHMetric <- (hyperParamGrid.df$CHMetric - min(hyperParamGrid.df$CHMetric, na.rm = TRUE)) /
  (max(hyperParamGrid.df$CHMetric, na.rm = TRUE) - min(hyperParamGrid.df$CHMetric, na.rm = TRUE))

hyperParamGrid.df$medianSilScore <- (hyperParamGrid.df$medianSilScore - min(hyperParamGrid.df$medianSilScore, na.rm = TRUE)) /
  (max(hyperParamGrid.df$medianSilScore, na.rm = TRUE) - min(hyperParamGrid.df$medianSilScore, na.rm = TRUE))

# make an inverse DB score so that it is more easily compared to the other two metrics
# (small DB is best, but large CH and silscore are best)
hyperParamGrid.df$DBIndexInverse <- 1 - hyperParamGrid.df$DBIndex

# create hyperParamGrid.df$meanEvalMetric, as the mean of $DBIndex, $CHMetric, $medianSilScore
hyperParamGrid.df$meanEvalMetric <- rowMeans(hyperParamGrid.df[, c("DBIndexInverse", "CHMetric", "medianSilScore")], na.rm = TRUE)

# sort and export the hyperparamgrid
hyperParamGrid.df <- hyperParamGrid.df %>%
  arrange(nClusters, desc(meanEvalMetric))

write.xlsx(hyperParamGrid.df, file = file.path(dataOutputDir, "20242017_RNA_clustering_hyperParamGrid.xlsx"))

# create a subset of hyperParamGrid.df with the best option for each nClusters
hyperParamGridOptSubset.df <- hyperParamGrid.df %>%
  group_by(nClusters) %>%
  filter(meanEvalMetric == max(meanEvalMetric)) %>%
  ungroup()

set.seed(6022)
seuratQCMergedCleanedDS <- FindNeighbors(seuratQCMergedCleanedDS, dims = 1:14) # 14
seuratQCMergedCleanedDS <- FindClusters(seuratQCMergedCleanedDS, resolution = 0.25) # 0.4)

set.seed(6022)
seuratQCMergedCleanedDS <- RunUMAP(object = seuratQCMergedCleanedDS, reduction = "pca",
  reduction.key = "test_",
  dims = 1:14,
  n.neighbors = 5, # 30
  min.dist = 0.6) # 0.1

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["RNA"]], "\\.", "p"))

# Add metadata to the Seurat object
seuratQCMergedCleanedDS <- seuratQCMergedCleanedDS %>%
  AddMetaData(Idents(seuratQCMergedCleanedDS), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratQCMergedCleanedDS) <- seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]

# Ensure data layers are joined
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratQCMergedCleanedDS, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])

palRNAClusters <-
  big_colorblind_pal(
    n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]),
    shuffle_colors = TRUE,
    drop_yellow = TRUE, drop_black = TRUE) %>%
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])

# Get the "ggsci::uniform_startrek" palette and adjust it
palRNAClusters <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))
```

```{r optRNAseqClusteringFunctionDraft}
# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS, layers = c("RNA"))
seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleanedDS <- NormalizeData(object = seuratQCMergedCleanedDS,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratQCMergedCleanedDS <- FindVariableFeatures(object = seuratQCMergedCleanedDS,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleanedDS <- ScaleData(object = seuratQCMergedCleanedDS, verbose = FALSE)
seuratQCMergedCleanedDS <- RunPCA(object = seuratQCMergedCleanedDS, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleanedDS, reduction = "pca")

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 7, 14, 16, 18, 20), # these values were chosen after examining the elbow plot.
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5) # these values were chosen somewhat arbitrarily
)

# the size of these vectors largely determines the cost of this function in walltime
min.dist.vector <-  c(0.1, 0.2) # c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
n_neighbors.vector <- c(5, 20) # c(5, 20, 30, 40, 50)

optimizeRNAseqClustering <- function(seuratObject, hyperParamGridPCA.df, min.dist.vector, n_neighbors.vector, maxNClusters = 10, minNClusters = 1) {
  # ------------------------------------------------INPUTS------------------------------------------------
  # seuratObject is... a seurat object
  # hyperParamGridPCA.df is an expanded grid for a full grid search for PCA clustering. type: dataframe
  # hyperParamGridUMAP.list is a list (of lists) of UMAP hyperparameters. type: list
  # min.dist.vector is a vector of min.dist values to pass to UMAP (via scDEED())
  # n_neighbors.vector is a vector of n_neighbors values to pass to UMAP (via scDEED())
  # maxNClusters is the maximum number of clusters to be considered (will evaluate 2 through maxNClusters)
  #-------------------------------------------------------------------------------------------------------

  #----------------------------------------------OUTPUTS--------------------------------------------------
  # result contains $hyperParamGridOptClusterAndUMAP.df and $hyperParamGridClusterOnly.df
  #   Extract like:
  #     hyperParamGridOptClusterAndUMAP.df <- result$hyperParamGridOptClusterAndUMAP.df (smaller output with opt PCA clustering and UMAP embedding params)
  #     hyperParamGridClusterOnly.df <- result$hyperParamGridClusterOnly.df (larger output with full PCA clustering gridsearch and results)
  #--------------------------------------------------------------------------------------------------------


  # STEP 1: grid search over FindNeighbors() and FindClusters() hyperparameters to find
  # the best combinations for each nClusters obtained

  # detect nuymber of cores, leave one available for the machine to do other things
  nCores <- parallel::detectCores() - 1

  # create the cluster for parallel computation
  myCluster <- parallel::makeCluster(
    nCores,
    type = "FORK"
  )

  # register it to be used by %dopar%
  doParallel::registerDoParallel(cl = myCluster)

  # Hyperparameter grid search
  clusteringMetrics <- foreach(
    findNeighborsDim = hyperParamGridPCA.df$findNeighborsDim,
    findClustersRes = hyperParamGridPCA.df$findClustersRes,
    .combine = "cbind"
  ) %dopar% {
    # do the UMAP clustering on the Seurat object
    set.seed(6022)
    seuratObject <- FindNeighbors(seuratObject, dims = 1:findNeighborsDim, verbose = FALSE)
    seuratObject <- FindClusters(seuratObject, resolution = findClustersRes, verbose = FALSE)

    # extract the cluster information
    metaData.df <- seuratObject@meta.data

    # Extract PCA embeddings
    pcaEmbeddings <- seuratObject@reductions$pca@cell.embeddings

    clusterMat <- pcaEmbeddings
    clusterVect <- as.numeric(metaData.df$seurat_clusters)
    nClusters <- dim(table(metaData.df$seurat_clusters))

    # calculate clustering metrics
    daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
    calinskiHarabasz <- index.G1(clusterMat, clusterVect)
    silScore <- silhouette(clusterVect, dist(clusterMat))
    if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
      medianSilScore <- NaN
    } else {
      silScoreSummary <- summary(silScore)
      medianSilScore <- silScoreSummary$si.summary["Median"]
    }

    clusteringMetrics <- c("nClusters" = nClusters,
      "DBIndex" = daviesBouldinIdx$DB,
      "CHMetric" = calinskiHarabasz,
      "medianSilScore" = medianSilScore)
    return(clusteringMetrics)
  }

  # transpose the result
  clusteringMetrics <- t(clusteringMetrics)

  # adding the prediction error column
  hyperParamGridPCA.df$DBIndex <- clusteringMetrics[, "DBIndex"]
  hyperParamGridPCA.df$CHMetric <- clusteringMetrics[, "CHMetric"]
  hyperParamGridPCA.df$medianSilScore <- clusteringMetrics[, "medianSilScore"]
  hyperParamGridPCA.df$nClusters <- clusteringMetrics[, "nClusters"]

  # stop cluster after we're done
  parallel::stopCluster(cl = myCluster)

  # scale the clustering metrics to fall between 0 and 1
  hyperParamGridPCA.df$DBIndex <- (hyperParamGridPCA.df$DBIndex - min(hyperParamGridPCA.df$DBIndex, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$DBIndex, na.rm = TRUE) - min(hyperParamGridPCA.df$DBIndex, na.rm = TRUE))

  hyperParamGridPCA.df$CHMetric <- (hyperParamGridPCA.df$CHMetric - min(hyperParamGridPCA.df$CHMetric, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$CHMetric, na.rm = TRUE) - min(hyperParamGridPCA.df$CHMetric, na.rm = TRUE))

  hyperParamGridPCA.df$medianSilScore <- (hyperParamGridPCA.df$medianSilScore - min(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE) - min(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE))

  # make an inverse DB score so that it is more easily compared to the other two metrics
  # (small DB is best, but large CH and silscore are best)
  hyperParamGridPCA.df$DBIndexInverse <- 1 - hyperParamGridPCA.df$DBIndex

  # create hyperParamGridPCA.df$meanEvalMetric, as the mean of $DBIndex, $CHMetric, $medianSilScore
  hyperParamGridPCA.df$meanEvalMetric <- rowMeans(hyperParamGridPCA.df[, c("DBIndexInverse", "CHMetric", "medianSilScore")], na.rm = TRUE)

  # sort and export (optional) the hyperparamgrid
  hyperParamGridPCA.df <- hyperParamGridPCA.df %>%
    arrange(nClusters, desc(meanEvalMetric))

  # TODO: wrap this in an if statement to print out a file if the user requests it with a true/false function parameter
  # write.xlsx(hyperParamGridPCA.df, file = file.path(dataOutputDir, "20242017_RNA_clustering_hyperParamGrid.xlsx"))

  # create a subset of hyperParamGridPCA.df with the best option for each nClusters
  hyperParamGridOptSubset.df <- hyperParamGridPCA.df %>%
    group_by(nClusters) %>%
    filter(meanEvalMetric == max(meanEvalMetric)) %>%
    ungroup()

  # Pre-allocate min.dist and n_neighbors columns with NA values
  hyperParamGridOptSubset.df$min.dist <- NA
  hyperParamGridOptSubset.df$n_neighbors <- NA

  # STEP 2: use scDEED to optimize the UMAP hyperparameters
  # ---------------------------start of scDEED UMAP opt---------------------------------------
  # if nrow(hyperParamGridOptSubset.df) is smaller than maxNClusters, then set maxNClusters to nrow(hyperParamGridOptSubset.df)
  if (nrow(hyperParamGridOptSubset.df) < maxNClusters) {
    maxNClusters <- nrow(hyperParamGridOptSubset.df)
  }

  # Loop over the rows of hyperParamGridOptSubset.df, finding the best UMAP embedding for each nClusters
  for (i in minNClusters:maxNClusters) {
    # Extract necessary values from hyperParamGridOptSubset.df
    nClusters <- hyperParamGridOptSubset.df$nClusters[i]
    numPCs <- hyperParamGridOptSubset.df$findNeighborsDim[i]
    findClustersRes <- hyperParamGridOptSubset.df$findClustersRes[i]

    set.seed(6022)
    seuratObject <- FindNeighbors(seuratObject, dims = 1:numPCs)
    seuratObject <- FindClusters(seuratObject, resolution = findClustersRes)

    scDEEDResult <- scDEED(seuratObject, # input Seurat object (must have UMAP or t-SNE already run)
      K = numPCs, # number of PCs
      reduction.method = "umap", # 'umap' or 'tsne'
      min.dist =  min.dist.vector, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
      n_neighbors = n_neighbors.vector, # scDEED defaults are c(5, 20, 30, 40, 50). Seurat default is 30.
      similarity_percent = 0.5, # scDEECD default
      dubious_cutoff = 0.05, # scDEED default
      trustworthy_cutoff = 0.95) # scDEED default

    # add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
    scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
    scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1

    # utile scDEED output
    optIdx <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells)) # find the result with the fewest 'dubiously' embedded cells
    # min.distOpt <- scDEEDResult$num_dubious$min.dist[optIdx]
    # n_neighborsOpt <- scDEEDResult$num_dubious$n_neighbors[optIdx]

    # just output the optimal hyperparams into hyperParamGridOptSubset.df
    hyperParamGridOptSubset.df$min.dist[i] <- scDEEDResult$num_dubious$min.dist[optIdx]
    hyperParamGridOptSubset.df$n_neighbors[i] <- scDEEDResult$num_dubious$n_neighbors[optIdx]
  }

  # Reorder columns to place min.dist and n_neighbors after findClustersRes
  hyperParamGridOptSubset.df <- hyperParamGridOptSubset.df %>%
    dplyr::select(findNeighborsDim, findClustersRes, min.dist, n_neighbors, everything())

  # Return the hyperparam dataframes
  return(list(hyperParamGridOptClusterAndUMAP.df = hyperParamGridOptSubset.df, hyperParamGridClusterOnly.df = hyperParamGridPCA.df))
}

# ---------------------chunk cut out of function for now (adds umap embeddings to meta.data)-------------------------------------------
# set.seed(6022)
# seuratObject <- RunUMAP(seuratObject,
#                         dims = 1:numPCs,
#                         min.dist = min.distOpt[1],
#                         n.neighbors = n_neighborsOpt[1])
# seed.use = 100)
#-------------------------------end of scDEED UMAP opt--------------------------------------------------------

# Note 20241205: commenting out this chunk in favor of just passing back the optimal params. The Seurat object can be reprocessed manually for each nCluster that we want to look at.
# # store cluster info in seurat object metadata
# # Initialize clusterName and clusterMarkers
# clusterName <- character()
# clusterMarkers <- list()

# # Create the cluster name for RNA
# clusterName <- paste0("seurat", as.character(nClusters), "Clusters")

# # Add metadata to the Seurat object
# seuratObject <- seuratObject %>%
#   AddMetaData(Idents(seuratObject), col.name = clusterName)

# # Set the identifiers
# Idents(seuratObject) <- seuratObject@meta.data[[clusterName]]

# # Ensure data layers are joined (note: tried moving this outside of the loop, and it broke everything. TODO: investigate)
# seuratObject <- JoinLayers(seuratObject)

# # Store the UMAP embeddings in the meta.data (we'll have to use ggplot rather than dimPlot and etc later.)
# # First extract the embeddings
# UMAPEmbeddings <- seuratObject@reductions$umap@cell.embeddings

# # Create dynamic column names for the UMAP coordinates
# colname_UMAP1 <- paste0("UMAP1_", nClusters, "Clusters")
# colname_UMAP2 <- paste0("UMAP2_", nClusters, "Clusters")

# # Store the UMAP coordinates in these columns
# seuratObject@meta.data[[colname_UMAP1]] <- UMAPEmbeddings[, 1]
# seuratObject@meta.data[[colname_UMAP2]] <- UMAPEmbeddings[, 2]
# ------------------------------------------------------------------------------------------------------------

# testing
seuratObject <- seuratTreg
startTime <- Sys.time()

result <- optimizeRNAseqClustering(seuratObject,
  hyperParamGridPCA.df,
  min.dist.vector,
  n_neighbors.vector,
  maxNClusters = 6)

endTime <- Sys.time()
timeElapsed <- endTime - startTime
print(timeElapsed)

# Extract the data frames from the result
hyperParamGridOptClusterAndUMAP.df <- result$hyperParamGridOptClusterAndUMAP.df
hyperParamGridClusterOnly.df <- result$hyperParamGridClusterOnly.df
```

```{r saveOptClusteringOutputs}
# save Treg Only files
write.xlsx(hyperParamGridClusterOnly.df, file.path(dataOutputDir, "20241205_RNAClusteringPCATregOnly.xlsx"))
write.xlsx(hyperParamGridOptClusterAndUMAP.df, file.path(dataOutputDir, "20241205_RNAClusteringPCAAndUMAPTregOnly.xlsx"))
```

```{r hierarchicalClusteringAnalysis}
# generate 5 cluster and 7 cluster options and then create tree diagrams or alluvial plots or similar

# set up dataframe of hyperparameters for different levels of clustering
# todo: clean up the hyperparam opt code sections so that these values get populated into a .csv automatically.
optHyperParams.df <- data.frame(
  nClust = c(3, 4, 5, 6, 7, 8, 9, 10),
  findNeighborsDim = c(20, 16, 16, 5, 14, 16, 5, 7),
  findNeighborsRes = c(0.05, 0.1, 0.2, 0.3, 0.25, 0.5, 0.5, 0.75),
  numUMAPDims = c(20, 16, 16, 5, 14, 16, 5, 7),
  numNeighborsUMAP = c(40, 5, 5, 5, 5, 5, 5, 5),
  minDist = c(0.2, 0.4, 0.4, 0.9, 0.6, 0.4, 0.9, 0.9)
)


seuratQCMergedCleanedDS5Clust.tmp <- seuratQCMergedCleanedDS
seuratQCMergedCleanedDS7Clust.tmp <- seuratQCMergedCleanedDS

seuratQCMergedCleanedDS5Clust.tmp <- FindNeighbors(seuratQCMergedCleanedDS5Clust.tmp, dims = 1:16)
seuratQCMergedCleanedDS5Clust.tmp <- FindClusters(seuratQCMergedCleanedDS5Clust.tmp, resolution = 0.2)

seuratQCMergedCleanedDS7Clust.tmp <- FindNeighbors(seuratQCMergedCleanedDS7Clust.tmp, dims = 1:14)
seuratQCMergedCleanedDS7Clust.tmp <- FindClusters(seuratQCMergedCleanedDS7Clust.tmp, resolution = 0.25)

set.seed(6022)
seuratQCMergedCleanedDS5Clust.tmp  <- RunUMAP(object = seuratQCMergedCleanedDS5Clust.tmp, reduction = "pca",
  dims = 1:16,
  n.neighbors = 5,
  min.dist = 0.4)

set.seed(6022)
seuratQCMergedCleanedDS7Clust.tmp <- RunUMAP(object = seuratQCMergedCleanedDS7Clust.tmp, reduction = "pca",
  dims = 1:14,
  n.neighbors = 5,
  min.dist = 0.8)

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", as.character())

# Add metadata to the Seurat object
seuratQCMergedCleanedDS <- seuratQCMergedCleanedDS %>%
  AddMetaData(Idents(seuratQCMergedCleanedDS), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratQCMergedCleanedDS) <- seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]

# Ensure data layers are joined
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratQCMergedCleanedDS, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])

palRNAClusters <-
  big_colorblind_pal(
    n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]]),
    shuffle_colors = TRUE,
    drop_yellow = TRUE, drop_black = TRUE) %>%
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])

# Get the "ggsci::uniform_startrek" palette and adjust it
palRNAClusters <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratQCMergedCleanedDS@meta.data[[clusterName[["RNA"]]]])))
```

```{r integration}
seuratQCMergedCleanedDSInteg <- JoinLayers(seuratQCMergedCleanedDS)
seuratQCMergedCleanedDSInteg[["RNA"]] <- split(seuratQCMergedCleanedDSInteg[["RNA"]], f = seuratQCMergedCleanedDSInteg$donorId)

# This will normalize and find variable features for each layer separately. A consensus set of variable features is automatically identified by Seurat
seuratQCMergedCleanedDSInteg <- NormalizeData(seuratQCMergedCleanedDSInteg)
seuratQCMergedCleanedDSInteg <- FindVariableFeatures(seuratQCMergedCleanedDSInteg)
seuratQCMergedCleanedDSInteg <- ScaleData(seuratQCMergedCleanedDSInteg)
seuratQCMergedCleanedDSInteg <- RunPCA(seuratQCMergedCleanedDSInteg)

seuratQCMergedCleanedDSInteg <- IntegrateLayers(
  object = seuratQCMergedCleanedDSInteg, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.rpca",
  verbose = FALSE
)
```

```{r scDEED}
# use scDEED to optimize the UMAP hyperparameters
K_ <- 14 # 14 # number of PCs

start_time.tmp <- Sys.time()

scDEEDResult <- scDEED(seuratQCMergedCleanedDS, # input Seurat object (must have UMAP or t-SNE already run)
  K = K_, # number of PCs
  reduction.method = "umap", # 'umap' or 'tsne'
  min.dist =  0.6, # c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), # 0.4, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
  n_neighbors = 5, # c(5, 20, 30, 40, 50), # 5, # c(5, 20, 30, 40, 50), #scDEED defaults. Seurat default is 30.
  similarity_percent = 0.5, # default
  dubious_cutoff = 0.05, # default
  trustworthy_cutoff = 0.95) # default

end_time.tmp <- Sys.time()

time_elapsed <- end_time.tmp - start_time.tmp
print(time_elapsed) # Time difference of 19.69495 mins

rm_tmp(ask = FALSE)

# add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1

# utilizing scDEED output
min(scDEEDResult$num_dubious$number_dubious_cells) # 437 # 26 with opt
opt <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells))
m <- scDEEDResult$num_dubious$min.dist[opt] # 0.1 # 0.3 #0.5
n <- scDEEDResult$num_dubious$n_neighbors[opt] # 30 (only value tested) # 5 #5

dubious_cells <- scDEEDResult$full_results$dubious_cells[opt]
dubious_cells <- as.numeric(strsplit(dubious_cells, ",")[[1]])
trustworthy_cells <- scDEEDResult$full_results$trustworthy_cells[opt]
trustworthy_cells <- as.numeric(strsplit(trustworthy_cells, ",")[[1]])
set.seed(6022)
SeuratUMAPscDEEDOpt <- RunUMAP(seuratQCMergedCleanedDS,
  dims = 1:K_,
  min.dist = m,
  n.neighbors = n)
# seed.use = 100)

# match up the dubious/trustworthy lists with the seurat data
rownames_seurat <- rownames(SeuratUMAPscDEEDOpt@meta.data)
rownames_dubious <- rownames_seurat[dubious_cells]
rownames_trustworthy <- rownames_seurat[trustworthy_cells]

designation <- rep("intermediate", length(rownames_seurat))

designation[rownames_seurat %in% rownames_dubious] <- "dubious"
designation[rownames_seurat %in% rownames_trustworthy] <- "trustworthy"

SeuratUMAPscDEEDOpt@meta.data$designation <- designation

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDoptUMAPdubiosityDS.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDOpt,
  reduction = "umap",
  # cells.highlight = list('dubious' = rownames_dubious, 'trustworthy' = rownames_trustworthy)) +
  group = "designation") +
  scale_color_manual(values = c("dubious" = "red", "intermediate" = "gray", "trustworthy" = "blue"))

dev.off()

rm_tmp(ask = FALSE)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDoptUMAPDS.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDOpt,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1)

dev.off()

rm_tmp(ask = FALSE)

# utilizing scDEED output (non-opt)
max(scDEEDResult$num_dubious$number_dubious_cells) # 453
opt <- which(scDEEDResult$num_dubious$number_dubious_cells == max(scDEEDResult$num_dubious$number_dubious_cells))
m <- scDEEDResult$num_dubious$min.dist[opt] # 0.4
n <- scDEEDResult$num_dubious$n_neighbors[opt] # 30 (only value tested)

dubious_cells <- scDEEDResult$full_results$dubious_cells[opt]
dubious_cells <- as.numeric(strsplit(dubious_cells, ",")[[1]])
trustworthy_cells <- scDEEDResult$full_results$trustworthy_cells[opt]
trustworthy_cells <- as.numeric(strsplit(trustworthy_cells, ",")[[1]])
set.seed(6022)
SeuratUMAPscDEEDNonOpt <- RunUMAP(seuratQCMergedCleanedDS,
  dims = 1:K_,
  min.dist = m,
  n.neighbors = n)
# seed.use = 100)

# match up the dubious/trustworthy lists with the seurat data
rownames_seurat <- rownames(SeuratUMAPscDEEDNonOpt@meta.data)
rownames_dubious <- rownames_seurat[dubious_cells]
rownames_trustworthy <- rownames_seurat[trustworthy_cells]

designation <- rep("intermediate", length(rownames_seurat))

designation[rownames_seurat %in% rownames_dubious] <- "dubious"
designation[rownames_seurat %in% rownames_trustworthy] <- "trustworthy"

SeuratUMAPscDEEDNonOpt@meta.data$designation <- designation

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDnonOptUMAPdubiosity.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDNonOpt,
  reduction = "umap",
  # cells.highlight = list('dubious' = rownames_dubious, 'trustworthy' = rownames_trustworthy)) +
  group = "designation") +
  scale_color_manual(values = c("dubious" = "red", "intermediate" = "gray", "trustworthy" = "blue"))

dev.off()

rm_tmp(ask = FALSE)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_scDEEDnonOptUMAP.pdf")),
height = 5.5,
width = 6)

DimPlot(object = SeuratUMAPscDEEDNonOpt,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1)

dev.off()

rm_tmp(ask = FALSE)
```

```{r lookAtClusters}

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_clusterFacet.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()
```

```{r lookAtClustersDS}

nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_downsampled.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_clusterFacet_downsampled.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seuratQCMergedCleanedDS@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seuratQCMergedCleanedDS@meta.data$seurat_clusters
umap_data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_stimulationFacet_downsampled.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = seurat_clusters)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r clusterProportionPlots}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratQCMergedCleanedDS@meta.data$studyGroup <- as.factor(seuratQCMergedCleanedDS@meta.data$studyGroup)
seuratQCMergedCleanedDS@meta.data$stimulationFigures <- as.factor(seuratQCMergedCleanedDS@meta.data$stimulationFigures)
seuratQCMergedCleanedDS@meta.data$donorIdFigures <- as.factor(seuratQCMergedCleanedDS@meta.data$donorIdFigures)
seuratQCMergedCleanedDS@meta.data$seurat_clusters <- as.factor(seuratQCMergedCleanedDS@meta.data$seurat_clusters)

# Extract metadata
metadata <- seuratQCMergedCleanedDS@meta.data

# Plot proportions of studyGroup in each seurat_clusters
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_studyGroup_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal()
dev.off()

# Plot proportions of stimulation in each seurat_clusters
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_stimulation_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  theme_minimal()
dev.off()

# Plot proportions of donorId in each seurat_clusters
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_donorId_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  theme_minimal()
dev.off()

# Plot proportions of donorId in each seurat_clusters, facet on stimulation
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Proportions_donorId_in_seurat_clusters.pdf")), height = 6, width = 10)
ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  facet_wrap(~stimulationFigures, ncol = 1) +
  theme_minimal()
dev.off()

# all together now
# Create the three plots
plot1 <- ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal()

plot2 <- ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal()

plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()

# all together now (POSTER
fontSize <- 14

# Create the three plots
plot1 <- ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot2 <- ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v", rel_heights = c(1, 1, 1.2))

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_poster.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()
```

```{r CITEseqMarkersPerCluster}
fb_data <- as.data.frame(t(as.matrix(seuratQCMergedCleanedDS@assays$FB@data)))

fb_data$seurat_clusters <- seuratQCMergedCleanedDS@meta.data$seurat_clusters

fb_data_long <- melt(fb_data, id.vars = "seurat_clusters", variable.name = "Feature", value.name = "Expression")

combined_plot <- ggplot(fb_data_long, aes(x = seurat_clusters, y = Expression, fill = seurat_clusters)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, size = 0.5, alpha = 0.5) +
  facet_wrap(~Feature, scales = "free_y") +
  labs(x = "Seurat Clusters", y = "Expression", title = "Boxplots of FB Features per Seurat Clusters") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

pdf(file.path(plotDir, paste0(filenameSuffix, "_Boxplots_FB_per_seurat_clusters.pdf")), height = 7, width = 12)
print(combined_plot)
dev.off()
```

```{r getTop10ClusterDefiningGenesDownsampled}
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
Idents(seuratQCMergedCleanedDS) <- "seurat_clusters"
# Join the data layers
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

clusterMarkers <- FindAllMarkers(seuratQCMergedCleanedDS)

# implement a filter so that we only consider genes expressed in a certain percentage of cells
# Calculate the percentage of cells with non-zero expression for each gene in each cluster
expressionData <- FetchData(seuratQCMergedCleanedDS, vars = unique(clusterMarkers$gene))
metadata <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::select(seurat_clusters) %>%
  rownames_to_column("cell")

expressionData <- expressionData %>%
  rownames_to_column("cell") %>%
  left_join(metadata, by = "cell")

expressionDataLong <- expressionData %>%
  pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

expressionDataSummary <- expressionDataLong %>%
  group_by(seurat_clusters, gene) %>%
  summarise(percent_expressed = mean(expression > 0) * 100)

min_percent_expressed <- 30
clusterMarkers <- clusterMarkers %>%
  left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
  filter(percent_expressed >= min_percent_expressed)
# end of expressed in x% of cells filtering


topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = 10) %>%
  dplyr::slice_min(p_val_adj, n = 10) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters)) # , each = 4

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

# write.csv(topMarkers, file.path(dataOutputDir, "top10_genes_per_cluster_downsampled.csv"), quote = FALSE, row.names = TRUE)
```

```{r clusterDefiningGenesDotPlot}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 12

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
dot_plot <- DotPlot(seuratQCMergedCleanedDS, features = genes.tmp) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
    text = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Print the DotPlot
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_clusterDefiningGenesDotPlot.pdf")), height = 5, width = 12)
print(dot_plot)
dev.off()

rm_tmp(ask = FALSE)
```

```{r calculateDiversityMetricsForClusterDefiningGenes}
library(vegan)
# Ensure the correct assay and identity class are set
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
Idents(seuratQCMergedCleanedDS) <- "seurat_clusters"

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Check if the genes are present in the dataset
genes_present <- genes.tmp %in% rownames(seuratQCMergedCleanedDS)

# Print the genes that are not found in the dataset
print(genes.tmp[!genes_present])

# Filter out the genes that are not present in the dataset
genes.tmp <- genes.tmp[genes_present]

# Calculate the mean expression of each gene in each cluster
mean_expression <- AverageExpression(seuratQCMergedCleanedDS, features = genes.tmp, assays = "RNA")

# Convert the mean expression data to a data frame
mean_expression_df <- as.data.frame(mean_expression$RNA)

# Calculate the Bray-Curtis dissimilarity between clusters
bray_curtis_dissimilarity <- vegdist(t(mean_expression_df), method = "bray")

# Convert the Bray-Curtis dissimilarity object to a matrix
bray_curtis_matrix <- as.matrix(bray_curtis_dissimilarity)

# Extract the off-diagonal elements
off_diagonal_elements <- bray_curtis_matrix[upper.tri(bray_curtis_matrix)]
rownames(bray_curtis_matrix) <- gsub("g", "cluster ", rownames(bray_curtis_matrix))
colnames(bray_curtis_matrix) <- gsub("g", "cluster ", colnames(bray_curtis_matrix))

# Calculate the mean of the off-diagonal elements
meanBrayCurtis <- mean(off_diagonal_elements)
meanBrayCurtis <- round(meanBrayCurtis, digits = 3)


columnTitleString <- paste0("Mean Bray-Curtis Dissimilarity = ", as.character(meanBrayCurtis))

# Create a heatmap from the Bray-Curtis dissimilarity matrix using ComplexHeatmap
BCHeatmap.tmp <- Heatmap(bray_curtis_matrix,
  name = "Bray-Curtis \nDissimilarity",
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_dend = TRUE,
  show_column_dend = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  column_title = columnTitleString)

# Print the heatmap
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_clusterBrayCurtisHeatmap.pdf")), height = 5, width = 6)
print(BCHeatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```
```{r getTop50ClusterDefiningGenesDownsampled}
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
Idents(seuratQCMergedCleanedDS) <- "seurat_clusters"
# Join the data layers
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

clusterMarkers <- FindAllMarkers(seuratQCMergedCleanedDS)

topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = 50) %>%
  dplyr::slice_min(p_val_adj, n = 50) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters))

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataOutputDir, "top50_cluster_defining_genes_per_cluster_downsampled.csv"), quote = FALSE, row.names = TRUE)

top50Markers <- topMarkers
```

```{r getAllClusterDefiningGenesDownsampled}
DefaultAssay(seuratQCMergedCleanedDS) <- "RNA"
Idents(seuratQCMergedCleanedDS) <- "seurat_clusters"
# Join the data layers
seuratQCMergedCleanedDS <- JoinLayers(seuratQCMergedCleanedDS)

clusterMarkers <- FindAllMarkers(seuratQCMergedCleanedDS)

topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters))

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataOutputDir, "cluster_defining_genes_per_cluster_downsampled.csv"), quote = FALSE, row.names = TRUE)
```

```{r setHTAsColumnDS}
# Fetch the data from the "HT" assay
ht_data <- seuratQCMergedCleanedDS[["HT"]]@data

# Get the names of the HT assay for each cell
ht_names <- colnames(ht_data)

# Add the HT names to the metadata
seuratQCMergedCleanedDS[["HT_names"]] <- ht_names

# Fetch the data from the "HT" assay
ht_data <- seuratQCMergedCleaned[["HT"]]@data

# Get the names of the HT assay for each cell
ht_names <- colnames(ht_data)

# Add the HT names to the metadata
seuratQCMergedCleaned[["HT_names"]] <- ht_names
```

```{r defineGenesOfInterestTregTconv}
genesOfInterest <- c("LDHB", "FABP5", "MYO1B", "ACSL6", "FZD3", "FASLG",
  "SPRY1", "UBE2E2", "RGCC", "TNFSF11", "ZNF704", "RAI2",
  "TTC8", "IL2", "DHRS3", "NELL2", "MAMLD1", "MAP7",
  "ARMH1", "IL3", "CSF2", "XCL1", "LRRN3", "FHL1",
  "RRAGD", "ADORA2B", "CNN3", "JAK1", "FTL", "CTLA4",
  "SYTL3", "ZNF292", "CHST11", "IL2RA", "PICALM", "IL2RB",
  "GNG2", "IL32", "CD74", "CD74", "ARL6IP5", "TIGIT",
  "IKZF2", "CTTNBP2NL", "FUT7", "MAN1A2", "ENTPD1", "LRRC32",
  "CCR8", "HLA-DQA1", "HLA-DRB1", "HLA-DRB5", "HLA-DQA2", "IL1R2",
  "FOXP3", "IL1R1", "CISH", "TXN", "TNFRSF18", "TPMT",
  "SFT2D1")

genesOfInterestTreg <- c("JAK1", "FTL", "CTLA4",
  "SYTL3", "ZNF292", "CHST11", "IL2RA", "PICALM", "IL2RB",
  "GNG2", "IL32", "CD74", "CD74", "ARL6IP5", "TIGIT",
  "IKZF2", "CTTNBP2NL", "FUT7", "MAN1A2", "ENTPD1", "LRRC32",
  "CCR8", "HLA-DQA1", "HLA-DRB1", "HLA-DRB5", "HLA-DQA2", "IL1R2",
  "FOXP3", "IL1R1", "CISH", "TXN", "TNFRSF18", "TPMT",
  "SFT2D1")

genesOfInterestTconv <- c("LDHB", "FABP5", "MYO1B", "ACSL6", "FZD3", "FASLG",
  "SPRY1", "UBE2E2", "RGCC", "TNFSF11", "ZNF704", "RAI2",
  "TTC8", "IL2", "DHRS3", "NELL2", "MAMLD1", "MAP7",
  "ARMH1", "IL3", "CSF2", "XCL1", "LRRN3", "FHL1",
  "RRAGD", "ADORA2B", "CNN3")
```

```{r TregTconvHeatmap}
## Fetch data for genes of interest
heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, genesOfInterest)
heatmapCounts.tmp <- t(heatmapCounts.tmp)

# Ensure metadata order matches data columns
hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ]
sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # Check ordering

# Arrange metadata by clusters
hMapAnno.tmp <- hMapAnno.tmp %>%
  dplyr::arrange(seurat_clusters)

# Reorder columns of heatmapCounts.tmp to match metadata
heatmapCounts.tmp <- heatmapCounts.tmp[, hMapAnno.tmp$HT_names]

# Scale the rows via z-score
heatmapCounts.tmp <- t(scale(t(heatmapCounts.tmp)))

# Reorder rows to group Treg and Tconv genes
genesOfInterestOrdered <- c(genesOfInterestTreg, genesOfInterestTconv)
heatmapCounts.tmp <- heatmapCounts.tmp[genesOfInterestOrdered, ]

# Create a vector indicating the group of each gene
row_split <- c(rep("Treg", length(genesOfInterestTreg)), rep("Tconv", length(genesOfInterestTconv)))

# Define custom color scale with white at 0
col_fun <- colorRamp2(c(-2, 0, 4), c("blue", "white", "red"))

# Generate heatmap with columns grouped by studygroup within each cluster
columnAnno.tmp <- HeatmapAnnotation(stimulationFigures = hMapAnno.tmp$stimulationFigures,
  cluster = hMapAnno.tmp$seurat_clusters,
  col = list(stimulationFigures = palStimulation,
    cluster = palRNAClusters))

heatmap.tmp <- Heatmap(heatmapCounts.tmp,
  top_annotation = columnAnno.tmp,
  name = "gene expr. (z-score)",
  col = col_fun,
  cluster_columns = F,
  show_column_names = F,
  row_names_gp = grid::gpar(fontsize = 8),
  row_split = row_split)  # Add row split to separate Treg and Tconv genes

# Save the heatmap to a PDF file
pdf(
  file = file.path(plotDir, paste0("TregTconvGenesHeatmap.", filenameSuffix, ".pdf")),
  width = 6, height = 6)

print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r top10ClusterDefiningGenesHeatmap}
# Average top marker expr by cluster.
nGenes <- 10

clusterMarkers.tmp <- FindAllMarkers(seuratQCMergedCleanedDS)

topMarkersHmap.tmp <- clusterMarkers.tmp %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>% # means up in this cluster relative to everything else
  dplyr::slice_max(avg_log2FC, n = nGenes) %>%
  dplyr::slice_min(p_val_adj, n = nGenes) %>%
  dplyr::mutate(fc_order = order(avg_log2FC)) # ordered high to low

selectedFeatures.tmp <- unique(topMarkersHmap.tmp$gene)

heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, selectedFeatures.tmp)
heatmapCounts.tmp <- t(heatmapCounts.tmp)
# heatmapCounts.tmp <- scale(t(heatmapCounts.tmp))
# heatmapCounts.tmp <- t(scale(log10(heatmapCounts.tmp + 0.5)))
# heatmapCounts.tmp <- t(log10(heatmapCounts.tmp + 0.5))
hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ] # make the orders match
sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # check to make sure the ordering is correct

hMapAnno.tmp <- hMapAnno.tmp %>%
  dplyr::arrange(seurat_clusters)

heatmapCounts.tmp <- heatmapCounts.tmp[, hMapAnno.tmp$HT_names]
# generate a heatmap with columns grouped by studygroup within each cluster

columnAnno.tmp <- HeatmapAnnotation(stimulationFigures = hMapAnno.tmp$stimulationFigures,
  cluster = hMapAnno.tmp$seurat_clusters,
  col = list(stimulationFigures = palStimulation,
    cluster = palRNAClusters))

heatmap.tmp <- Heatmap(heatmapCounts.tmp,
  top_annotation = columnAnno.tmp,
  name = "log10(gene expr.) (z-score)",
  cluster_columns = F,
  show_column_names = F,
  row_names_gp = grid::gpar(fontsize = 8))

pdf(
  file =
    file.path(
      plotDir,
      paste0("top10ClusterDefiningGenesHeatmap.", filenameSuffix, ".pdf")),
  width = 10, height = 7)

print(heatmap.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r clusterDefiningGenesHeatmaps}
# Average top marker expr by cluster.
nGenes <- 50

# Loop through clusters 0 to 8
for (clusterOfInterest.tmp in 0:6) {

  clusterMarkers.tmp <- FindAllMarkers(seuratQCMergedCleanedDS)

  topMarkersHmap.tmp <- clusterMarkers.tmp %>%
    dplyr::filter(cluster == clusterOfInterest.tmp) %>%  # Restrict to current cluster
    dplyr::filter(avg_log2FC > 0) %>% # means up in this cluster relative to everything else
    dplyr::slice_max(avg_log2FC, n = nGenes) %>%
    dplyr::slice_min(p_val_adj, n = nGenes) %>%
    dplyr::mutate(fc_order = order(avg_log2FC))

  selectedFeatures.tmp <- unique(topMarkersHmap.tmp$gene)

  heatmapCounts.tmp <- FetchData(seuratQCMergedCleanedDS, selectedFeatures.tmp)
  # heatmapCounts.tmp <- scale(t(heatmapCounts.tmp))
  # heatmapCounts.tmp <- t(scale(heatmapCounts.tmp))
  heatmapCounts.tmp <- t(heatmapCounts.tmp)
  hMapAnno.tmp <- seuratQCMergedCleanedDS@meta.data
  hMapAnno.tmp <- hMapAnno.tmp[match(colnames(heatmapCounts.tmp), hMapAnno.tmp$HT_names), ] # make the orders match
  sum(hMapAnno.tmp$HT_names != colnames(heatmapCounts.tmp)) # check to make sure the ordering is correct

  hMapAnno.tmp <- hMapAnno.tmp %>%
    dplyr::arrange(seurat_clusters)

  heatmapCounts.tmp <- heatmapCounts.tmp[, hMapAnno.tmp$HT_names]
  # generate a heatmap with columns grouped by studygroup within each cluster

  columnAnno.tmp <- HeatmapAnnotation(stimulationFigures = hMapAnno.tmp$stimulationFigures,
    cluster = hMapAnno.tmp$seurat_clusters,
    col = list(stimulationFigures = palStimulation,
      cluster = palRNAClusters))

  heatmap.tmp <- Heatmap(heatmapCounts.tmp,
    top_annotation = columnAnno.tmp,
    name = "gene expr. (z-score)",
    cluster_columns = F,
    show_column_names = F,
    row_names_gp = grid::gpar(fontsize = 8))

  pdf(
    file =
      file.path(
        plotDir,
        paste0("top50Cluster", clusterOfInterest.tmp, "DefiningGenesHeatmap.", filenameSuffix, ".pdf")),
    width = 10, height = 7)

  print(heatmap.tmp)

  dev.off()
}

rm_tmp(ask = FALSE)
```

```{r defineGeneOfInterestPlotFunction}
plotGenesOfInterest <- function(seuratObject, geneList, fileName, nCols = 2) {
  pdf(
    file =
      file.path(
        plotDir,
        paste0(fileName, filenameSuffix, ".pdf")),
    width = 6, height = 5)

  genesOfInterestPlot <- FeaturePlot(object = seuratObject,
    reduction = "umap",
    feature = geneList,
    ncol = nCols,
    order = T) &
    labs(x = "UMAP 1", y = "UMAP 2") &
    theme(aspect.ratio = 1)

  print(genesOfInterestPlot)
  dev.off()
}
```

```{r genesOfInterestOnUMAP_wFunction}
# prints out a separate expression UMAP for each gene in genesOfInterest
for (gene in genesOfInterest) {
  plotGenesOfInterest(
    seuratQCMergedCleanedDS,
    gene,
    paste0("seuratUMAP_", gene),
    nCols = 1
  )
}
```

```{r genesOfInterestOnUMAP_TregModuleExpression}
# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTreg)
)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTregExpressionOnUMAP", filenameSuffix, ".pdf")),
  width = 6, height = 5)

# Plot the UMAP with the mean expression of genesOfInterestTreg
TregUMAP.plt.tmp <- FeaturePlot(
  seuratQCMergedCleanedDS,
  features = "meanExpressionTreg",
  reduction = "umap"
) + ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean expression \nZ-score")

print(TregUMAP.plt.tmp)
dev.off()
rm_tmp(ask = FALSE)
```

```{r genesOfInterestOnUMAP_TregModuleExpression_stimulationFacet}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTreg)
)

# Extract UMAP coordinates and mean expression data
umap_data.tmp <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
umap_data.tmp$meanExpressionTreg <- FetchData(seuratQCMergedCleanedDS, "meanExpressionTreg")$meanExpressionTreg
umap_data.tmp$stimulationFigures <- as.factor(seuratQCMergedCleanedDS$stimulationFigures)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTregExpressionOnUMAPStimulationFacet", nClustString, filenameSuffix, ".pdf")),
  width = 12, height = 3)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTreg)) +
  geom_point(size = 1) +
  ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean expression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() +
  theme_minimal()

print(TregUMAP.plt.tmp)
dev.off()

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTregExpressionOnUMAPStimulationFacetPoster", nClustString, filenameSuffix, ".pdf")),
  width = 10, height = 3.5)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTreg)) +
  geom_point(size = 1) +
  # ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean \nTreg gene \nexpression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() + # scale_color_gradient(low = "lightgrey", high = "blue") +
  theme_minimal() +
  theme(
    text = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16),
    plot.title = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(TregUMAP.plt.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r meanExpressionTregHistogram}
# generate a histogram of meanExpressionTreg

# Calculate the mean expression of the genes in genesOfInterestTreg for all cells
seuratQCMergedCleaned$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTreg)
)

# Calculate the 75th percentile of meanExpressionTreg
percentile_75_Treg <- quantile(seuratQCMergedCleaned$meanExpressionTreg, 0.75, na.rm = TRUE)

# Generate a histogram of meanExpressionTreg with a vertical line at the 75th percentile
histogramPlot.tmp <- ggplot(data.frame(meanExpressionTreg = seuratQCMergedCleaned$meanExpressionTreg), aes(x = meanExpressionTreg)) +
  geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) +
  geom_vline(aes(xintercept = percentile_75_Tconv), color = "red", linetype = "dashed", size = 1) +
  labs(title = "Histogram of meanExpressionTreg",
    x = "Mean Expression Treg",
    y = "Frequency") +
  theme_minimal()

# Start PDF printing
pdf(file.path(plotDir, paste0(filenameSuffix, "meanExpressionTreg_Histogram.pdf")),
  height = 5,
  width = 7)

# Print the histogram
print(histogramPlot.tmp)

# Close the PDF device
dev.off()

# rm_tmp(ask = FALSE)
```

```{r meanExpressionTconvHistogram}
# generate a histogram of meanExpressionTreg

# Calculate the mean expression of the genes in genesOfInterestTreg for all cells
seuratQCMergedCleaned$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTconv)
)

# Calculate the 75th percentile of meanExpressionTconv
percentile_75_Tconv <- quantile(seuratQCMergedCleaned$meanExpressionTconv, 0.75, na.rm = TRUE)

# Generate a histogram of meanExpressionTconv with a vertical line at the 75th percentile
histogramPlot.tmp <- ggplot(data.frame(meanExpressionTconv = seuratQCMergedCleaned$meanExpressionTconv), aes(x = meanExpressionTconv)) +
  geom_histogram(binwidth = 0.05, fill = "blue", color = "black", alpha = 0.7) +
  geom_vline(aes(xintercept = percentile_75_Tconv), color = "red", linetype = "dashed", size = 1) +
  labs(title = "Histogram of meanExpressionTconv",
    x = "Mean Expression Tconv",
    y = "Frequency") +
  theme_minimal()

# Start PDF printing
pdf(file.path(plotDir, paste0(filenameSuffix, "meanExpressionTconv_Histogram.pdf")),
  height = 5,
  width = 7)

# Print the histogram
print(histogramPlot.tmp)

# Close the PDF device
dev.off()

# rm_tmp(ask = FALSE)
```

```{r addP390ModuleCallingToSeurat}
# Calculate the mean expression of the genes in genesOfInterestTreg for all cells
seuratQCMergedCleaned$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTreg)
)

seuratQCMergedCleanedDS$meanExpressionTreg <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTreg)
)

# Calculate the mean expression of the genes in genesOfInterestTconv for all cells
seuratQCMergedCleaned$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTconv)
)

seuratQCMergedCleanedDS$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleaned, vars = genesOfInterestTconv)
)

# Calculate the 75th percentiles
percentile_75_Treg <- quantile(seuratQCMergedCleaned$meanExpressionTreg, 0.50, na.rm = TRUE)
percentile_75_Tconv <- quantile(seuratQCMergedCleaned$meanExpressionTconv, 0.50, na.rm = TRUE)

# Add a new column for cell type based on the specified conditions
seuratQCMergedCleaned$cellTypeP390 <- "Other"
seuratQCMergedCleaned$cellTypeP390[seuratQCMergedCleaned$meanExpressionTreg > percentile_75_Treg & seuratQCMergedCleaned$meanExpressionTconv > percentile_75_Tconv] <- "Both"
seuratQCMergedCleaned$cellTypeP390[seuratQCMergedCleaned$meanExpressionTreg > percentile_75_Treg & seuratQCMergedCleaned$meanExpressionTconv <= percentile_75_Tconv] <- "Treg"
seuratQCMergedCleaned$cellTypeP390[seuratQCMergedCleaned$meanExpressionTreg <= percentile_75_Treg & seuratQCMergedCleaned$meanExpressionTconv > percentile_75_Tconv] <- "Tconv"

# Verify the new column
table(seuratQCMergedCleaned$cellTypeP390)


# Calculate the mean expression of the genes in genesOfInterestTreg for downsampled object (TODO, move this all above downsampling)

# Add a new column for cell type based on the specified conditions
seuratQCMergedCleanedDS$cellTypeP390 <- "Other"
seuratQCMergedCleanedDS$cellTypeP390[seuratQCMergedCleanedDS$meanExpressionTreg > percentile_75_Treg & seuratQCMergedCleanedDS$meanExpressionTconv > percentile_75_Tconv] <- "Both"
seuratQCMergedCleanedDS$cellTypeP390[seuratQCMergedCleanedDS$meanExpressionTreg > percentile_75_Treg & seuratQCMergedCleanedDS$meanExpressionTconv <= percentile_75_Tconv] <- "Treg"
seuratQCMergedCleanedDS$cellTypeP390[seuratQCMergedCleanedDS$meanExpressionTreg <= percentile_75_Treg & seuratQCMergedCleanedDS$meanExpressionTconv > percentile_75_Tconv] <- "Tconv"

# Verify the new column
table(seuratQCMergedCleanedDS$cellTypeP390)
```

```{r genesOfInterestOnUMAP_TconvModuleExpression}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTconv)
)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTconvExpressionOnUMAP", nClustString, filenameSuffix, ".pdf")),
  width = 6, height = 5)

# Plot the UMAP with the mean expression of genesOfInterestTreg
TregUMAP.plt.tmp <- FeaturePlot(
  seuratQCMergedCleanedDS,
  features = "meanExpressionTconv",
  reduction = "umap"
) + ggtitle("Mean Expression of Tconv Genes") +
  labs(color = "Mean expression")

print(TregUMAP.plt.tmp)
dev.off()
rm_tmp(ask = FALSE)
```


```{r genesOfInterestOnUMAP_TconvModuleExpression_stimulationFacet}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Calculate the mean expression of the genes in genesOfInterestTreg
seuratQCMergedCleanedDS$meanExpressionTconv <- rowMeans(
  FetchData(seuratQCMergedCleanedDS, vars = genesOfInterestTconv)
)

# Extract UMAP coordinates and mean expression data
umap_data.tmp <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
umap_data.tmp$meanExpressionTconv <- FetchData(seuratQCMergedCleanedDS, "meanExpressionTconv")$meanExpressionTconv
umap_data.tmp$stimulationFigures <- as.factor(seuratQCMergedCleanedDS$stimulationFigures)

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTconvExpressionOnUMAPStimulationFacet", nClustString, filenameSuffix, ".pdf")),
  width = 12, height = 3)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTconv)) +
  geom_point(size = 1) +
  ggtitle("Mean Expression of Tconv Genes") +
  labs(color = "Mean expression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() +
  theme_minimal()

print(TregUMAP.plt.tmp)
dev.off()

# start the pdf printing stuff
pdf(
  file =
    file.path(
      plotDir,
      paste0("meanTconvExpressionOnUMAPStimulationFacetPoster", nClustString, filenameSuffix, ".pdf")),
  width = 10, height = 3.5)


# Create the plot using ggplot2
TregUMAP.plt.tmp <- ggplot(umap_data.tmp, aes(x = umap_1, y = umap_2, color = meanExpressionTconv)) +
  geom_point(size = 1) +
  # ggtitle("Mean Expression of Treg Genes") +
  labs(color = "Mean \nTconv gene \nexpression") +
  facet_wrap(~stimulationFigures) +
  scale_color_viridis_c() + # scale_color_gradient(low = "lightgrey", high = "blue") +
  theme_minimal() +
  theme(
    text = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    strip.text = element_text(size = 16),
    plot.title = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

print(TregUMAP.plt.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r showHashtagsOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()
```

```{r showHashtagsOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Hashtag", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()
```

```{r showDonorIDOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "donorId",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_Facet.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "donorId",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~donorId)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_clusterFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleaned, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleaned@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = donorId)) +
  geom_point(size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Donor ID", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters) # Now using the combined data

print(p)
dev.off()
```

```{r showDonorIDOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "donorIdFigures",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_FacetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "donorIdFigures",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~donorIdFigures)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_clusterFacetDS.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleanedDS@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = donorIdFigures)) +
  geom_point(size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Donor ID", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters) # Now using the combined data

print(p)
dev.off()
```

```{r showstemnessScoreOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScoreDS.pdf")),
height = 6,
width = 12)

FeaturePlot(object = seuratQCMergedCleanedDS,
  features = "stemnessScore",
  reduction = "umap",
  pt.size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1)
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScore_FacetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "donorIdFigures",
  pt.size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~donorIdFigures)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_donorIDLabel_clusterFacetDS.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleanedDS@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = donorIdFigures)) +
  geom_point(size = 1) +
  scale_color_manual(values = palDonorId) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Donor ID", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters) # Now using the combined data

print(p)
dev.off()
```

```{r showCellTypistCallingOnUMAPDS}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_celltypistLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "cellTypistCalling",
  pt.size = 1) +
  scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "donorId", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_UMAP_RNA_cellTypistLabel_stimulationFacet.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratQCMergedCleanedDS@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellTypistCalling)) +
  geom_point(size = 1) +
  scale_color_manual(values = palCellTypist) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "cellTypistCalling", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()
```

```{r cellTypistVsP390}
# Extract the relevant metadata
meta_data <- seuratQCMergedCleanedDS@meta.data

# Create a long format data frame for ggplot2
long_data <- meta_data %>%
  dplyr::select(cellTypistCalling, meanExpressionTreg, meanExpressionTconv) %>%
  pivot_longer(cols = c(meanExpressionTreg, meanExpressionTconv),
    names_to = "ExpressionType",
    values_to = "ExpressionValue")

pdf(file.path(plotDir,
  paste0(filenameSuffix, "P390ModulesCellTypistBoxPlots.pdf")),
height = 6,
width = 12)
# Create boxplots with points displayed
boxplot.tmp <- ggplot(long_data, aes(x = cellTypistCalling, y = ExpressionValue, color = ExpressionType)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  labs(title = "Mean Treg and Tconv Expression by Cell Typist Calling",
    x = "Cell Typist Calling",
    y = "Mean Expression",
    color = "Expression Type") +
  theme_minimal() +
  theme(text = element_text(size = 16))

print(boxplot.tmp)
dev.off()
```

```{r plotPropCellsPerClusterDataQcCd4ByDonorId from MattD}
propCellsPerClusterseuratByDonorId <-
  seuratQCMergedCleaned@meta.data %>%
  dplyr::count(donorIdFigures, studyGroup, !!rlang::sym(clusterName[["RNA"]])) %>%
  tidyr::complete(
    tidyr::expand(., nesting(donorIdFigures, studyGroup), !!rlang::sym(clusterName[["RNA"]])),
    fill = list(n = 0)) %>%
  group_by(donorIdFigures) %>%
  mutate(
    nTotal = sum(n),
    prop = n / nTotal) %>%
  ungroup()

plot.tmp <-
  propCellsPerClusterseuratByDonorId %>%
  ggplot(mapping = aes(x = studyGroup, y = prop, color = studyGroup)) +
  geom_beeswarm(size = 3, cex = 3, groupOnX = TRUE) +
  scale_color_manual(values = palStudyGroup) +
  guides(color = "none") +
  labs(x = NULL, y = "Proportion of CD4 cells in cluster") +
  facet_wrap(vars(!!rlang::sym(clusterName[["rnaCD4"]]))) +
  theme(axis.text.x = element_text(hjust = 0, angle = -45, size = 14),
    plot.margin = margin(t = 10, r = 60, b = 10, l = 10))

pdf(
  file.path(
    plotDir,
    paste0("plotPropCellsPerClusterseuratByDonorId.", filenameSuffix, ".pdf")),
  w = 10, h = 7)
print(plot.tmp)
invisible(dev.off())

rm_tmp(ask = FALSE)
```

```{r showCITEseqOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Save the original default assay
original_default_assay <- DefaultAssay(seuratQCMergedCleaned)

# Set the default assay to 'FB'
DefaultAssay(seuratQCMergedCleaned) <- "FB"

# Define the markers you want to plot
markers <- rownames(seuratQCMergedCleaned@assays$FB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_HTLabel_", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratQCMergedCleaned,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# Reset the default assay to its original
DefaultAssay(seuratQCMergedCleaned) <- original_default_assay
```

```{r showCITEseqOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_HTLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "htDemux",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# Save the original default assay
original_default_assay <- DefaultAssay(seuratQCMergedCleanedDS)

# Set the default assay to 'FB'
DefaultAssay(seuratQCMergedCleanedDS) <- "FB"

# Define the markers you want to plot
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_HTLabel_", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratQCMergedCleanedDS,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# Reset the default assay to its original
DefaultAssay(seuratQCMergedCleanedDS) <- original_default_assay
```

```{r showCITEseqOnUMAPDS_DSB}

# Save the original default assay
original_default_assay <- DefaultAssay(seuratQCMergedCleanedDS)

# Set the default assay to 'FB'
DefaultAssay(seuratQCMergedCleanedDS) <- "DSB"

# Define the markers you want to plot
markers <- rownames(seuratQCMergedCleanedDS@assays$DSB@data)

# Loop through each marker and create a UMAP plot
for (marker in markers) {
  pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_HTLabel_DSB", marker, ".pdf")), height = 6, width = 12)

  # Generate UMAP plot colored by expression of the current marker
  p <- FeaturePlot(object = seuratQCMergedCleanedDS,
    features = marker,
    reduction = "umap",
    pt.size = 1) +
    scale_color_viridis_c() +
    labs(x = "UMAP 1", y = "UMAP 2", color = marker, title = paste("Expression of", marker)) +
    theme(aspect.ratio = 1)

  print(p)
  dev.off()
}

# Reset the default assay to its original
DefaultAssay(seuratQCMergedCleanedDS) <- original_default_assay
```

```{r CD45RACD45ROScatterPlots}
# Extract the expression data for anti-human CD45RO and anti-human CD45RA
CD45ROExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RO", assay = "FB")
CD45RAExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RA", assay = "FB")

# Extract the metadata for stimulationFigures
stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Combine the expression data and metadata into a data frame
expressionData <- data.frame(
  CD45RO = CD45ROExpression$`fb_anti-human CD45RO`,
  CD45RA = CD45RAExpression$`fb_anti-human CD45RA`,
  stimulationFigures = stimulationFigures
)


pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlot.pdf")), height = 6, width = 12)

# Create the scatterplot
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16))

print(scatterPlot.tmp)
dev.off()

pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlotStimulationFacet.pdf")), height = 6, width = 12)

# Create the scatterplot with best fit line, CI, R value, and facet wrap by stimulationFigures
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16)) +
  facet_wrap(~stimulationFigures)

print(scatterPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r CD45RACD45ROScatterPlotsDSB}
# Extract the expression data for anti-human CD45RO and anti-human CD45RA
CD45ROExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RO", assay = "DSB")
CD45RAExpression <- FetchData(seuratQCMergedCleanedDS, vars = "anti-human CD45RA", assay = "DSB")

# Extract the metadata for stimulationFigures
stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Combine the expression data and metadata into a data frame
expressionData <- data.frame(
  CD45RO = CD45ROExpression$`anti-human CD45RO`,
  CD45RA = CD45RAExpression$`anti-human CD45RA`,
  stimulationFigures = stimulationFigures
)


pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlotDSB.pdf")), height = 6, width = 12)

# Create the scatterplot
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16))

print(scatterPlot.tmp)
dev.off()

pdf(file.path(plotDir, paste0(filenameSuffix, "CD45RAVsCD45ROScatterPlotStimulationFacet.pdf")), height = 6, width = 12)

# Create the scatterplot with best fit line, CI, R value, and facet wrap by stimulationFigures
scatterPlot.tmp <- ggplot(expressionData, aes(x = CD45RO, y = CD45RA)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  stat_cor(method = "pearson", label.x = 3, label.y = 10) + # Adjust label.x and label.y as needed
  labs(title = "Scatterplot of anti-human CD45RO vs anti-human CD45RA",
    x = "CD45RO Expression",
    y = "CD45RA Expression") +
  theme_minimal() +
  theme(text = element_text(size = 16)) +
  facet_wrap(~stimulationFigures)

print(scatterPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r showStudyGroupOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

# # Extract UMAP coordinates and mean expression data
# umap_data.tmp <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
# umap_data.tmp$stimulation <- as.factor(seuratQCMergedCleanedDS$stimulation)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel_facet.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~studyGroup)

dev.off()
rm_tmp(ask = FALSE)
```

```{r showStudyGroupOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "study group", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel_facetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "studyGroup",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "study group", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~studyGroup)

dev.off()

# Ensure the 'stimulation' variable is a factor (if needed)
seuratQCMergedCleanedDS@meta.data$stimulation <- as.factor(seuratQCMergedCleanedDS@meta.data$stimulation)

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(Embeddings(seuratQCMergedCleanedDS, "umap"))
umap_data$studyGroup <- seuratQCMergedCleanedDS@meta.data$studyGroup
umap_data$stimulation <- seuratQCMergedCleanedDS@meta.data$stimulation

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_studyGroupLabel_facetByStimDS.pdf")),
height = 6,
width = 12)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = studyGroup)) +
  geom_point(size = 1) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "study group", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulation)

dev.off()
```

```{r showStimulationOnUMAP}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "stimulation",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel_facet.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleaned,
  reduction = "umap",
  group = "stimulation",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulation)

dev.off()
```

```{r showStimulationOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel_facetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stimulationLabel_facetDS_poster.pdf")),
height = 6,
width = )

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "stimulationFigures",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r showPoolOnUMAPDS}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_poolLabelDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "pool",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Pool", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_poolLabel_facetDS.pdf")),
height = 6,
width = 12)

DimPlot(object = seuratQCMergedCleanedDS,
  reduction = "umap",
  group = "pool",
  pt.size = 1) +
  # scale_color_manual(values = clusterColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Pool", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~pool)

dev.off()
```

```{r CITEseqMarkerScatterPlots}

# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))
sanitized_markers <- make.names(markers)

# Ensure the data frame and metadata are aligned
data <- data[rownames(filtered_meta_data), ]
data$stimulation <- filtered_meta_data$stimulation

# TODO move this filtering up higher to where we actually do the doublet filtering!!!!!!

# Function to create scatterplots for a given marker against all other markers
create_scatterplots <- function(marker, data, sanitized_markers) {
  plots <- list()
  other_markers <- setdiff(sanitized_markers, marker)

  for (other_marker in other_markers) {
    p <- ggplot(data, aes(x = !!sym(marker), y = !!sym(other_marker))) +
      geom_pointdensity(alpha = 0.5) +
      scale_color_viridis_c() +
      labs(title = paste(marker, "vs", other_marker), x = marker, y = other_marker) +
      theme_minimal()
    plots[[other_marker]] <- p
  }

  return(plots)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulation)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulation == stimulation, ]

  # Create and save scatterplot grids for each marker
  for (i in seq_along(sanitized_markers)) {
    sanitized_marker <- sanitized_markers[i]
    original_marker <- markers[i]
    scatterplots <- create_scatterplots(sanitized_marker, data_filtered, sanitized_markers)
    grid <- marrangeGrob(scatterplots, nrow = 3, ncol = 3, top = paste(original_marker, "-", stimulation))

    # Save the grid to a file
    png(file.path(plotDir,
      paste0(filenameSuffix, sanitized_marker, "_", stimulation, "_scatterplots.png")),
    height = 6,
    width = 12,
    units = "in",
    res = 600)

    print(grid)

    dev.off()
  }
}
```

```{r CITEseqMarkerScatterplotsNChoose2}
# Filter the metadata
meta_data.tmp <- seuratQCMergedCleanedDS@meta.data

# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$DSB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$DSB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))
sanitized_markers <- make.names(markers)

# Ensure the data frame and metadata are aligned
data <- data[rownames(meta_data.tmp), ]
data$stimulation <- meta_data.tmp$stimulation

# Function to create a scatterplot for a given pair of markers
create_scatterplot <- function(marker1, marker2, stimulation, data) {
  p <- ggplot(data, aes(x = !!as.name(marker1), y = !!as.name(marker2))) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = paste(marker1, "vs", marker2, stimulation), x = marker1, y = marker2) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulation)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulation == stimulation, ]

  # Create and save scatterplots for each pair of markers
  for (i in seq_along(sanitized_markers)) {
    for (j in (i + 1):length(sanitized_markers)) { # this doesn't work because it goes to 10, and there's no 10th entry...
      marker1 <- sanitized_markers[i]
      marker2 <- sanitized_markers[j]
      original_marker1 <- markers[i]
      original_marker2 <- markers[j]
      scatterplot <- create_scatterplot(marker1, marker2, stimulation, data_filtered)

      # Save the scatterplot to a file
      png(file.path(plotDir,
        paste0(filenameSuffix, original_marker1, "_vs_", original_marker2, "_", stimulation, "_scatterplot.png")),
      height = 6,
      width = 6,
      units = "in",
      res = 600)

      print(scatterplot)

      dev.off()
    }
  }
}

stimulation <- "Islet"
# Filter data for the current stimulation
data_filtered <- data[data$stimulation == stimulation, ]

# Create and save scatterplots for each pair of markers
for (i in seq_along(sanitized_markers)) {
  for (j in (i + 1):length(sanitized_markers)) { # this doesn't work because it goes to 10, and there's no 10th entry...
    marker1 <- sanitized_markers[i]
    marker2 <- sanitized_markers[j]
    original_marker1 <- markers[i]
    original_marker2 <- markers[j]
    scatterplot <- create_scatterplot(marker1, marker2, stimulation, data_filtered)

    # Save the scatterplot to a file
    png(file.path(plotDir,
      paste0(filenameSuffix, original_marker1, "_vs_", original_marker2, "_", stimulation, "_scatterplot.png")),
    height = 6,
    width = 6,
    units = "in",
    res = 600)

    print(scatterplot)

    dev.off()
  }
}
```

```{r CITEseqMarkerScatterPlotsStimulationSplit}
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))
sanitized_markers <- make.names(markers)

# Add stimulation information to the data
data$stimulation <- seuratQCMergedCleanedDS@meta.data$stimulation

# Function to create scatterplots for a given marker against all other markers
create_scatterplots <- function(marker, data, sanitized_markers) {
  plots <- list()
  other_markers <- setdiff(sanitized_markers, marker)

  for (other_marker in other_markers) {
    p <- ggplot(data, aes(x = !!sym(marker), y = !!sym(other_marker))) +
      geom_pointdensity(alpha = 0.5) +
      scale_color_viridis_c() +
      labs(title = paste(marker, "vs", other_marker), x = marker, y = other_marker) +
      theme_minimal()
    plots[[other_marker]] <- p
  }

  return(plots)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulation)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulation == stimulation, ]

  # Create and save scatterplot grids for each marker
  for (i in seq_along(sanitized_markers)) {
    sanitized_marker <- sanitized_markers[i]
    original_marker <- markers[i]
    scatterplots <- create_scatterplots(sanitized_marker, data_filtered, sanitized_markers)
    grid <- marrangeGrob(scatterplots, nrow = 3, ncol = 3, top = paste(original_marker, "-", stimulation))

    # Save the grid to a file
    png(file.path(plotDir,
      paste0(filenameSuffix, sanitized_marker, "_", stimulation, "_scatterplots.png")),
    height = 6,
    width = 12,
    units = "in",
    res = 600)

    print(grid)

    dev.off()
  }
}
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_logNorm}
# set plot sizes
plotHeight <- 2.5
plotWidth <- 4
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Add meanExpressionTreg to the data
data$meanExpressionTreg <- seuratQCMergedCleanedDS@meta.data$meanExpressionTreg

# Define the sum of two Gaussians function (for a curved gate)
sum_of_gaussians <- function(x, mean1, sigma1, weight1, mean2, sigma2, weight2, mean3, sigma3, weight3) {
  gauss1 <- weight1 * exp(-((x - mean1)^2) / (2 * sigma1^2))
  gauss2 <- weight2 * exp(-((x - mean2)^2) / (2 * sigma2^2))
  gauss3 <- weight3 * exp(-((x - mean3)^2) / (2 * sigma3^2))
  return(gauss1 + gauss2 + gauss3)
}

# Function to check if a point is inside an ellipse
is_inside_ellipse <- function(x, y, center_x, center_y, width, height, angle) {
  angle_rad <- angle * pi / 180
  cos_angle <- cos(angle_rad)
  sin_angle <- sin(angle_rad)
  x_rot <- cos_angle * (x - center_x) + sin_angle * (y - center_y)
  y_rot <- -sin_angle * (x - center_x) + cos_angle * (y - center_y)
  return((x_rot^2 / (width / 2)^2) + (y_rot^2 / (height / 2)^2) <= 1)
}

# Define the parameters for the Gaussians (Treg gate)
mean1 <- 7.5
sigma1 <- 1
weight1 <- 3.5
mean2 <- 5.5
sigma2 <- 2.5
weight2 <- 2.5
mean3 <- 3
sigma3 <- 2
weight3 <- 2.5

# Define the parameters for the ellipse (Tconv gate)
center_x <- 9
center_y <- 6
width <- 2
height <- 6
angle <- 190 * (pi / 180) # radians

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  set.seed(6022)
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = meanExpressionTreg)) +
    stat_function(fun = function(x) sum_of_gaussians(x, mean1, sigma1, weight1, mean2, sigma2, weight2, mean3, sigma3, weight3), color = "blue", alpha = 0.8) +
    geom_ellipse(aes(x0 = center_x, y0 = center_y, a = width / 2, b = height / 2, angle = angle),
      color = "red", alpha = 0.2) +
    # annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
    #   alpha = 0.2, fill = NA, color = "blue") +
    # annotate("rect", xmin = 7.5, xmax = Inf, ymin = 5, ymax = Inf,
    #   alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "meanExpressionTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()) +
    ylim(-0.2, NA)
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

set.seed(6022)
# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria for Tregs (under the Gaussian curve)
gated_data <- data[data$CD154_jittered < sum_of_gaussians(data$CD69_jittered, mean1, sigma1, weight1, mean2, sigma2, weight2, mean3, sigma3, weight3), ]

# Apply gating criteria for Tconvs (inside the ellipse)
cellsTconv <- data[is_inside_ellipse(data$CD69_jittered, data$CD154_jittered, center_x, center_y, width, height, angle), ]

# Apply gating criteria
# gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

set.seed(6022)
# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
# cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Define the parameters for the ellipse (Treg gate2)
center_x <- 8.75
center_y <- 6.75
width <- 1.75
height <- 2.5
angle <- 15 * (pi / 180) # radians

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    #  geom_ellipse(aes(x0 = center_x, y0 = center_y, a = width / 2, b = height / 2, angle = angle),
    #              color = "blue", alpha = 0.2) +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
set.seed(6022)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD127, amount = 0.2)
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]
# gated_data_2 <- gated_data[is_inside_ellipse(data$CD25_jittered, data$CD137_jittered, center_x, center_y, width, height, angle), ]


# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTreg") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_logNorm.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_logNorm_noDownsample_densityPlot}
# set plot sizes
plotHeight <- 2
plotWidth <- 4
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleaned@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleaned@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleaned@meta.data$stimulationFigures

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation, xminTreg, xmaxTreg, yminTreg, ymaxTreg, xminTconv, xmaxTconv, yminTconv, ymaxTconv) {
  # Add jitter to the data
  set.seed(6022)
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "Density") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()) +
    ylim(-0.25, 8) +
    xlim(-0.25, 9) +
    annotate("rect", xmin = xminTreg, xmax = xmaxTreg, ymin = yminTreg, ymax = ymaxTreg,
      alpha = 1, fill = NA, color = "blue") +
    annotate("rect", xmin = xminTconv, xmax = xmaxTconv, ymin = yminTconv, ymax = ymaxTconv,
      alpha = 1, fill = NA, color = "red")
  return(p)
}

# set gate cutoffs
gate_cutoffs <- list(
  "Microbial" = list(xminTreg = 2.5, xmaxTreg = Inf, yminTreg = -0.25, ymaxTreg = 4, xminTconv = 7.5, xmaxTconv = Inf, yminTconv = 4.5, ymaxTconv = Inf),
  "IAR" = list(xminTreg = 2.5, xmaxTreg = Inf, yminTreg = -0.25, ymaxTreg = 4, xminTconv = 7.5, xmaxTconv = Inf, yminTconv = 4.5, ymaxTconv = Inf),
  "Polyclonal" = list(xminTreg = 2.5, xmaxTreg = Inf, yminTreg = -0.25, ymaxTreg = 4, xminTconv = 7.5, xmaxTconv = Inf, yminTconv = 4.5, ymaxTconv = Inf)
)

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Get the gate cutoffs for the current stimulation
  cutoffs <- gate_cutoffs[[stimulation]]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation,
    cutoffs$xminTreg, cutoffs$xmaxTreg, cutoffs$yminTreg, cutoffs$ymaxTreg,
    cutoffs$xminTconv, cutoffs$xmaxTconv, cutoffs$yminTconv, cutoffs$ymaxTconv)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "density_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleaned@meta.data$HT_names

set.seed(6022)
# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria (step 1/3 for Tregs)
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Apply gating to find Tconvs (step 1/1 for Tconvs)
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.5, ]
cellsTconv  <- cellsTconv$HT_names

set.seed(6022)
# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
set.seed(6022)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD127, amount = 0.2)
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]
# gated_data_2 <- gated_data[is_inside_ellipse(data$CD25_jittered, data$CD137_jittered, center_x, center_y, width, height, angle), ]


# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTreg") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_logNorm.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_DSBNorm_noDownsample_densityPlot}
# set plot sizes
plotHeight <- 2.5
plotWidth <- 4
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleaned@assays$DSB@data)
data <- as.data.frame(t(seuratQCMergedCleaned@assays$DSB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleaned@meta.data$stimulationFigures

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  set.seed(6022)
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "Density") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()) +
    ylim(-0.25, 8) +
    xlim(-1, 5) +
    annotate("rect", xmin = 1.8, xmax = Inf, ymin = 0.85, ymax = Inf,
      alpha = 1, fill = NA, color = "red") +
    annotate("rect", xmin = -Inf, xmax = Inf, ymin = -0.25, ymax = 0.666,
      alpha = 1, fill = NA, color = "blue")
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "density_scatterplot_DSBNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleaned@meta.data$HT_names

set.seed(6022)
# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD154_jittered < 0.666, ]

# Apply gating to find Tconvs
cellsTconvDSB <- data[data$CD69_jittered > 1.8 & data$CD154_jittered > 0.85, ]
cellsTconvDSB  <- cellsTconvDSB$HT_names


set.seed(6022)
# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
    annotate("rect", xmin = 1.75, xmax = Inf, ymin = 1, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "point density") +
    theme_minimal() +
    ylim(-3, 10) +
    xlim(-1, 7) +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "density_scatterplot_DSBNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
set.seed(6022)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD127, amount = 0.2)
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 1.75 & gated_data$anti.human.CD137 > 1, ]
# gated_data_2 <- gated_data[is_inside_ellipse(data$CD25_jittered, data$CD137_jittered, center_x, center_y, width, height, angle), ]


# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
    annotate("rect", xmin = 2, xmax = Inf, ymin = -Inf, ymax = 1.5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "point density") +
    xlim(1, 7) +
    ylim(0, 6) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "density_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    annotate("rect", xmin = 2, xmax = Inf, ymin = -Inf, ymax = 1.5,
      alpha = 0.2, fill = NA, color = "blue") +
    # xlim(0, 10) +
    # ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_DSB.png")),
  height = 5,
  width = 6,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 2 & gated_data_2$anti.human.CD127 < 1.5, ]

cellsTregDSB <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_showRNAClusters_logNorm}
# set plot sizes
plotHeight <- 5
plotWidth <- 6
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Add RNA clusters to the dataframe
data$cluster <- seuratQCMergedCleanedDS@meta.data$seurat_clusters

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = cluster)) +
    annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
      alpha = 0.2, fill = NA, color = "blue") +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "cluster") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "RNAcluster_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 5, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = cluster)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "cluster") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "RNAcluster_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = cluster)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "cluster") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "RNAcluster_scatterplot_logNorm.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127, color = cluster)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_RNACluster_logNorm.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_DSB}
# set plot sizes
plotHeight <- 2.5
plotWidth <- 4
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$DSB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$DSB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Add meanExpressionTreg to the data
data$meanExpressionTreg <- seuratQCMergedCleanedDS@meta.data$meanExpressionTreg

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = meanExpressionTreg)) +
    # annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
    #   alpha = 0.2, fill = NA, color = "blue") +
    # annotate("rect", xmin = 7.5, xmax = Inf, ymin = 5, ymax = Inf,
    #   alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "meanExpressionTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "TregExp_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    # annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
    #   alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    # annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
    #   alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTreg") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_DSB.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_showRNAClusters_DSB}
# set plot sizes
plotHeight <- 5
plotWidth <- 6
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$DSB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$DSB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Add RNA clusters to the dataframe
data$cluster <- seuratQCMergedCleanedDS@meta.data$seurat_clusters

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = cluster)) +
    # annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
    #   alpha = 0.2, fill = NA, color = "blue") +
    # annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
    #   alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "cluster") +
    theme_minimal() +
    ylim(-0.25, 8) +
    xlim(-1, 5) +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "RNAcluster_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD154_jittered < 0.666, ]

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 1.8 & data$CD154_jittered > 0.85, ]
cellsTconv  <- cellsTconv$HT_names

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = cluster)) +
    # annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
    #   alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "cluster") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "RNAcluster_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = cluster)) +
    # annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
    #   alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "cluster") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "RNAcluster_scatterplot_DSB.png")),
  height = plotHeight,
  width = plotWidth,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127, color = cluster)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_manual(values = palRNAClusters) +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_RNACluster_DSB.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_cellTypist}
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleaned@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleaned@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleaned@meta.data$stimulationFigures

# Add meanExpressionTreg to the data
data$meanExpressionTreg <- seuratQCMergedCleaned@meta.data$meanExpressionTreg

# Add cellTypistCalling to the data
data$cellTypistCalling <- seuratQCMergedCleaned@meta.data$cellTypistCalling

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = cellTypistCalling)) +
    annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
      alpha = 0.2, fill = NA, color = "blue") +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
      alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "cellTypistCalling") +
    theme_minimal() +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 2))
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "_cellTypist_scatterplot.png")),
  height = 5,
  width = 6,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = cellTypistCalling)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "cellTypistCalling") +
    theme_minimal() +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 2))
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "_cellTypist_scatterplot.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = cellTypistCalling)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "cellTypistCalling") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 2))
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_cellTypist_scatterplot.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {

  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127, color = cellTypistCalling)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_cellTypist.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_cellTypist_DSB}
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleaned@assays$DSB@data)
data <- as.data.frame(t(seuratQCMergedCleaned@assays$DSB @data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleaned@meta.data$stimulationFigures

# Add cellTypistCalling to the data
data$cellTypistCalling <- seuratQCMergedCleaned@meta.data$cellTypistCalling

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  set.seed(6022)
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = cellTypistCalling)) +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "cellTypistCalling") +
    theme_minimal() +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 2)) +
    ylim(-0.25, 8) +
    xlim(-1, 5) +
    annotate("rect", xmin = 1.8, xmax = Inf, ymin = 0.85, ymax = Inf,
      alpha = 1, fill = NA, color = "red") +
    annotate("rect", xmin = -Inf, xmax = Inf, ymin = -0.25, ymax = 0.666,
      alpha = 1, fill = NA, color = "blue")
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "_cellTypist_scatterplot_DSB.png")),
  height = 5,
  width = 6,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleaned@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconvDSB <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconvDSB  <- cellsTconvDSB$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = cellTypistCalling)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "cellTypistCalling") +
    theme_minimal() +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 2))
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "_cellTypist_scatterplot_DSB.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = cellTypistCalling)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "cellTypistCalling") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 2))
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_cellTypist_scatterplot_DSB.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {

  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127, color = cellTypistCalling)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_manual(values = palCellTypist) +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_cellTypist_DSB.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTregDSB <- gated_data_3$HT_names
```

```{r AgSpecificCellsPerStimLogNorm}
# Extract the relevant metadata for cellsTreg and cellsTconv
metaData.df.tmp <- seuratQCMergedCleaned@meta.data

# Filter metadata for cellsTreg and cellsTconv
metaDataTreg.df.tmp <- metaData.df.tmp %>% filter(barcode %in% cellsTreg)
metaDataTconv.df.tmp <- metaData.df.tmp %>% filter(barcode %in% cellsTconv)

# Create contingency tables
table_treg <- metaDataTreg.df.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(count = n()) %>%
  spread(stimulationFigures, count, fill = 0) %>%
  mutate(cellType = "Treg")

table_tconv <- metaDataTconv.df.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(count = n()) %>%
  spread(stimulationFigures, count, fill = 0) %>%
  mutate(cellType = "Tconv")

# Combine the tables into a single data frame
combined_table <- bind_rows(table_treg, table_tconv)

# Print the combined table
print(combined_table)

# Define the output file path
output_file <- file.path(dataOutputDir, "totalSeqTregTconvCountsPerDonorStimulationNoDownsample.xlsx")

# Save the combined_table to an Excel file
write.xlsx(combined_table, output_file)

rm_tmp(ask = FALSE)
```

```{r AgSpecificCellsPerStimDSBNorm}
# Extract the relevant metadata for cellsTreg and cellsTconv
metaData.df.tmp <- seuratQCMergedCleaned@meta.data

# Filter metadata for cellsTreg and cellsTconv
metaDataTreg.df.tmp <- metaData.df.tmp %>% filter(barcode %in% cellsTregDSB)
metaDataTconv.df.tmp <- metaData.df.tmp %>% filter(barcode %in% cellsTconvDSB)

# Create contingency tables
table_treg <- metaDataTreg.df.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(count = n()) %>%
  spread(stimulationFigures, count, fill = 0) %>%
  mutate(cellType = "Treg")

table_tconv <- metaDataTconv.df.tmp %>%
  group_by(donorIdFigures, stimulationFigures) %>%
  summarise(count = n()) %>%
  spread(stimulationFigures, count, fill = 0) %>%
  mutate(cellType = "Tconv")

# Combine the tables into a single data frame
combined_table <- bind_rows(table_treg, table_tconv)

# Print the combined table
print(combined_table)

# Define the output file path
output_file <- file.path(dataOutputDir, "totalSeqTregTconvCountsPerDonorStimulationNoDownsampleDSB.xlsx")

# Save the combined_table to an Excel file
write.xlsx(combined_table, output_file)

rm_tmp(ask = FALSE)
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_poster}
# set plot sizes
plotHeight <- 2.5
plotWidth <- 4
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Add meanExpressionTreg to the data
data$meanExpressionTreg <- seuratQCMergedCleanedDS@meta.data$meanExpressionTreg

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
      alpha = 0.2, fill = NA, color = "blue") +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
      alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "meanExpressionTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      text = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16),
      axis.title.x = element_text(size = 16),
      axis.title.y = element_text(size = 16),
      legend.text = element_text(size = 16),
      legend.title = element_text(size = 16),
      strip.text = element_text(size = 16),
      plot.title = element_text(size = 16),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  pdf(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "TregExp_scatterplot_poster.pdf")),
  height = plotHeight,
  width = plotWidth)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTreg") +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      text = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16),
      axis.title.x = element_text(size = 16),
      axis.title.y = element_text(size = 16),
      legend.text = element_text(size = 16),
      legend.title = element_text(size = 16),
      strip.text = element_text(size = 16),
      plot.title = element_text(size = 16),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  pdf(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_poster.pdf")),
  height = plotHeight,
  width = plotWidth)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTreg") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "none", # "bottom",
      text = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16),
      axis.title.x = element_text(size = 16),
      axis.title.y = element_text(size = 16),
      legend.text = element_text(size = 16),
      legend.title = element_text(size = 16),
      strip.text = element_text(size = 16),
      plot.title = element_text(size = 16),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank())
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  pdf(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_poster.pdf")),
  height = plotHeight,
  width = plotWidth)

  print(scatterplot)

  dev.off()
}
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_TregClusterSubset}
# subset down to clusters 2 and 5
# Subset the Seurat object to include only clusters 2 and 5
clusters_to_keep <- c(2, 5)
seuratSubset.tmp <- subset(seuratQCMergedCleanedDS, idents = clusters_to_keep)


# Extract the data for the markers
markers <- rownames(seuratSubset.tmp@assays$FB@data)
data <- as.data.frame(t(seuratSubset.tmp@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratSubset.tmp@meta.data$stimulationFigures

# Add meanExpressionTreg to the data
data$meanExpressionTreg <- seuratSubset.tmp@meta.data$meanExpressionTreg

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
      alpha = 0.2, fill = NA, color = "blue") +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
      alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "meanExpressionTreg") +
    theme_minimal() +
    theme(legend.position = "bottom")
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "TregExp_scatterplot_clusters_2_5.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTreg") +
    theme_minimal() +
    theme(legend.position = "bottom")
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TregExp_scatterplot_clusters_2_5.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTreg)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTreg") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "bottom")
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TregExp_scatterplot_clusters_2_5.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated_clusters_2_5.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```


```{r addTotalSeqCellTypesToSeurat}
# Add a new metadata column for cell type
seuratQCMergedCleanedDS$cellType <- "Other"

# Set cell type for Tregs
seuratQCMergedCleanedDS$cellType[seuratQCMergedCleanedDS$HT_names %in% cellsTreg] <- "Treg"

# Set cell type for Tconvs
seuratQCMergedCleanedDS$cellType[seuratQCMergedCleanedDS$HT_names %in% cellsTconv] <- "Tconv"

# Add a new metadata column for cell type
seuratQCMergedCleanedDS$cellTypeDSB <- "Other"

# Set cell type for Tregs
seuratQCMergedCleanedDS$cellTypeDSB[seuratQCMergedCleanedDS$HT_names %in% cellsTregDSB] <- "Treg"

# Set cell type for Tconvs
seuratQCMergedCleanedDS$cellTypeDSB[seuratQCMergedCleanedDS$HT_names %in% cellsTconvDSB] <- "Tconv"

# Add a new metadata column for cell type
seuratQCMergedCleaned$cellType <- "Other"

# Set cell type for Tregs
seuratQCMergedCleaned$cellType[seuratQCMergedCleaned$HT_names %in% cellsTreg] <- "Treg"

# Set cell type for Tconvs
seuratQCMergedCleaned$cellType[seuratQCMergedCleaned$HT_names %in% cellsTconv] <- "Tconv"

# Add a new metadata column for cell type
seuratQCMergedCleaned$cellTypeDSB <- "Other"

# Set cell type for Tregs
seuratQCMergedCleaned$cellTypeDSB[seuratQCMergedCleaned$HT_names %in% cellsTregDSB] <- "Treg"

# Set cell type for Tconvs
seuratQCMergedCleaned$cellTypeDSB[seuratQCMergedCleaned$HT_names %in% cellsTconvDSB] <- "Tconv"
```

```{r clusterProportionPlotsWithCellTypeCalls}
nClust <- length(table(seuratQCMergedCleanedDS@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratQCMergedCleanedDS@meta.data$studyGroup <- as.factor(seuratQCMergedCleanedDS@meta.data$studyGroup)
seuratQCMergedCleanedDS@meta.data$stimulationFigures <- as.factor(seuratQCMergedCleanedDS@meta.data$stimulationFigures)
seuratQCMergedCleanedDS@meta.data$donorIdFigures <- as.factor(seuratQCMergedCleanedDS@meta.data$donorIdFigures)
seuratQCMergedCleanedDS@meta.data$seurat_clusters <- as.factor(seuratQCMergedCleanedDS@meta.data$seurat_clusters)
seuratQCMergedCleanedDS@meta.data$cellType <- as.factor(seuratQCMergedCleanedDS$cellType)
seuratQCMergedCleanedDS@meta.data$cellTypistCalling <- as.factor(seuratQCMergedCleanedDS$cellTypistCalling)

# Extract metadata
metadata.tmp <- seuratQCMergedCleanedDS@meta.data

# all together now
# Create the three plots
plot1.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot2.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot3.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot4.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellType)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "TotalSeq cellType") +
  scale_fill_manual(values = palCellType) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot5.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1.tmp, plot2.tmp, plot3.tmp, plot4.tmp, plot5.tmp, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_cellTypeCalls.pdf")), height = 7, width = 7)
print(combined_plot)
dev.off()

# all together now (POSTER
fontSize <- 14

# Create the three plots
plot1 <- ggplot(metadata, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Study Group", title = "Proportions of Study Group in Seurat Clusters") +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot2 <- ggplot(metadata, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = NULL, y = "Proportion", fill = "Stimulation", title = "Proportions of Stimulation in Seurat Clusters") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

plot3 <- ggplot(metadata, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID", title = "Proportions of Donor ID in Seurat Clusters") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(text = element_text(size = fontSize),
    axis.text.x = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.x = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Combine the plots vertically
combined_plot <- plot_grid(plot1, plot2, plot3, ncol = 1, align = "v", rel_heights = c(1, 1, 1.2))

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_poster.pdf")), height = 5, width = 6)
print(combined_plot)
dev.off()
rm_tmp(ask = FALSE)
```

```{r logNormVsDSBCellTypeVenn}
library(ggvenn)

# make subset seurat objects that contain separate cellType calls
seuratLogNormTreg.tmp <- subset(seuratQCMergedCleanedDS, subset = cellType == "Treg")
seuratDSBNormTreg.tmp <- subset(seuratQCMergedCleanedDS, subset = cellTypeDSB == "Treg")
seuratLogNormTconv.tmp <- subset(seuratQCMergedCleanedDS, subset = cellType == "Tconv")
seuratDSBNormTconv.tmp <- subset(seuratQCMergedCleanedDS, subset = cellTypeDSB == "Tconv")

# Extract cell type assignments
cellType <- seuratQCMergedCleanedDS$cellType
cellTypeDSB <- seuratQCMergedCleanedDS$cellTypeDSB

# Create sets for each cell type
set1_Other <- which(cellType == "Other")
set1_Treg <- which(cellType == "Treg")
set1_Tconv <- which(cellType == "Tconv")

set2_Other <- which(cellTypeDSB == "Other")
set2_Treg <- which(cellTypeDSB == "Treg")
set2_Tconv <- which(cellTypeDSB == "Tconv")

# Create a list of sets
venn_list <- list(
  CellType_Other = set1_Other,
  CellType_Treg = set1_Treg,
  CellType_Tconv = set1_Tconv,
  CellTypeDSB_Other = set2_Other,
  CellTypeDSB_Treg = set2_Treg,
  CellTypeDSB_Tconv = set2_Tconv
)

# Generate the Venn diagram using ggvenn with adjusted text size
venn.plot <- ggvenn(venn_list, fill_color = c("red", "green", "blue", "yellow", "purple", "cyan")) +
  theme(text = element_text(size = 12))

# Save the Venn diagram to a file with increased dimensions
ggsave(file.path(plotDir, "cellType_VennDiagram.png"), venn.plot, height = 10, width = 15, units = "in", dpi = 300)

rm_tmp(ask = FALSE)
```

```{r TregCallingMethodsVennDiagram}
# venn diagram with cells called Treg in:
# seuratQCMergedCleaned$cellType
# seuratQCMergedCleaned@meta.data$cellTypist
# and seuratQCMergedCleanedDS@meta.data$seurat_clusters 3 and 4


# Extract cell barcodes for Treg in seuratQCMergedCleaned$cellType
treg_TotalSeq <- names(seuratQCMergedCleaned$cellType[seuratQCMergedCleaned$cellType == "Treg"])

# Extract cell barcodes for Treg in seuratQCMergedCleaned@meta.data$cellTypist
treg_cellTypist <- rownames(seuratQCMergedCleaned@meta.data[seuratQCMergedCleaned@meta.data$cellTypistCalling == "Treg", ])

# Extract cell barcodes for clusters 3 and 4 in seuratQCMergedCleanedDS@meta.data$seurat_clusters
treg_clusters <- rownames(seuratQCMergedCleanedDS@meta.data[seuratQCMergedCleanedDS@meta.data$seurat_clusters %in% c(3, 4), ])

# Extract cell barcodes for cells that are Tregs according to the P390 module
treg_P390 <- names(seuratQCMergedCleaned$cellTypeP390[seuratQCMergedCleaned$cellTypeP390 == "Treg"])

# 4 methods
# Create a list of these sets
venn_list <- list(
  TotalSeq = treg_TotalSeq,
  CellTypist = treg_cellTypist,
  Clusters = treg_clusters,
  P390 = treg_P390
)

# start pdf printing
pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregCalling4MethodsVenn.pdf")),
height = 5,
width = 7)

# Generate the Venn diagram using ggvenn
venn.plot.tmp <- ggvenn(venn_list, fill_color = c("red", "green", "blue", "Orange"))

# Print the venn plot
print(venn.plot.tmp)
dev.off()

# 3 methods
# Create a list of these sets
venn_list <- list(
  TotalSeq = treg_TotalSeq,
  CellTypist = treg_cellTypist,
  Clusters = treg_clusters
)

# start pdf printing
pdf(file.path(plotDir,
  paste0(filenameSuffix, "TregCalling3MethodsVenn.pdf")),
height = 5,
width = 7)

# Generate the Venn diagram using ggvenn
venn.plot.tmp <- ggvenn(venn_list, fill_color = c("red", "green", "blue"))

# Print the venn plot
print(venn.plot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r cellTypeAssignmentCITEseqAlluvialPlot}
library(ggalluvial)

# Extract cell type assignments
cellType.tmp <- seuratQCMergedCleaned$cellType
cellTypeDSB.tmp <- seuratQCMergedCleaned$cellTypeDSB

# Create a data frame with cell barcodes and their corresponding cell type assignments
cellAssignments.tmp <- data.frame(
  cellBarcode = names(cellType.tmp),
  cellTypeLogNorm = cellType.tmp,
  cellTypeDSB = cellTypeDSB.tmp[names(cellType.tmp)]
)

# Count the number of cells in each category
cellCounts.tmp <- cellAssignments.tmp %>%
  group_by(cellTypeLogNorm, cellTypeDSB) %>%
  summarise(count = n())

# Print the cell counts to verify
print(cellCounts.tmp)

png(file.path(plotDir,
  paste0(filenameSuffix, "logNormVsDSBNormAlluvialPlot.png")),
height = 5,
width = 7,
units = "in",
res = 600)

# Create an alluvial plot
alluvialPlot.tmp <- ggplot(cellCounts.tmp,
  aes(axis1 = cellTypeLogNorm, axis2 = cellTypeDSB, y = count)) +
  geom_flow(aes(fill = cellTypeLogNorm), stat = "alluvium") +
  geom_stratum(alpha = .5) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  scale_x_discrete(limits = c("cellTypeLogNorm", "cellTypeDSB"), expand = c(0.15, 0.05)) +
  labs(title = "Alluvial Plot of Cell Type Assignments",
    x = "Method",
    y = "Number of Cells") +
  theme_minimal()

# Print the alluvial plot
print(alluvialPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r cellTypeAssignmentLogNormVsCellTypistAlluvialPlot}
library(ggalluvial)

# Extract cell type assignments
cellType.tmp <- seuratQCMergedCleaned$cellType
# Extract cell type assignments from CellTypist
cellTypeCellTypist.tmp <- seuratQCMergedCleaned@meta.data$cellTypistCalling

# Ensure cell barcodes are assigned as names
names(cellTypeCellTypist.tmp) <- rownames(seuratQCMergedCleaned@meta.data)

# Verify the table
table(cellTypeCellTypist.tmp)

# Create a data frame with cell barcodes and their corresponding cell type assignments
cellAssignments.tmp <- data.frame(
  cellBarcode = names(cellType.tmp),
  cellTypeLogNorm = cellType.tmp,
  cellTypeCellTypist = cellTypeCellTypist.tmp[names(cellType.tmp)]
)

# Count the number of cells in each category
cellCounts.tmp <- cellAssignments.tmp %>%
  group_by(cellTypeLogNorm, cellTypeCellTypist) %>%
  summarise(count = n())

# Print the cell counts to verify
print(cellCounts.tmp)

# Ensure the factors are correctly ordered
cellCounts.tmp$cellTypeLogNorm <- factor(cellCounts.tmp$cellTypeLogNorm, levels = unique(cellCounts.tmp$cellTypeLogNorm))
cellCounts.tmp$cellTypeCellTypist <- factor(cellCounts.tmp$cellTypeCellTypist, levels = unique(cellCounts.tmp$cellTypeCellTypist))

png(file.path(plotDir,
  paste0(filenameSuffix, "logNormVsCellTypistAlluvialPlot.png")),
height = 5,
width = 7,
units = "in",
res = 600)

# Create an alluvial plot
alluvialPlot.tmp <- ggplot(cellCounts.tmp,
  aes(axis1 = cellTypeLogNorm, axis2 = cellTypeCellTypist, y = count)) +
  geom_flow(aes(fill = cellTypeLogNorm), stat = "alluvium") +
  geom_stratum(alpha = .5) +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  scale_x_discrete(limits = c("cellTypeLogNorm", "cellTypeCellTypist"), expand = c(0.15, 0.05)) +
  labs(title = "TotalSeq (logNorm) vs CellTypist",
    x = "Method",
    y = "Number of Cells") +
  theme_minimal()

# Print the alluvial plot
print(alluvialPlot.tmp)
dev.off()

rm_tmp(ask = FALSE)
```

```{r CITEseqMarkerScatterPlotsStimulationSplit_forGating_meanTconvExpression}
# Extract the data for the markers
markers <- rownames(seuratQCMergedCleanedDS@assays$FB@data)
data <- as.data.frame(t(seuratQCMergedCleanedDS@assays$FB@data[markers, ]))

# Sanitize column names
colnames(data) <- make.names(colnames(data))

sanitized_markers <- make.names(markers)
# c("CD154", "CD137", "CD69", "CD127", "CD25", "CD45RA", "CD45RO", "CCR7", "MouseIgG1_isotypeCtrl")

# Add stimulation information to the data
data$stimulationFigures <- seuratQCMergedCleanedDS@meta.data$stimulationFigures

# Add meanExpressionTconv to the data
data$meanExpressionTconv <- seuratQCMergedCleanedDS@meta.data$meanExpressionTconv

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD154_CD69 <- function(data, stimulation) {
  # Add jitter to the data
  data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
  data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

  # p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered)) +
  #   annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
  #     alpha = 0.2, fill = "red", color = "red") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD69", y = "CD154") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  p <- ggplot(data, aes(x = CD69_jittered, y = CD154_jittered, color = meanExpressionTconv)) +
    annotate("rect", xmin = 2.5, xmax = Inf, ymin = -0.25, ymax = 4,
      alpha = 0.2, fill = NA, color = "blue") +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = 4.25, ymax = Inf,
      alpha = 0.2, fill = NA, color = "red") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD69", y = "CD154", color = "meanExpressionTconv") +
    theme_minimal() +
    theme(legend.position = "bottom")
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD154_CD69(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD69_CD154_", stimulation, "TconvExp_scatterplot.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Add HT_names to the data
data$HT_names <- seuratQCMergedCleanedDS@meta.data$HT_names

# Add jitter to the data
data$CD69_jittered <- jitter(data$anti.human.CD69, amount = 0.2)
data$CD154_jittered <- jitter(data$anti.human.CD154, amount = 0.2)

# Apply gating criteria
gated_data <- data[data$CD69_jittered > 2.5 & data$CD154_jittered < 4, ]

# Add jitter to the data
gated_data$CD25_jittered <- jitter(gated_data$anti.human.CD25, amount = 0.2)
gated_data$CD137_jittered <- jitter(gated_data$anti.human.CD137, amount = 0.2)

# Apply gating to find Tconvs
cellsTconv <- data[data$CD69_jittered > 7.5 & data$CD154_jittered > 4.25, ]
cellsTconv  <- cellsTconv$HT_names

# Extract the HT_names for the filtered cells
HT_names_filtered <- gated_data$HT_names

# Print the filtered HT_names
print(HT_names_filtered)

# Function to create a scatterplot for CD154 vs CD69 with jittered points and point density
create_scatterplot_CD137_CD25 <- function(gated_data, stimulation) {
  # p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD137") +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTconv)) +
    annotate("rect", xmin = 8, xmax = Inf, ymin = 5, ymax = Inf,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD137", color = "meanExpTconv") +
    theme_minimal() +
    theme(legend.position = "bottom")
  return(p)

}

# Loop over each unique stimulation
for (stimulation in unique(gated_data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data[gated_data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD154 vs CD69
  scatterplot <- create_scatterplot_CD137_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD137_CD25_", stimulation, "TconvExp_scatterplot.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Apply gating criteria CD25/CD137
gated_data_2 <- gated_data[gated_data$anti.human.CD25 > 7 & gated_data$anti.human.CD137 > 4.5, ]

gated_data_2$CD137_jittered <- jitter(gated_data_2$anti.human.CD127, amount = 0.2)

# Function to create a scatterplot for CD127 and CD25 with jittered points and point density
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {
  # p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered)) +
  #   annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
  #     alpha = 0.2, fill = "blue", color = "blue") +
  #   geom_pointdensity(alpha = 0.5) +
  #   scale_color_viridis_c() +
  #   labs(title = stimulation, x = "CD25", y = "CD127") +
  #   xlim(0, 10) +
  #   ylim(0, 8) +
  #   theme_minimal() +
  #   theme(legend.position = "none")
  # return(p)

  p <- ggplot(gated_data_2, aes(x = CD25_jittered, y = CD137_jittered, color = meanExpressionTconv)) +
    annotate("rect", xmin = 7.5, xmax = Inf, ymin = -Inf, ymax = 5,
      alpha = 0.2, fill = NA, color = "blue") +
    geom_point(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127", color = "meanExpTconv") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal() +
    theme(legend.position = "bottom")
  return(p)


}

# Loop over each unique stimulation
for (stimulation in unique(gated_data_2$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- gated_data_2[gated_data_2$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "TconvExp_scatterplot.png")),
  height = 4,
  width = 4,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}


# Function to create a scatterplot for CD127 and CD25--ungated
create_scatterplot_CD127_CD25 <- function(gated_data_2, stimulation) {


  p <- ggplot(gated_data_2, aes(x = anti.human.CD25, y = anti.human.CD127)) +
    geom_pointdensity(alpha = 0.5) +
    scale_color_viridis_c() +
    labs(title = stimulation, x = "CD25", y = "CD127") +
    xlim(0, 10) +
    ylim(0, 8) +
    theme_minimal()
  return(p)
}

# Loop over each unique stimulation
for (stimulation in unique(data$stimulationFigures)) {
  # Filter data for the current stimulation
  data_filtered <- data[data$stimulationFigures == stimulation, ]

  # Create the scatterplot for CD127 vs CD25
  scatterplot <- create_scatterplot_CD127_CD25(data_filtered, stimulation)

  # Save the scatterplot to a file
  png(file.path(plotDir,
    paste0(filenameSuffix, "CD127_CD25_", stimulation, "_scatterplot_ungated.png")),
  height = 3,
  width = 12,
  units = "in",
  res = 600)

  print(scatterplot)

  dev.off()
}

# Apply gating criteria CD25/CD127
gated_data_3 <- gated_data_2[gated_data_2$anti.human.CD25 > 7.5 & gated_data_2$anti.human.CD127 < 5, ]

cellsTreg <- gated_data_3$HT_names
```

```{r clusterTregCellsSeparately}
# make a subset seurat object that only contains the cells where $cellType == "Treg"
seuratTreg <- subset(seuratQCMergedCleanedDS, subset = cellType == "Treg")

# now subset down to the cells in RNAseq clusters 3 and 4
seuratTreg <- subset(seuratQCMergedCleanedDS, subset = seurat_clusters %in% c("3", "4"))

# save old clusters
seuratTreg@meta.data$seuratClustersAllCellsDS <- seuratTreg@meta.data$seurat_clusters

# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratTreg) <- "RNA"
seuratTreg <- SeuratObject::JoinLayers(seuratTreg, layers = c("RNA"))
seuratTreg <- NormalizeData(object = seuratTreg,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratTreg <- NormalizeData(object = seuratTreg,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

# seuratTreg <- NormalizeData(object = seuratTreg, verbose = FALSE)
seuratTreg <- FindVariableFeatures(object = seuratTreg,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratTreg <- ScaleData(object = seuratTreg, verbose = FALSE)
seuratTreg <- RunPCA(object = seuratTreg, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratTreg)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 7, 14, 16, 18, 20),
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5)
)

# the size of these vectors largely determines the cost of this function in walltime
min.dist.vector <-  c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
n_neighbors.vector <- c(5, 20, 30, 40, 50)

startTime <- Sys.time()

resultTreg <- optimizeRNAseqClustering(seuratTreg,
  hyperParamGridPCA.df,
  min.dist.vector,
  n_neighbors.vector,
  maxNClusters = 6)

endTime <- Sys.time()
timeElapsed <- endTime - startTime
print(timeElapsed)

# Extract the data frames from the result
hyperParamGridOptClusterAndUMAP.df <- resultTreg$hyperParamGridOptClusterAndUMAP.df
hyperParamGridClusterOnly.df <- resultTreg$hyperParamGridClusterOnly.df

write.xlsx(hyperParamGridOptClusterAndUMAP.df, file = file.path(dataOutputDir, "20241210_RNA_clustering_TregOnly_hyperParamGrid.xlsx"))

set.seed(6022)
seuratTreg <- FindNeighbors(seuratTreg, dims = 1:16)
seuratTreg <- FindClusters(seuratTreg, resolution = 0.6)


# Optimize UMAP hyperparameters with scDEED
K_ <- 16 # number of PCs

start_time.tmp <- Sys.time()

scDEEDResult <- scDEED(seuratTreg, # input Seurat object (must have UMAP or t-SNE already run)
  K = K_, # number of PCs
  reduction.method = "umap", # 'umap' or 'tsne'
  min.dist =  c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), # c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1), # 0.4, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
  n_neighbors = c(5, 20, 30, 40, 50), # c(5, 20, 30, 40, 50), # 5, # c(5, 20, 30, 40, 50), #scDEED defaults. Seurat default is 30.
  similarity_percent = 0.5, # default
  dubious_cutoff = 0.05, # default
  trustworthy_cutoff = 0.95) # default

end_time.tmp <- Sys.time()

time_elapsed <- end_time.tmp - start_time.tmp
print(time_elapsed) # Time difference of 19.69495 mins

rm_tmp(ask = FALSE)

# add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1

# utilizing scDEED output
min(scDEEDResult$num_dubious$number_dubious_cells) # 437 # 26 with opt
opt <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells))
m <- scDEEDResult$num_dubious$min.dist[opt] # 0.1 # 0.3 #0.5
n <- scDEEDResult$num_dubious$n_neighbors[opt] # 30 (only value tested) # 5 #5

dubious_cells <- scDEEDResult$full_results$dubious_cells[opt]
dubious_cells <- as.numeric(strsplit(dubious_cells, ",")[[1]])
trustworthy_cells <- scDEEDResult$full_results$trustworthy_cells[opt]
trustworthy_cells <- as.numeric(strsplit(trustworthy_cells, ",")[[1]])
set.seed(6022)
SeuratUMAPscDEEDOpt <- RunUMAP(seuratTreg,
  dims = 1:K_,
  min.dist = m,
  n.neighbors = n)
# seed.use = 100)

# match up the dubious/trustworthy lists with the seurat data
rownames_seurat <- rownames(SeuratUMAPscDEEDOpt@meta.data)
rownames_dubious <- rownames_seurat[dubious_cells]
rownames_trustworthy <- rownames_seurat[trustworthy_cells]

designation <- rep("intermediate", length(rownames_seurat))

designation[rownames_seurat %in% rownames_dubious] <- "dubious"
designation[rownames_seurat %in% rownames_trustworthy] <- "trustworthy"

SeuratUMAPscDEEDOpt@meta.data$designation <- designation
# end of scDEED

set.seed(6022)
seuratTreg <- RunUMAP(object = seuratTreg,
  reduction = "pca",
  dims = 1:16,
  n.neighbors = 5, # 30
  min.dist = 0.7) # 0.1

# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName[["RNA"]] <- paste0("seurat_clusters_RNA_", str_replace(clusterResolution[["RNA"]], "\\.", "p"))

# Add metadata to the Seurat object
seuratTreg <- seuratTreg %>%
  AddMetaData(Idents(seuratTreg), col.name = clusterName[["RNA"]])

# Set the identifiers
Idents(seuratTreg) <- seuratTreg@meta.data[[clusterName[["RNA"]]]]

# Ensure data layers are joined
seuratTreg <- JoinLayers(seuratTreg)

# Perform the FindAllMarkers function and store the results in clusterMarkers
clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]] <-
  FindAllMarkers(seuratTreg, assay = "RNA")

# Print cluster markers
print("Cluster markers found:")
print(clusterMarkers[[paste0("RNA_", clusterName[["RNA"]])]])

palRNAClusters <-
  big_colorblind_pal(
    n_distinct(seuratTreg@meta.data[[clusterName[["RNA"]]]]),
    shuffle_colors = TRUE,
    drop_yellow = TRUE, drop_black = TRUE) %>%
  setNames(sort(unique(seuratTreg@meta.data[[clusterName[["RNA"]]]])))

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratTreg@meta.data[[clusterName[["RNA"]]]])

# Get the "ggsci::uniform_startrek" palette and adjust it
palRNAClusters <- paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratTreg@meta.data[[clusterName[["RNA"]]]])))

# rm_tmp(ask = FALSE)
```

```{r clusterTconvSeparately}
# make a subset seurat object that only contains the cells where $cellType == "Treg"
seuratTconv <- subset(seuratQCMergedCleanedDS, subset = cellType == "Tconv")

# now subset down to the cells in RNAseq clusters 3 and 4
seuratTconv <- subset(seuratQCMergedCleanedDS, subset = seurat_clusters %in% c("0", "1", "2", "5", "6"))

# save old clusters
seuratTconv@meta.data$seuratClustersAllCellsDS <- seuratTconv@meta.data$seurat_clusters

# Re-run normalization, clustering, UMAP, etc on this subset
DefaultAssay(seuratTconv) <- "RNA"
seuratTconv <- SeuratObject::JoinLayers(seuratTconv, layers = c("RNA"))
seuratTconv <- NormalizeData(object = seuratTconv,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratTconv <- NormalizeData(object = seuratTconv,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

# seuratTconv <- NormalizeData(object = seuratTconv, verbose = FALSE)
seuratTconv <- FindVariableFeatures(object = seuratTconv,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratTconv <- ScaleData(object = seuratTconv, verbose = FALSE)
seuratTconv <- RunPCA(object = seuratTconv, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratTconv)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)

# let's do some hyperparameter optimization
# create grid of hyperparameters to test
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 8, 12, 14, 20), # these values were chosen after examining the elbow plot.
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5) # these values were chosen somewhat arbitrarily
)

# the size of these vectors largely determines the cost of this function in walltime
min.dist.vector <-  c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
n_neighbors.vector <- c(5, 20, 30, 40, 50)

# testing
startTime <- Sys.time()

resultTconv <- optimizeRNAseqClustering(seuratTconv,
  hyperParamGridPCA.df,
  min.dist.vector,
  n_neighbors.vector,
  maxNClusters = 10,
  minNClusters = 5) # because we're starting with 5

endTime <- Sys.time()
timeElapsed <- endTime - startTime
print(timeElapsed)

# Extract the data frames from the result
hyperParamGridOptClusterAndUMAP.df <- resultTconv$hyperParamGridOptClusterAndUMAP.df
hyperParamGridClusterOnly.df <- resultTconv$hyperParamGridClusterOnly.df

write.xlsx(hyperParamGridOptClusterAndUMAP.df, file = file.path(dataOutputDir, "20241210_RNA_clustering_TconvOnly_hyperParamGrid.xlsx"))

# TODO automate
# process Tconv cells for each different nCluster of interest
set.seed(6022)
seuratTconv <- FindNeighbors(seuratTconv, dims = 1:12)
seuratTconv <- FindClusters(seuratTconv, resolution = 0.8)

set.seed(6022)
seuratTconv <- RunUMAP(object = seuratTconv, reduction = "pca",
  # reduction.key = "umap",
  dims = 1:12,
  n.neighbors = 50,
  min.dist = 0.2)


# store cluster info in seurat object metadata
# Initialize clusterName and clusterMarkers
clusterName <- character()
clusterMarkers <- list()

# Create the cluster name for RNA
clusterName <- paste0("seurat_clusters_Tconv")

# Add metadata to the Seurat object
seuratTconv <- seuratTconv %>%
  AddMetaData(Idents(seuratTconv), col.name = clusterName)

# Set the identifiers
Idents(seuratTconv) <- seuratTconv@meta.data[[clusterName]]

# Ensure data layers are joined
seuratTconv <- JoinLayers(seuratTconv)

# Get the number of distinct RNA clusters
num_clusters <- n_distinct(seuratTconv@meta.data[[clusterName]])

# Get the "ggsci::uniform_startrek" palette and adjust it
palRNAClusters <- paletteer_d("basetheme::royal", n = num_clusters) %>% # paletteer_d("khroma::okabeitoblack", n = num_clusters) %>%
  sample() %>%  # Shuffle colors
  .[!grepl("yellow|black", .)] %>%  # Drop yellow and black colors
  setNames(sort(unique(seuratTconv@meta.data[[clusterName]])))
```

```{r lookAtClustersTregs}

nClust <- length(table(seuratTreg@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_TregOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTreg,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_clusterFacet_TregOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTreg,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seuratTreg@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seuratTreg@meta.data$seurat_clusters
umap_data$stimulationFigures <- seuratTreg@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_stimulationFacet_TregOnly.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = seurat_clusters)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r clusterProportionPlotsWithCellTypeCalls}
nClust <- length(table(seuratTreg@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratTreg@meta.data$studyGroup <- as.factor(seuratTreg@meta.data$studyGroup)
seuratTreg@meta.data$stimulationFigures <- as.factor(seuratTreg@meta.data$stimulationFigures)
seuratTreg@meta.data$donorIdFigures <- as.factor(seuratTreg@meta.data$donorIdFigures)
seuratTreg@meta.data$seurat_clusters <- as.factor(seuratTreg@meta.data$seurat_clusters)
seuratTreg@meta.data$seuratClustersAllCellsDS <- as.factor(seuratTreg@meta.data$seuratClustersAllCellsDS)
seuratTreg@meta.data$cellType <- as.factor(seuratTreg$cellType)
seuratTreg@meta.data$cellTypistCalling <- as.factor(seuratTreg$cellTypistCalling)

# Extract metadata
metadata.tmp <- seuratTreg@meta.data

# all together now
# Create the three plots
plot1.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot2.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot3.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot4.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = seuratClustersAllCellsDS)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Original Clusters") +
  # scale_fill_manual(values = palCellType) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot5.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1.tmp, plot2.tmp, plot3.tmp, plot4.tmp, plot5.tmp, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_TregOnly.pdf")), height = 9, width = 8)
print(combined_plot)
dev.off()
```

```{r getTop10ClusterDefiningGenesDownsampled}
DefaultAssay(seuratTreg) <- "RNA"
Idents(seuratTreg) <- "seurat_clusters"
# Join the data layers
seuratTreg <- JoinLayers(seuratTreg)

clusterMarkers <- FindAllMarkers(seuratTreg)

# implement a filter so that we only consider genes expressed in a certain percentage of cells
# Calculate the percentage of cells with non-zero expression for each gene in each cluster
expressionData <- FetchData(seuratTreg, vars = unique(clusterMarkers$gene))
metadata <- seuratTreg@meta.data %>%
  dplyr::select(seurat_clusters) %>%
  rownames_to_column("cell")

expressionData <- expressionData %>%
  rownames_to_column("cell") %>%
  left_join(metadata, by = "cell")

expressionDataLong <- expressionData %>%
  pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

expressionDataSummary <- expressionDataLong %>%
  group_by(seurat_clusters, gene) %>%
  summarise(percent_expressed = mean(expression > 0) * 100)

min_percent_expressed <- 30
clusterMarkers <- clusterMarkers %>%
  left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
  filter(percent_expressed >= min_percent_expressed)
# end of expressed in x% of cells filtering


topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = 10) %>%
  dplyr::slice_min(p_val_adj, n = 10) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters)) # , each = 4

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataOutputDir, "top10_genes_per_cluster_downsampled_Treg.csv"), quote = FALSE, row.names = TRUE)
```

```{r clusterDefiningGenesDotPlot}
nClust <- length(table(seuratTreg@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 12

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
dot_plot <- DotPlot(seuratTreg, features = genes.tmp) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
    text = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Print the DotPlot
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_clusterDefiningGenesDotPlotTregs.pdf")), height = 5, width = 12)
print(dot_plot)
dev.off()

rm_tmp(ask = FALSE)
```

```{r showstemnessScoreOnUMAPTregOnly}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScore_TregOnly.pdf")),
height = 6,
width = 12)

FeaturePlot(object = seuratTreg,
  features = "stemnessScore",
  reduction = "umap",
  pt.size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1)
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_stimulationFacetTregOnly.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratTreg, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTreg@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = stemnessScore)) +
  geom_point(size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()
```

```{r makeAirlinePlotTregOnly}
# -------------------all three stimulations---------------------------------
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seuratTreg@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
# print(cdr3CloneID_filtered)
airlinePlot(seuratTreg,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTregOnly4Clust")

airlinePlotDonorId(seuratTreg,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTregOnly4ClustDonorId")

# --------------------------------------------------------------------------

# -----------------------------------IAR------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTreg, subset = stimulationFigures == "IAR")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTregOnly4ClustIAR")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTregOnly4ClustIARDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Microbial------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTreg, subset = stimulationFigures == "Microbial")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTregOnly4ClustMicrobial")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTregOnly4ClustMicrobialDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Polyclonal------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTreg, subset = stimulationFigures == "Polyclonal")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTregOnly4ClustPolyclonal")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTregOnly4ClustPolyclonalDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------
```

### Tconv only analysis

```{r lookAtClustersTconvs}

nClust <- length(table(seuratTconv@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_TconvOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTconv,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) #+
#   facet_wrap(~seurat_clusters)

dev.off()

pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_clusterFacet_TconvOnly.pdf")),
height = 6,
width = 10)

DimPlot(object = seuratTconv,
  reduction = "umap",
  group = "seurat_clusters",
  pt.size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~seurat_clusters)

dev.off()

# Extract UMAP coordinates and metadata
umap_data <- as.data.frame(seuratTconv@reductions$umap@cell.embeddings)
umap_data$seurat_clusters <- seuratTconv@meta.data$seurat_clusters
umap_data$stimulationFigures <- seuratTconv@meta.data$stimulationFigures

# Create the plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, nClustString, "_UMAP_RNA_stimulationFacet_TconvOnly.pdf")),
height = 6,
width = 10)

ggplot(umap_data, aes(x = umap_1, y = umap_2, color = seurat_clusters)) +
  geom_point(size = 1) +
  scale_color_manual(values = palRNAClusters) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cluster", title = "") +
  theme(aspect.ratio = 1, legend.position = "none") +
  facet_wrap(~stimulationFigures)

dev.off()
```

```{r clusterProportionPlotsWithCellTypeCalls}
nClust <- length(table(seuratTconv@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

# Ensure the variables are factors
seuratTconv@meta.data$studyGroup <- as.factor(seuratTconv@meta.data$studyGroup)
seuratTconv@meta.data$stimulationFigures <- as.factor(seuratTconv@meta.data$stimulationFigures)
seuratTconv@meta.data$donorIdFigures <- as.factor(seuratTconv@meta.data$donorIdFigures)
seuratTconv@meta.data$seurat_clusters <- as.factor(seuratTconv@meta.data$seurat_clusters)
seuratTconv@meta.data$seuratClustersAllCellsDS <- as.factor(seuratTconv@meta.data$seuratClustersAllCellsDS)
seuratTconv@meta.data$cellType <- as.factor(seuratTconv$cellType)
seuratTconv@meta.data$cellTypistCalling <- as.factor(seuratTconv$cellTypistCalling)

# Extract metadata
metadata.tmp <- seuratTconv@meta.data

# all together now
# Create the three plots
plot1.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = studyGroup)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Study Group") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot2.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = stimulationFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Stimulation") +
  scale_fill_manual(values = palStimulation) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot3.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = donorIdFigures)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Donor ID") +
  scale_fill_manual(values = palDonorId) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot4.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = seuratClustersAllCellsDS)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Original Clusters") +
  # scale_fill_manual(values = palCellType) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
    axis.title.x = element_blank())

plot5.tmp <- ggplot(metadata.tmp, aes(x = seurat_clusters, fill = cellTypistCalling)) +
  geom_bar(position = "fill") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "CellTypist calling") +
  scale_fill_manual(values = palCellTypist) +
  theme_minimal()

# Combine the plots vertically
combined_plot <- plot_grid(plot1.tmp, plot2.tmp, plot3.tmp, plot4.tmp, plot5.tmp, ncol = 1, align = "v")

# Save the combined plot to a PDF
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_Combined_Proportions_in_seurat_clusters_TconvOnly.pdf")), height = 9, width = 8)
print(combined_plot)
dev.off()
```

```{r getTop10ClusterDefiningGenesDownsampled}
DefaultAssay(seuratTconv) <- "RNA"
Idents(seuratTconv) <- "seurat_clusters"
# Join the data layers
seuratTconv <- JoinLayers(seuratTconv)

clusterMarkers <- FindAllMarkers(seuratTconv)

# implement a filter so that we only consider genes expressed in a certain percentage of cells
# Calculate the percentage of cells with non-zero expression for each gene in each cluster
expressionData <- FetchData(seuratTconv, vars = unique(clusterMarkers$gene))
metadata <- seuratTconv@meta.data %>%
  dplyr::select(seurat_clusters) %>%
  rownames_to_column("cell")

expressionData <- expressionData %>%
  rownames_to_column("cell") %>%
  left_join(metadata, by = "cell")

expressionDataLong <- expressionData %>%
  pivot_longer(cols = -c(cell, seurat_clusters), names_to = "gene", values_to = "expression")

expressionDataSummary <- expressionDataLong %>%
  group_by(seurat_clusters, gene) %>%
  summarise(percent_expressed = mean(expression > 0) * 100)

min_percent_expressed <- 30
clusterMarkers <- clusterMarkers %>%
  left_join(expressionDataSummary, by = c("cluster" = "seurat_clusters", "gene" = "gene")) %>%
  filter(percent_expressed >= min_percent_expressed)
# end of expressed in x% of cells filtering


topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = 10) %>%
  dplyr::slice_min(p_val_adj, n = 10) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters)) # , each = 4

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleanedDS$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

# write.csv(topMarkers, file.path(dataOutputDir, "top10_genes_per_cluster_downsampled_Treg.csv"), quote = FALSE, row.names = TRUE)
```

```{r clusterDefiningGenesDotPlot}
nClust <- length(table(seuratTconv@meta.data$seurat_clusters))
nClustString <- paste0("_", as.character(nClust), "Clusters")

fontSize <- 12

# Extract the gene names from the topMarkers tibble
genes.tmp <- unique(unlist(topMarkers))

# Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
dot_plot <- DotPlot(seuratTconv, features = genes.tmp) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
    text = element_text(size = fontSize),
    axis.text.y = element_text(size = fontSize),
    axis.title.y = element_text(size = fontSize),
    legend.text = element_text(size = fontSize),
    legend.title = element_text(size = fontSize),
    strip.text = element_text(size = fontSize),
    plot.title = element_text(size = fontSize))

# Print the DotPlot
pdf(file.path(plotDir, paste0(filenameSuffix, nClustString, "_clusterDefiningGenesDotPlotTconvs.pdf")), height = 5, width = 12)
print(dot_plot)
dev.off()

rm_tmp(ask = FALSE)
```

```{r showstemnessScoreOnUMAPTconvOnly}
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_stemnessScore_TconvOnly.pdf")),
height = 6,
width = 12)

FeaturePlot(object = seuratTconv,
  features = "stemnessScore",
  reduction = "umap",
  pt.size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1)
#   facet_wrap(~seurat_clusters)

dev.off()

# Ensure 'seurat_clusters' exists, then proceed with plotting
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_stimulationFacetTconvOnly.pdf")), height = 5.5, width = 10)

# Extract UMAP data
umap_data <- Embeddings(seuratTconv, "umap")

# Name the columns of umap_data explicitly to match expected names in ggplot
colnames(umap_data) <- c("UMAP_1", "UMAP_2")

# Convert umap_data to a data frame
umap_data_df <- as.data.frame(umap_data)

# Add row names as a new column for merging
umap_data_df$cells <- rownames(umap_data_df)

# Ensure metadata has a column to merge on, typically cell names
metadata <- seuratTconv@meta.data
metadata$cells <- rownames(metadata)

# Combine UMAP data with metadata for plotting
plot_data <- merge(umap_data_df, metadata, by = "cells")

# Use ggplot for plotting to manually handle facets and colors
p <- ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = stemnessScore)) +
  geom_point(size = 1) +
  scale_color_viridis_c() +
  labs(x = "UMAP 1", y = "UMAP 2", color = "stemnessScore", title = "") +
  theme(aspect.ratio = 1) +
  facet_wrap(~stimulationFigures) # Now using the combined data

print(p)
dev.off()
```

```{r makeAirlinePlotTconvOnly}
# -------------------all three stimulations---------------------------------
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seuratTconv@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
# print(cdr3CloneID_filtered)
airlinePlot(seuratTconv,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTconvOnly5Clust")

airlinePlotDonorId(seuratTconv,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimTconvOnly5ClustDonorId")

# --------------------------------------------------------------------------

# -----------------------------------IAR------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTconv, subset = stimulationFigures == "IAR")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTconvOnly5ClustIAR")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARTconvOnly5ClustIARDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Microbial------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTconv, subset = stimulationFigures == "Microbial")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTconvOnly5ClustMicrobial")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nMicrobial/CEFX",
  plotName = "AirlinePlotIARTconvOnly5ClustMicrobialDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Polyclonal------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratTconv, subset = stimulationFigures == "Polyclonal")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTconvOnly5ClustPolyclonal")

airlinePlotDonorId(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotIARTconvOnly5ClustPolyclonalDonorId")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------
```

### End of Tconv-only analysis

```{r plotTconvsTregsOnUMAP}
# Print unique values of stimulationFigures to verify
print(unique(seuratQCMergedCleanedDS$stimulationFigures))

# Print the distribution of stimulationFigures values
print(table(seuratQCMergedCleanedDS$stimulationFigures))

# Define the stimulation values manually
stimulation_values <- c("IAR", "Polyclonal", "Microbial")

for (stimulation in stimulation_values) {

  seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == stimulation)
}
# Loop over each stimulation value
for (stimulation in stimulation_values) {
  # Print the current stimulation value for debugging
  print(paste("Processing stimulation:", stimulation))

  # Check if the stimulation value exists in the data
  if (!(stimulation %in% seuratQCMergedCleanedDS$stimulationFigures)) {
    print(paste("Stimulation value not found in data:", stimulation))
    next
  }

  # Print the first few rows of the data before subsetting
  print(head(seuratQCMergedCleanedDS@meta.data))

  # Subset the Seurat object to only include cells with the current stimulation value
  seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == stimulation)

  # Print the subset condition and the first few rows of the subset data
  print(paste("Subset condition: stimulationFigures == ", stimulation))
  print(head(seurat_subset.tmp@meta.data))

  # Print the number of cells found for debugging
  print(paste("Number of cells found:", nrow(seurat_subset.tmp@meta.data)))

  # Check if any cells were found
  if (nrow(seurat_subset.tmp@meta.data) == 0) {
    print(paste("No cells found for stimulation:", stimulation))
    next
  }

  # Define colors for the cell types
  cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

  # Create the UMAP plot
  pdf(file.path(plotDir,
    paste0(filenameSuffix, "_UMAP_RNA_", stimulation, "_TregTconvByTotalSeq", ".pdf")),
  height = 6,
  width = 12)

  DimPlot(object = seurat_subset.tmp,
    reduction = "umap",
    group.by = "cellType",
    cols = cellTypeColors) +
    labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = stimulation) +
    theme(aspect.ratio = 1)

  dev.off()
}
```

```{r debugCopilotsAwfulSuggestions}

# Subset the Seurat object to only include cells with the current stimulation value
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "IAR")

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_", "IAR", "_TregTconvByTotalSeq", ".pdf")),
height = 5.5,
width = 5)

DimPlot(object = seurat_subset.tmp,
  reduction = "umap",
  group.by = "cellType",
  cols = cellTypeColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = "IAR") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)

# Subset the Seurat object to only include cells with the current stimulation value
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Polyclonal")

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_", "Polyclonal", "_TregTconvByTotalSeq", ".pdf")),
height = 5.5,
width = 5)

DimPlot(object = seurat_subset.tmp,
  reduction = "umap",
  group.by = "cellType",
  cols = cellTypeColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = "Polyclonal") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)

# Subset the Seurat object to only include cells with the current stimulation value
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Microbial")

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot
pdf(file.path(plotDir,
  paste0(filenameSuffix, "_UMAP_RNA_", "Microbial", "_TregTconvByTotalSeq", ".pdf")),
height = 5.5,
width = 5)

DimPlot(object = seurat_subset.tmp,
  reduction = "umap",
  group.by = "cellType",
  cols = cellTypeColors) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq", title = "Microbial") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)
```

```{r TconvTregByTotalSeqOnUMAPFacetByStim}
# Extract UMAP coordinates
umap_coords <- Embeddings(seuratQCMergedCleanedDS, "umap")

# Create a data frame for plotting
plot_data <- data.frame(
  UMAP_1 = umap_coords[, 1],
  UMAP_2 = umap_coords[, 2],
  cellType = seuratQCMergedCleanedDS$cellType,
  stimulationFigures = seuratQCMergedCleanedDS@meta.data$stimulationFigures
)

# Define colors for the cell types
cellTypeColors <- c("Other" = "grey", "Treg" = "blue", "Tconv" = "red")

# Create the UMAP plot with ggplot2 and facet_wrap
pdf(file.path(plotDir, paste0(filenameSuffix, "_UMAP_RNA_TregTconvByTotalSeq.pdf")), height = 5.5, width = 12)

ggplot(plot_data, aes(x = UMAP_1, y = UMAP_2, color = cellType)) +
  geom_point(size = 0.5) +
  scale_color_manual(values = cellTypeColors) +
  facet_wrap(~stimulationFigures) +
  labs(x = "UMAP 1", y = "UMAP 2", color = "Cell type by\nTotalSeq") +
  theme(aspect.ratio = 1)

dev.off()

# Clean up temporary variables
rm_tmp(ask = FALSE)
```

```{r getClusterDefiningGenes}
DefaultAssay(seuratQCMergedCleaned) <- "RNA"
Idents(seuratQCMergedCleaned) <- "seurat_clusters"
# Join the data layers
seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned)

clusterMarkers <- FindAllMarkers(seuratQCMergedCleaned)

topMarkersLong <- clusterMarkers %>%
  dplyr::group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 0) %>%
  dplyr::slice_max(avg_log2FC, n = 10) %>%
  dplyr::slice_min(p_val_adj, n = 10) %>%
  dplyr::mutate(fc_order = order(avg_log2FC))

topMarkers <- topMarkersLong %>%
  pivot_wider(id_cols = "fc_order",
    names_from = "cluster",
    values_from = "gene")

topMarkersWide <- clusterMarkers %>%
  # dplyr::filter(!str_detect(gene, "Trav|Trbv")) %>%
  dplyr::mutate(cluster_id = paste0("Cluster ", cluster),
    cluster_id = factor(cluster_id, levels = mixedsort(unique(cluster_id)))) %>%
  dplyr::group_by(cluster_id) %>%
  dplyr::mutate(row_order = order(p_val_adj)) %>%
  pivot_wider(id_cols = row_order,
    names_from = "cluster_id",
    names_glue = "{cluster_id}_{.value}",
    values_from = c("cluster_id",
      "gene",
      "avg_log2FC",
      "p_val_adj"))

clusters <- unique(clusterMarkers$cluster) %>% mixedsort()
clusterLabs <- paste0("Cluster ", rep(clusters, each = 4))

columnLabs <- c("cluster_id",
  "gene",
  "avg_log2FC",
  "p_val_adj")

nClust <- length(unique(seuratQCMergedCleaned$seurat_clusters))
columnLabs <- rep(columnLabs, nClust)

columnLabs <- paste0(clusterLabs, "_", columnLabs)

topMarkersWide <- topMarkersWide %>%
  dplyr::select(columnLabs)
#```

### Top-cluster defining genes

# The top 10 cluster defining genes are shown in the table below. These genes are selected by ranking by p-value among genes that are up in a given cluster relative to all others. 

# ```{r clust_table, results = 'asis'}
topMarkers <- topMarkers %>%
  dplyr::select(-one_of("fc_order"))

topMarkers %>%
  kable(row.names = F) %>%
  kable_styling("striped",
    full_width = F,
    position = "left") %>%
  scroll_box(height = "900px")

write.csv(topMarkers, file.path(dataInputDir, "top10_genes_per_cluster_default.csv"), quote = FALSE, row.names = TRUE)
```

```{r P390GenesHeatmap}
genesOfInterest <- c("LDHB", "FABP5", "MYO1B", "ACSL6", "FZD3", "FASLG",
  "SPRY1", "UBE2E2", "RGCC", "TNFSF11", "ZNF704", "RAI2",
  "TTC8", "IL2", "DHRS3", "NELL2", "MAMLD1", "MAP7",
  "C1orf228", "IL3", "CSF2", "XCL1", "LRRN3", "FHL1",
  "RRAGD", "ADORA2B", "CNN3", "JAK1", "FTL", "CTLA4",
  "SYTL3", "ZNF292", "CHST11", "IL2RA", "PICALM", "IL2RB",
  "GNG2", "IL32", "CD74", "CD74", "ARL6IP5", "TIGIT",
  "IKZF2", "CTTNBP2NL", "FUT7", "MAN1A2", "ENTPD1", "LRRC32",
  "CCR8", "HLA-DQA1", "HLA-DRB1", "HLA-DRB5", "HLA-DQA2", "IL1R2",
  "FOXP3", "IL1R1", "CISH", "TXN", "TNFRSF18", "TPMT",
  "SFT2D1")

seuratQCMergedCleaned@meta.data
# heatmap of these genes with columns by seurat_cluster
```

```{r integrationByDonor}
### for CD4s
## version with split by project
# Split seurat object by the donor ID
seuratQCMergedCleanedSplitDonor <- SplitObject(seuratQCMergedCleaned, split.by = "donorId")

# find integration anchors
maxDims.tmp <- 6 # usually teens, selected from elbow plot of PCs
# ran into issues with anchor/filter/score larger than maxDims
# filter and score may not be necessary
integAnchorsseuratQCMergedCleanedSplitDonor <- FindIntegrationAnchors(
  object.list = seuratQCMergedCleanedSplitDonor,
  dims = 1:min(30, maxDims.tmp),
  k.anchor = min(5, maxDims.tmp),
  k.filter = min(200, maxDims.tmp),
  k.score = min(30, maxDims.tmp)
)

# run the integration
seuratQCMergedCleanedSplitDonorInteg <- IntegrateData(
  integAnchorsseuratQCMergedCleanedSplitDonor,
  dims = 1:min(30, maxDims.tmp),
  k.weight = min(100, maxDims.tmp)
)
```

```{r makeAirlinePlotFunction}

# this version colors cells by CITEseq/FB/TotalSeq surface marker gating cellType
airlinePlotFB <- function(seuratObj,
                          cloneIDColumn,
                          cloneIDs,
                          arcLinewidth = 0.2,
                          arcAlpha = 0.5,
                          savePlot = FALSE,
                          plotTitle, # string
                          plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellType") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cell type \nby TotalSeq") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = c("Treg" = "blue", "Tconv" = "red", "Other" = "grey")) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors cells by CITEseq/FB/TotalSeq surface marker gating cellType (DSB norm)
airlinePlotFBDSB <- function(seuratObj,
                             cloneIDColumn,
                             cloneIDs,
                             arcLinewidth = 0.2,
                             arcAlpha = 0.5,
                             savePlot = FALSE,
                             plotTitle, # string
                             plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellTypeDSB") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cell type \nby TotalSeq") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = c("Treg" = "blue", "Tconv" = "red", "Other" = "grey")) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors cells by CITEseq/FB/TotalSeq surface marker gating cellType
# and omits some labels, has larger label text throughout to look good on a poster
airlinePlotFBPoster <- function(seuratObj,
                                cloneIDColumn,
                                cloneIDs,
                                arcLinewidth = 0.4,
                                arcAlpha = 0.5,
                                savePlot = FALSE,
                                plotTitle, # string
                                plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellType") +
    # labs(title = "") +
    labs(title = plotTitle, color = "Cell type \nby TotalSeq") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = c("Treg" = "blue", "Tconv" = "red", "Other" = "grey")) +
    theme(aspect.ratio = 1,
      text = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.text = element_text(size = 16),
      legend.title = element_text(size = 16),
      strip.text = element_text(size = 16),
      plot.title = element_text(size = 16, face = "plain"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = "none")

  if (savePlot == TRUE) {

    pdf(file = file.path(plotDir, paste0(plotName, ".pdf")),
      width = 3.5,
      height = 3.5)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors points by RNAseq clusters
airlinePlot <- function(seuratObj,
                        cloneIDColumn,
                        cloneIDs,
                        arcLinewidth = 0.2,
                        arcAlpha = 0.5,
                        savePlot = FALSE,
                        plotTitle,
                        plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "seurat_clusters") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cluster") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = palRNAClusters) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors cells by CellTypist cell type calling
airlinePlotCT <- function(seuratObj,
                          cloneIDColumn,
                          cloneIDs,
                          arcLinewidth = 0.1,
                          arcAlpha = 0.5,
                          savePlot = FALSE,
                          plotTitle, # string
                          plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "cellTypistCalling") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Cell type \nby CellTypist") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = palCellTypist) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}

# this version colors points by DonorId
airlinePlotDonorId <- function(seuratObj,
                               cloneIDColumn,
                               cloneIDs,
                               arcLinewidth = 0.2,
                               arcAlpha = 0.5,
                               savePlot = FALSE,
                               plotTitle,
                               plotName = "AirlinePlot") {

  DefaultAssay(seuratObj) <- "RNA"

  # Make sure a umap project exits

  if (is.null(seuratObj@reductions$umap)) {
    stop("UMAP must first be run on the Seurat object")
  }

  # Make sure the clone ID column exists
  if (!(cloneIDColumn %in% colnames(seuratObj@meta.data))) {
    stop("Check that the clone ID column exists in the metadata")
  }



  # Link umap coordinates to cloneIDs
  umapDF <- data.frame(cloneID = seuratObj@meta.data[, cloneIDColumn],
    umap1 = seuratObj@reductions$umap@cell.embeddings[, 1],
    umap2 = seuratObj@reductions$umap@cell.embeddings[, 2])

  # Filter the umapDF to only include the cloneIDs of interest
  umapDF <- umapDF %>%
    dplyr::filter(cloneID %in% cloneIDs)

  # create data frame to store links
  curves.tmp <-
    data.frame(
      cloneID = character(),
      x = numeric(),
      y = numeric(),
      xend = numeric(),
      yend = numeric())

  # loop over each clone, and extract coordinates for cells from the same clone
  for (clone_id.tmp in na.omit(unique(umapDF$cloneID))) {
    clone_id_curves.tmp <- curves.tmp[0, ]
    data_for_curves.tmp <-
      umapDF %>%
      dplyr::filter(cloneID %in% clone_id.tmp)
    for (i in 1:(nrow(data_for_curves.tmp) - 1)) {
      for (j in (i + 1):nrow(data_for_curves.tmp)) {
        clone_id_curves.tmp <-
          rbind(
            clone_id_curves.tmp,
            list(
              cloneID =
                data_for_curves.tmp$cloneID[i],
              x = data_for_curves.tmp$umap1[i],
              y = data_for_curves.tmp$umap2[i],
              xend = data_for_curves.tmp$umap1[j],
              yend = data_for_curves.tmp$umap2[j]))
      }
    }
    curves.tmp <-
      rbind(curves.tmp, clone_id_curves.tmp)
  }

  gPlot <- DimPlot(object = seuratObj, reduction = "umap", group.by = "donorIdFigures") +
    # labs(title = "") +
    labs(title = plotTitle, x = "UMAP 1", y = "UMAP 2", color = "Donor ID") +
    geom_curve(
      data = curves.tmp,
      mapping = aes(x = x, y = y, xend = xend, yend = yend),
      linewidth = arcLinewidth,
      alpha = arcAlpha)  +
    scale_color_manual(values = palDonorId) +
    theme(aspect.ratio = 1)

  if (savePlot == TRUE) {

    png(file = file.path(plotDir, paste0(plotName, ".png")),
      width = 7,
      height = 5.5,
      units = "in",
      res = 600)

    print(gPlot)

    invisible(dev.off())
  }

  return(gPlot)
}
```

```{r makeAirlinePlot}
# -------------------all three stimulations---------------------------------
# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seuratQCMergedCleanedDS@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
# print(cdr3CloneID_filtered)
airlinePlot(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStim")

airlinePlotFB(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimFB")

airlinePlotFBDSB(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimFBDSB")

airlinePlotFBPoster(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "All stimulations",
  plotName = "AirlinePlotAllStimFBPoster")

airlinePlotCT(seuratQCMergedCleanedDS,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences",
  plotName = "AirlinePlotAllStimCT")

# --------------------------------------------------------------------------

# -----------------------------------IAR------------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "IAR")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIAR")

airlinePlotFB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARFB")

airlinePlotFBDSB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARFBDSB")

airlinePlotFBPoster(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "IAR",
  plotName = "AirlinePlotIARFBPoster")

airlinePlotCT(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nIAR",
  plotName = "AirlinePlotIARCT")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------CEFX-----------------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Microbial")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobial")

airlinePlotFB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobialFB")

airlinePlotFBDSB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobialFBDSB")

airlinePlotFBPoster(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Microbial",
  plotName = "AirlinePlotMicrobialFBPoster")

airlinePlotCT(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nCEFX",
  plotName = "AirlinePlotMicrobialCT")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------

# -----------------------------------Polyclonal-----------------------------
# make subset Seurat object
seurat_subset.tmp <- subset(seuratQCMergedCleanedDS, subset = stimulationFigures == "Polyclonal")

# Extract the cdr3CloneID column from the metadata
cdr3CloneIDs <- seurat_subset.tmp@meta.data$cdr3CloneID

# Count the occurrences of each cdr3CloneID
cdr3CloneID_counts <- table(cdr3CloneIDs)

# Filter the IDs that have 3 or more occurrences
cdr3CloneID_filtered <- names(cdr3CloneID_counts[cdr3CloneID_counts >= 2])

# Print the filtered cdr3CloneID names
print(cdr3CloneID_filtered)

airlinePlot(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonal")

airlinePlotFB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonalFB")

airlinePlotFBDSB(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonalFBDSB")

airlinePlotFBPoster(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Polyclonal",
  plotName = "AirlinePlotPolyclonalFBPoster")

airlinePlotCT(seurat_subset.tmp,
  cloneIDColumn = "cdr3CloneID",
  cloneIDs = cdr3CloneID_filtered, # c("Clone_378"),
  savePlot = TRUE,
  plotTitle = "Clone IDs with 2+ occurrences\nPolyclonal",
  plotName = "AirlinePlotPolyclonalCT")

rm_tmp(ask = FALSE)
# --------------------------------------------------------------------------
```

### Matt D - style Circos plot chunks

```{r createObjectsPlotCircosQcCd8}
# add seuratQCMergedCleanedDS@meta.data$cellType to TCRs.DS.df, matching on $barcode
metaData.df.tmp <- seuratQCMergedCleanedDS@meta.data %>%
  dplyr::select(barcode, cellType)

# Perform the left join to add cellType to TCRs.DS.df
TCRs.DS.df <- TCRs.DS.df %>%
  left_join(metaData.df.tmp, by = "barcode")

rm_tmp(ask = FALSE)

# # make $stimulationFigures where the values in $stimulation map from "CD3CD28", "CEFX", "Islet"
# # to "Polyclonal", "Microbial", "IAR"
stimulation_mapping <- c(
  "CD3CD28" = "Polyclonal",
  "CEFX" = "Microbial",
  "Islet" = "IAR"
)

# # Assuming your data frame is named df
# # Add the stimulationFigures column to the data frame
TCRs.DS.df$stimulationFigures <- stimulation_mapping[TCRs.DS.df$stimulation]

## define columns for sample and group variables
sampleColumnCircosQcCd8 <- "cellType"
groupColumnCircosQcCd8 <- "studyGroup"

# Filter TCRs to those of interest
tcrsCircos <- TCRs.DS.df

# Add sample info (sample and group) to the tcr df
# tcrsCircosQcCd8 <-
#   left_join(
#     tcrsCircosQcCd8,
#     annotatedMetricsQC %>% dplyr::select(libid, all_of(c(sampleColumnCircosQcCd8, groupColumnCircosQcCd8))))
# check for columns duplicated in tcr and annotation.merged
# grep("\\.[xy]", colnames(tcrsCircosQcCd8), value=TRUE)
# none; good!

# sort tcrsCircosQcCd8 by the variables of interest (which might be unnecessary?)
# tcrsCircosQcCd8 <-
#   tcrsCircosQcCd8[
#     order(tcrsCircosQcCd8[, groupColumnCircosQcCd8, drop = TRUE],
#       tcrsCircosQcCd8[, sampleColumnCircosQcCd8, drop = TRUE]), ]

# # Make a new numeric libid number for each lib, in the order libs have been arranged, to facilitate plotting order
# tcrsCircosQcCd8 <-
#   tcrsCircosQcCd8 %>%
#   dplyr::rename(old.libid = libid)
# tcrsCircosQcCd8$libid <-
#   tcrsCircosQcCd8$old.libid %>%
#   match(unique(.))

### determine expanded TCRs
tcrChainMatchesCircos <- match_TCR_chains(tcrsCircos)
tcrChainMatchesCircosQcCd8[, c("tcr1", "tcr2")] <-
  lapply(tcrChainMatchesCircosQcCd8[, c("tcr1", "tcr2")], as.character)

### tabulate number of chains matching between cells
tcrLinksCircosQcCd8 <-
  tabulate_shared_TCR_chains(tcrChainMatchesCircosQcCd8) %>%
  dplyr::arrange(tcr1)

### create new data frame to store cell information (colors on various rings)
tcrCellsCircosQcCd8 <- tcrsCircosQcCd8

# Set up project colors for incorporation into tcr_cells
samplePalCircosQcCd8 <-
  big_colorblind_pal(length(unique(tcrsCircosQcCd8[, sampleColumnCircosQcCd8, drop = TRUE]))) %>%
  setNames(length(unique(tcrsCircosQcCd8[, sampleColumnCircosQcCd8, drop = TRUE])))

## set up color palette for sub-projects, using variations on a color scheme
# can use sample() around the colorRampPalette() calls to randomize the order of colors
samplePalCircosQcCd8 <-
  palDonorId[names(palDonorId) %in% tcrCellsCircosQcCd8$donorId]
tcrCellsCircosQcCd8$sampleCol <-
  samplePalCircosQcCd8[
    as.character(
      tcrCellsCircosQcCd8[
        , sampleColumnCircosQcCd8, drop = TRUE])]

groupPalCircosQcCd8 <-
  palCellTypeGroup[names(palCellTypeGroup) %in% tcrCellsCircosQcCd8$Cell.Type_CD8]
tcrCellsCircosQcCd8$groupCol <-
  groupPalCircosQcCd8[
    as.character(
      tcrCellsCircosQcCd8[
        , groupColumnCircosQcCd8, drop = TRUE])]

tcrCellsCircosQcCd8 <-
  unique(tcrCellsCircosQcCd8[, c("libid", "sampleCol", "groupCol")]) %>%
  dplyr::rename(tcr1 = libid)

tcrCellsCircosQcCd8$tcr1 <-
  factor(tcrCellsCircosQcCd8$tcr1,
    levels = gtools::mixedsort(tcrCellsCircosQcCd8$tcr1))
tcrCellsCircosQcCd8 <-
  tcrCellsCircosQcCd8 %>%
  dplyr::arrange(tcr1)

## set colors of links (average sample colors of the two TCRs)
tcrLinksCircosQcCd8$sampleCol <-
  cbind(
    tcrCellsCircosQcCd8$sampleCol[
      match(tcrLinksCircosQcCd8$tcr1, tcrCellsCircosQcCd8$tcr1)],
    tcrCellsCircosQcCd8$sampleCol[
      match(tcrLinksCircosQcCd8$tcr2, tcrCellsCircosQcCd8$tcr1)]) # %>%
# apply(MARGIN = 1, FUN = miscHelpers::average_colors)
```

```{r plotCircosQcCd8, dependson="createObjectsPlotCircosQcCd8"}
## generate a circos plot with individuals and patient groups labeled
filenamePlotCircosQcCd8 <-
  paste0("circosQcCd8_noMAIT_by_", groupColumnCircosQcCd8, "_and_", sampleColumnCircosQcCd8,
    ".", filenameSuffix, ".pdf")
plot_TCR_circos(
  tcrCellsCircosQcCd8, tcrLinksCircosQcCd8,
  ring_colors = c("sampleCol", "groupCol"),
  link_colors = "sampleCol", link_width = "num_shared_chains",
  filename = file.path(plotDir, filenamePlotCircosQcCd8))
```

```{r plotCircosLegendsQcCd8, dependson="createObjectsPlotCircosQcCd8"}
## output color legends for incorporation downstream
# easier to output them separately and merge them in Illustrator
filenameCircosLegend1QcCd8 <-
  paste0("circosQcCd8_noMAIT_legend_", sampleColumnCircosQcCd8,
    ".", filenameSuffix, ".pdf")
pdf(
  file.path(plotDir, filenameCircosLegend1QcCd8),
  w = 5, h = 8)
plot.new()

legend(
  x = "topleft",
  title = "Donor ID",
  legend = names(samplePalCircosQcCd8), fill = samplePalCircosQcCd8,
  bty = "n", xpd = TRUE)

# # version for splitting legend into two columns
# legend(
#   x = "topleft",
#   legend=
#     names(samplePalCircosQcCd8)[
#       1:floor(length(samplePalCircosQcCd8)/2)],
#   fill=
#     samplePalCircosQcCd8[
#       1:floor(length(samplePalCircosQcCd8)/2)],
#   bty = "n", xpd=TRUE)
# legend(
#   x = "topright",
#   legend
#   =names(samplePalCircosQcCd8)[
#     ceiling((length(samplePalCircosQcCd8)+1)/2):length(samplePalCircosQcCd8)],
#   fill=
#     samplePalCircosQcCd8[
#       ceiling((length(samplePalCircosQcCd8)+1)/2):length(samplePalCircosQcCd8)],
#   bty = "n", xpd=TRUE)
invisible(dev.off())

# legend for groups
filenameCircosLegend2QcCd8 <-
  paste0("circosQcCd8_legend_", groupColumnCircosQcCd8,
    ".", filenameSuffix, ".pdf")
pdf(
  file.path(plotDir, filenameCircosLegend2QcCd8),
  w = 3, h = 3)
plot.new()
legend(
  x = "topleft",
  title = "Study group",
  legend = names(palCellTypeGroup), fill = palCellTypeGroup,
  bty = "n", xpd = TRUE)
invisible(dev.off())
```

```{r circosWithBandWidth}
# Install and load the circlize package
# library(circlize)

# Example data preparation
# Assume you have a data frame `tcr_data` with columns: `cell1`, `cell2`, and `shared_tcr_count`
# `cell1` and `cell2` are the cell identifiers, and `shared_tcr_count` is the number of shared TCRs

# Example data
tcr_data <- data.frame(
  cell1 = c("A", "A", "B", "C"),
  cell2 = c("B", "C", "C", "D"),
  shared_tcr_count = c(5, 3, 2, 4)
)

# Define the plot directory and filename
filename <- file.path(plotDir, "circos_plot.png")

# Save the plot to a PNG file
png(filename = filename, width = 6, height = 5, units = "in", res = 600)

# Initialize the circos plot
circos.initialize(factors = unique(c(tcr_data$cell1, tcr_data$cell2)), xlim = c(0, 1))

# Add the circos track
circos.trackPlotRegion(factors = unique(c(tcr_data$cell1, tcr_data$cell2)), ylim = c(0, 1), panel.fun = function(x, y) {
  circos.axis()
})

# Add links with varying widths based on shared TCR count
for (i in 1:nrow(tcr_data)) {
  circos.link(
    sector.index1 = tcr_data$cell1[i],
    point1 = 0.5,
    sector.index2 = tcr_data$cell2[i],
    point2 = 0.5,
    col = "blue",
    lwd = tcr_data$shared_tcr_count[i]
  )
}

# Clear the circos plot
circos.clear()

# Close the PNG device
dev.off()
```